// Auto Gen
    
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// IntPtr ReAllocHGlobal(IntPtr, IntPtr)bool w_ppp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ppp");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef void* (*FuncToCall)(void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr NewObjectA(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_pppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pppPS_bi1ci2i4i8r4r8p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void* (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr NewObject(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_pppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pppS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef void* (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr ToReflectedMethod(IntPtr, IntPtr, Boolean)bool w_pppb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pppb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void* (*FuncToCall)(void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr, IntPtr, Int32)bool w_pppi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pppi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void* (*FuncToCall)(void* p1, void* p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr NewObject(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_pppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pppo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void* (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetConstructorID(IntPtr, System.String)bool w_pps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pps");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void* (*FuncToCall)(void* p1, Il2CppString* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetMethodID(IntPtr, System.String, System.Object[], Boolean)bool w_ppsob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ppsob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void* (*FuncToCall)(void* p1, Il2CppString* p2, Il2CppObject* p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetMethodID(IntPtr, System.String, System.String)bool w_ppss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ppss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void* (*FuncToCall)(void* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetMethodID(IntPtr, System.String, System.String, Boolean)bool w_ppssb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ppssb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void* (*FuncToCall)(void* p1, Il2CppString* p2, Il2CppString* p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr xlua_pushstruct(IntPtr, UInt32, Int32)bool w_ppu4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ppu4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void* (*FuncToCall)(void* p1, uint32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr Box(Single)bool w_pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr Box(Double)bool w_pr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pr8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(double p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr StringToBSTR(System.String)bool w_ps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ps");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef void* (*FuncToCall)(Il2CppString* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr FileOpen(System.String, Int32)bool w_psi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_psi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void* (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr CreateMarker(System.String, UInt16, Unity.Profiling.LowLevel.MarkerFlags, Int32)bool w_psu2u2i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_psu2u2i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void* (*FuncToCall)(Il2CppString* p1, uint16_t p2, uint16_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr get_Value()bool w_pt(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pt");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr SupportsInterface(System.Guid ByRef)bool w_ptPS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ptPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void* (*FuncToCall)(void*,void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetCOMIUnknown(Boolean)bool w_ptb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ptb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(void*,bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr GetNativeVertexBufferPtr(Int32)bool w_pti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(void*,int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// IntPtr Invoke(System.String, IntPtr)bool w_ptsp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ptsp");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef void* (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// UIntPtr op_Explicit(UInt32)bool w_pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pu4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(uint32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// UIntPtr op_Explicit(UInt64)bool w_pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pu8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(uint64_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Single get_avoidancePredictionTime()bool w_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.Object)bool w_r4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.Object, System.IFormatProvider)bool w_r4Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single VolatileRead(Single ByRef)bool w_r4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef float (*FuncToCall)(void* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Exchange(Single ByRef, Single)bool w_r4Pr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Pr4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single CompareExchange(Single ByRef, Single, Single)bool w_r4Pr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Pr4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void* p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.ReadOnlySpan`1[System.Byte])bool w_r4S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef float (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_r4S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef float (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DotCoordinate(System.Numerics.Plane, System.Numerics.Vector3)bool w_r4S_S_r4r4r4_r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_S_r4r4r4_r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Dot(System.Numerics.Plane, System.Numerics.Vector4)bool w_r4S_S_r4r4r4_r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_S_r4r4r4_r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistanceToCircle(UnityEditor.CameraProjectionCache, UnityEngine.Vector3, Single)bool w_r4S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Distance(UnityEngine.Vector2Int, UnityEngine.Vector2Int)bool w_r4S_i4i4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4i4_S_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef float (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Distance(UnityEngine.Vector3Int, UnityEngine.Vector3Int)bool w_r4S_i4i4i4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4i4i4_S_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
    typedef float (*FuncToCall)(struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.Decimal)bool w_r4S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef float (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single op_Explicit(System.Numerics.BigInteger)bool w_r4S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef float (*FuncToCall)(struct S_i4o_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Calculate(System.Diagnostics.CounterSample)bool w_r4S_i8i8i8i8i8i8i8i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i8i8i8i8i8i8i8i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp1 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(env, _sv1);
    S_i8i8i8i8i8i8i8i4_ p1 = pp1 ? *pp1 : S_i8i8i8i8i8i8i8i4_ {};
        
    typedef float (*FuncToCall)(struct S_i8i8i8i8i8i8i8i4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Calculate(System.Diagnostics.CounterSample, System.Diagnostics.CounterSample)bool w_r4S_i8i8i8i8i8i8i8i4_S_i8i8i8i8i8i8i8i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i8i8i8i8i8i8i8i4_S_i8i8i8i8i8i8i8i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp1 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(env, _sv1);
    S_i8i8i8i8i8i8i8i4_ p1 = pp1 ? *pp1 : S_i8i8i8i8i8i8i8i4_ {};
        
     // LuaValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp2 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(env, _sv2);
    S_i8i8i8i8i8i8i8i4_ p2 = pp2 ? *pp2 : S_i8i8i8i8i8i8i8i4_ {};
        
    typedef float (*FuncToCall)(struct S_i8i8i8i8i8i8i8i4_ p1, struct S_i8i8i8i8i8i8i8i4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SqrMagnitude(UnityEngine.Vector2)bool w_r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Dot(UnityEngine.Vector2, UnityEngine.Vector2)bool w_r4S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistancePointToLine(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2)bool w_r4S_r4r4_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single CalcLineTranslation(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector3, UnityEngine.Vector3)bool w_r4S_r4r4_S_r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_S_r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Knob(UnityEngine.Vector2, Single, Single, Single, System.String, UnityEngine.Color, UnityEngine.Color, Boolean, UnityEngine.GUILayoutOption[])bool w_r4S_r4r4_r4r4r4sS_r4r4r4r4_S_r4r4r4r4_bVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_r4r4r4sS_r4r4r4r4_S_r4r4r4r4_bVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv8)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    void* p9 = nullptr;        
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, float p2, float p3, float p4, Il2CppString* p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, bool p8, void* p9, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Magnitude(UnityEngine.Vector3)bool w_r4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3)bool w_r4S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)bool w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistancePointBezier(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)bool w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistanceToArc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)bool w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistanceToDisc(UnityEngine.Vector3, UnityEngine.Vector3, Single)bool w_r4S_r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistanceToCone(UnityEngine.Vector3, UnityEngine.Quaternion, Single)bool w_r4S_r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistanceToCircle(UnityEngine.Vector3, Single)bool w_r4S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Magnitude(UnityEngine.Vector4)bool w_r4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single RadiusHandle(UnityEngine.Quaternion, UnityEngine.Vector3, Single)bool w_r4S_r4r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single RadiusHandle(UnityEngine.Quaternion, UnityEngine.Vector3, Single, Boolean)bool w_r4S_r4r4r4r4_S_r4r4r4_r4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_S_r4r4r4_r4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, bool p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Dot(UnityEngine.Quaternion, UnityEngine.Quaternion)bool w_r4S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.Rect, UnityEngine.GUIContent, Single)bool w_r4S_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.Rect, UnityEngine.GUIContent, Single, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_or4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_or4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, float p3, Il2CppObject* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Slider(UnityEngine.Rect, UnityEngine.GUIContent, Single, Single, Single)bool w_r4S_r4r4r4r4_or4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_or4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.Rect, Single)bool w_r4S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.Rect, Single, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalSlider(UnityEngine.Rect, Single, Single, Single)bool w_r4S_r4r4r4r4_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalSlider(UnityEngine.Rect, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_r4r4r4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalSlider(UnityEngine.Rect, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_r4r4r4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4ooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalScrollbar(UnityEngine.Rect, Single, Single, Single, Single)bool w_r4S_r4r4r4r4_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalScrollbar(UnityEngine.Rect, Single, Single, Single, Single, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_r4r4r4r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, float p5, Il2CppObject* p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Slider(UnityEngine.Rect, Single, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUIStyle, Boolean, Int32, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_r4r4r4r4oobi4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_r4r4r4r4oobi4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 10) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv8)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv9)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(env, _sv9);        
        
 // LuaValToCSVal P any
    void* p10 = nullptr;        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, float p5, Il2CppObject* p6, Il2CppObject* p7, bool p8, int32_t p9, void* p10, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.Rect, System.String, Single)bool w_r4S_r4r4r4r4_sr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_sr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.Rect, System.String, Single, UnityEngine.GUIStyle)bool w_r4S_r4r4r4r4_sr4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_sr4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, float p3, Il2CppObject* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Slider(UnityEngine.Rect, System.String, Single, Single, Single)bool w_r4S_r4r4r4r4_sr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_sr4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Determinant(UnityEngine.Matrix4x4)bool w_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.DateTime)bool w_r4S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef float (*FuncToCall)(struct S_u8_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single DistanceToPolyLine(UnityEngine.Vector3[])bool w_r4VS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4VS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef float (*FuncToCall)(void* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Min(Single[])bool w_r4Vr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Vr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef float (*FuncToCall)(void* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Boolean)bool w_r4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(bool p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Char)bool w_r4c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(Il2CppChar p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(SByte)bool w_r4i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(int8_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Int16)bool w_r4i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(int16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Int32BitsToSingle(Int32)bool w_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPropertyHeight(UnityEditor.SerializedPropertyType, UnityEngine.GUIContent)bool w_r4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef float (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ScaleSlider(Int32, Single, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Single)bool w_r4i4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef float (*FuncToCall)(int32_t p1, float p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, float p6, float p7, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ScaleValueHandle(Int32, Single, UnityEngine.Vector3, UnityEngine.Quaternion, Single, CapFunction, Single)bool w_r4i4r4S_r4r4r4_S_r4r4r4r4_r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4r4S_r4r4r4_S_r4r4r4r4_r4or4");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef float (*FuncToCall)(int32_t p1, float p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, Il2CppObject* p6, float p7, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Int64)bool w_r4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(int64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ExtractInnerCone(UnityEngine.Light)bool w_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPropertyHeight(UnityEditor.SerializedProperty, Boolean)bool w_r4ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ob");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Byte[], Int32)bool w_r4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetRangeLimits(UnityEngine.Shader, Int32, Int32)bool w_r4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent)bool w_r4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent, Boolean)bool w_r4oob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4oob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetLayoutProperty(UnityEngine.RectTransform, System.Func`2[UnityEngine.UI.ILayoutElement,System.Single], Single)bool w_r4oor4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4oor4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetLayoutProperty(UnityEngine.RectTransform, System.Func`2[UnityEngine.UI.ILayoutElement,System.Single], Single, UnityEngine.UI.ILayoutElement ByRef)bool w_r4oor4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4oor4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
        
    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, void* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.GUIContent, Single, UnityEngine.GUILayoutOption[])bool w_r4or4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, float p2, void* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(UnityEngine.GUIContent, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r4or4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, float p2, Il2CppObject* p3, void* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetNextKeyframeTime(UnityEditorInternal.AnimationWindowCurve[], Single, Single)bool w_r4or4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Slider(UnityEngine.GUIContent, Single, Single, Single, UnityEngine.GUILayoutOption[])bool w_r4or4r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4r4r4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef float (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, void* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloatArrayElement(IntPtr, Int32)bool w_r4pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void* p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloatField(IntPtr, IntPtr)bool w_r4pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef float (*FuncToCall)(void* p1, void* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single CallFloatMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_r4ppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef float (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single CallFloatMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_r4ppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef float (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single CallFloatMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_r4ppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef float (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Single)bool w_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ScaleSlider(Single, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Single)bool w_r4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4r4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef float (*FuncToCall)(float p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ScaleValueHandle(Single, UnityEngine.Vector3, UnityEngine.Quaternion, Single, CapFunction, Single)bool w_r4r4S_r4r4r4_S_r4r4r4r4_r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4S_r4r4r4_S_r4r4r4r4_r4or4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef float (*FuncToCall)(float p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, Il2CppObject* p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(Single, UnityEngine.GUILayoutOption[])bool w_r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4Vo");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef float (*FuncToCall)(float p1, void* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Round(Single, Int32)bool w_r4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(float p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Round(Single, Int32, System.MidpointRounding)bool w_r4r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(float p1, int32_t p2, int32_t p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r4r4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4oVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef float (*FuncToCall)(float p1, Il2CppObject* p2, void* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Max(Single, Single)bool w_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single)bool w_r4r4r4Pr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef float (*FuncToCall)(float p1, float p2, void* p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single, Single)bool w_r4r4r4Pr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef float (*FuncToCall)(float p1, float p2, void* p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single, Single, Single)bool w_r4r4r4Pr4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4r4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef float (*FuncToCall)(float p1, float p2, void* p3, float p4, float p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Clamp(Single, Single, Single)bool w_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalSlider(Single, Single, Single, UnityEngine.GUILayoutOption[])bool w_r4r4r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4Vo");
    
    auto TIp4 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, void* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalSlider(Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r4r4r4r4ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4ooVo");
    
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, Il2CppObject* p4, Il2CppObject* p5, void* p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalScrollbar(Single, Single, Single, Single, UnityEngine.GUILayoutOption[])bool w_r4r4r4r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4Vo");
    
    auto TIp5 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, void* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single HorizontalScrollbar(Single, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r4r4r4r4r4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4oVo");
    
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, Il2CppObject* p5, void* p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Double)bool w_r4r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(double p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.String)bool w_r4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef float (*FuncToCall)(Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Parse(System.String, System.Globalization.NumberStyles)bool w_r4si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_r4si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef float (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.String, System.IFormatProvider)bool w_r4so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef float (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloat(System.String, Single)bool w_r4sr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(System.String, Single, UnityEngine.GUILayoutOption[])bool w_r4sr4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef float (*FuncToCall)(Il2CppString* p1, float p2, void* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatField(System.String, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r4sr4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef float (*FuncToCall)(Il2CppString* p1, float p2, Il2CppObject* p3, void* p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Slider(System.String, Single, Single, Single, UnityEngine.GUILayoutOption[])bool w_r4sr4r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4r4r4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef float (*FuncToCall)(Il2CppString* p1, float p2, float p3, float p4, void* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ReadSingle()bool w_r4t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(System.Object)bool w_r4tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetMuscle(UnityEngine.Animations.MuscleHandle)bool w_r4tS_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetAnimationTime(UnityEngine.Vector3Int)bool w_r4tS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloat(Unity.Profiling.Stats.Counter)bool w_r4tS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef float (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SqrDistance(UnityEngine.Vector3)bool w_r4tS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single PointOcclusion(UnityEngine.Vector3, UnityEngine.Vector3)bool w_r4tS_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FrameDeltaToPixel(UnityEngine.Rect)bool w_r4tS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ValueField(UnityEngine.Rect, Int32, Single)bool w_r4tS_r4r4r4r4_i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, int32_t p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single TimeField(UnityEngine.Rect, Int32, Single, Single, TimeFormat)bool w_r4tS_r4r4r4r4_i4r4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_i4r4r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, int32_t p2, float p3, float p4, int32_t p5, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single TextureScaleOffsetProperty(UnityEngine.Rect, UnityEditor.MaterialProperty)bool w_r4tS_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single TextureScaleOffsetProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, Boolean)bool w_r4tS_r4r4r4r4_ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_ob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single RangeProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String)bool w_r4tS_r4r4r4r4_os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4r4_os");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef float (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloat(UnityEngine.Animations.AnimationStream)bool w_r4tS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_u4pppppp_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
    typedef float (*FuncToCall)(void*,struct S_u4pppppp_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetLayerCost(Int32)bool w_r4ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(void*,int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetBlendShapeFrameWeight(Int32, Int32)bool w_r4ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetItemMergedSamplesMetadataAsFloat(Int32, Int32, Int32)bool w_r4ti4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single SetAnimation(Int32, System.String, Boolean)bool w_r4ti4sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4sb");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ReadSingle(Int64)bool w_r4ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(void*,int64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetNodeHeight(UnityEditorInternal.AnimationWindowHierarchyNode)bool w_r4to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4to");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_r4toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4toS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPropertyHeight(UnityEditor.SerializedProperty, UnityEngine.GUIContent)bool w_r4too(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4too");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single CalcHeight(UnityEngine.GUIContent, Single)bool w_r4tor4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tor4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetRadiusAtTime(TreeEditor.TreeNode, Single, Boolean)bool w_r4tor4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tor4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, float p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single RangeProperty(UnityEditor.MaterialProperty, System.String)bool w_r4tos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tos");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPropertyHeight(UnityEditor.MaterialProperty, System.String, UnityEditor.MaterialEditor)bool w_r4toso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4toso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Evaluate(Single)bool w_r4tr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(void*,float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FrameToPixel(Single, UnityEngine.Rect)bool w_r4tr4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4S_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,float p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single PixelToTime(Single, SnapMode)bool w_r4tr4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void*,float p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetInterpolatedHeight(Single, Single)bool w_r4tr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void*,float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FrameToPixel(Single, Single, UnityEngine.Rect)bool w_r4tr4r4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4S_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,float p1, float p2, struct S_r4r4r4r4_ p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single Noise(Single, Single, Single)bool w_r4tr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef float (*FuncToCall)(void*,float p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single RidgedMultifractal(Single, Single, Single, Single)bool w_r4tr4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef float (*FuncToCall)(void*,float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetSingle(System.String)bool w_r4ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef float (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPreferredWidth(System.String, UnityEngine.TextGenerationSettings ByRef)bool w_r4tsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p2 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloat(System.String, Boolean ByRef)bool w_r4tsPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsPb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetPreferredWidth(System.String, UnityEngine.TextGenerationSettings)bool w_r4tsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* pp2 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, _sv2);
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2 = pp2 ? *pp2 : S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ {};
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetFloat(System.String, Single)bool w_r4tsr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single FloatProperty(System.String, System.String)bool w_r4tss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef float (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single RangeProperty(System.String, System.String, Single, Single)bool w_r4tssr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tssr4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single GetDirectAudioVolume(UInt16)bool w_r4tu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tu2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(void*,uint16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(Byte)bool w_r4u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(uint8_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(UInt16)bool w_r4u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(uint16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(UInt32)bool w_r4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(uint32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Single ToSingle(UInt64)bool w_r4u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef float (*FuncToCall)(uint64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<float>::toScript(env, ret));        return true;
}
// Double get_dspTime()bool w_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.Object)bool w_r8O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef double (*FuncToCall)(Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.Object, System.IFormatProvider)bool w_r8Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef double (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double VolatileRead(Double ByRef)bool w_r8Pr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8Pr8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef double (*FuncToCall)(void* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Exchange(Double ByRef, Double)bool w_r8Pr8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8Pr8r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(void* p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double CompareExchange(Double ByRef, Double, Double)bool w_r8Pr8r8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8Pr8r8r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
    typedef double (*FuncToCall)(void* p1, double p2, double p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.ReadOnlySpan`1[System.Byte])bool w_r8S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef double (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_r8S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef double (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double op_Explicit(UnityEditor.Media.MediaRational)bool w_r8S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef double (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.Decimal)bool w_r8S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef double (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Log(System.Numerics.BigInteger)bool w_r8S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef double (*FuncToCall)(struct S_i4o_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Log(System.Numerics.BigInteger, Double)bool w_r8S_i4o_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4o_r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(struct S_i4o_ p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double op_Explicit(UnityEditor.Media.MediaTime)bool w_r8S_i8S_i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i8S_i4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8S_i4i4__* pp1 = DataTransfer::GetPointer<S_i8S_i4i4__>(env, _sv1);
    S_i8S_i4i4__ p1 = pp1 ? *pp1 : S_i8S_i4i4__ {};
        
    typedef double (*FuncToCall)(struct S_i8S_i4i4__ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double op_Division(System.TimeSpan, System.TimeSpan)bool w_r8S_i8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i8_S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef double (*FuncToCall)(struct S_i8_ p1, struct S_i8_ p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.Rect, UnityEngine.GUIContent, Double)bool w_r8S_r4r4r4r4_or8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_or8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, double p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.Rect, UnityEngine.GUIContent, Double, UnityEngine.GUIStyle)bool w_r8S_r4r4r4r4_or8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_or8o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, double p3, Il2CppObject* p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.Rect, Double)bool w_r8S_r4r4r4r4_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.Rect, Double, UnityEngine.GUIStyle)bool w_r8S_r4r4r4r4_r8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_r8o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p1, double p2, Il2CppObject* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.Rect, System.String, Double)bool w_r8S_r4r4r4r4_sr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_sr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, double p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.Rect, System.String, Double, UnityEngine.GUIStyle)bool w_r8S_r4r4r4r4_sr8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r4r4r4r4_sr8o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef double (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, double p3, Il2CppObject* p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Abs(System.Numerics.Complex)bool w_r8S_r8r8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_r8r8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
        
    typedef double (*FuncToCall)(struct S_r8r8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.DateTime)bool w_r8S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef double (*FuncToCall)(struct S_u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Boolean)bool w_r8b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(bool p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetNumericValue(Char)bool w_r8c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(Il2CppChar p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(SByte)bool w_r8i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(int8_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Int16)bool w_r8i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(int16_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Int32)bool w_r8i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Int64BitsToDouble(Int64)bool w_r8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(int64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.Xml.XPath.XPathItem)bool w_r8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8o");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef double (*FuncToCall)(Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Byte[], Int32)bool w_r8oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.GUIContent, Double, UnityEngine.GUILayoutOption[])bool w_r8or8Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8or8Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef double (*FuncToCall)(Il2CppObject* p1, double p2, void* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(UnityEngine.GUIContent, Double, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r8or8oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8or8oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef double (*FuncToCall)(Il2CppObject* p1, double p2, Il2CppObject* p3, void* p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetDoubleArrayElement(IntPtr, Int32)bool w_r8pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(void* p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetDoubleField(IntPtr, IntPtr)bool w_r8pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef double (*FuncToCall)(void* p1, void* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double CallDoubleMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_r8ppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef double (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double CallDoubleMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_r8ppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef double (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double CallDoubleMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_r8ppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef double (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Single)bool w_r8r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(float p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Double)bool w_r8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double StaticVariableParamFuncDefault(Double, Double, System.String[])bool w_r8r8Dr8Vs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8Dr8Vs");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef double (*FuncToCall)(double p1, void* p2, void* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(Double, UnityEngine.GUILayoutOption[])bool w_r8r8Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8Vo");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef double (*FuncToCall)(double p1, void* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Round(Double, Int32)bool w_r8r8i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(double p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Round(Double, Int32, System.MidpointRounding)bool w_r8r8i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef double (*FuncToCall)(double p1, int32_t p2, int32_t p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(Double, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r8r8oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8oVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef double (*FuncToCall)(double p1, Il2CppObject* p2, void* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double IEEERemainder(Double, Double)bool w_r8r8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(double p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Clamp(Double, Double, Double)bool w_r8r8r8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8r8r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
    typedef double (*FuncToCall)(double p1, double p2, double p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.String)bool w_r8s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef double (*FuncToCall)(Il2CppString* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetNumericValue(System.String, Int32)bool w_r8si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_r8si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef double (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.String, System.IFormatProvider)bool w_r8so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef double (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(System.String, Double, UnityEngine.GUILayoutOption[])bool w_r8sr8Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8sr8Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef double (*FuncToCall)(Il2CppString* p1, double p2, void* p3, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double DoubleField(System.String, Double, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_r8sr8oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8sr8oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef double (*FuncToCall)(Il2CppString* p1, double p2, Il2CppObject* p3, void* p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double MSStringCompare(System.String, System.String, System.String, System.String)bool w_r8ssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ssss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef double (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToOADate()bool w_r8t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetNumberValue(Double)bool w_r8tDr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tDr8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef double (*FuncToCall)(void*,void* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(System.Object)bool w_r8tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef double (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ComplexFunc(Tutorial.Param1, Int32 ByRef, System.String ByRef, System.Action, System.Action ByRef)bool w_r8tS_i4s_Pi4PsoPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tS_i4s_Pi4PsoPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv5)); // object ret
    Il2CppObject** p5 = &up5;
        
    typedef double (*FuncToCall)(void*,struct S_i4s_ p1, void* p2, void* p3, Il2CppObject* p4, void* p5, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double Divide(System.TimeSpan)bool w_r8tS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef double (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetMilliseconds(System.DateTime)bool w_r8tS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef double (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetFrameStartS(Int32)bool w_r8ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(void*,int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetItemColumnDataAsDouble(Int32, Int32)bool w_r8ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ti4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ReadDouble(Int64)bool w_r8ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(void*,int64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_r8toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8toS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef double (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double NextDouble(Double)bool w_r8tr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tr8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(void*,double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double NextDouble(Double, Double)bool w_r8tr8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tr8r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef double (*FuncToCall)(void*,double p1, double p2, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double GetDouble(System.String)bool w_r8ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef double (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ReadElementContentAsDouble(System.String, System.String)bool w_r8tss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef double (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double RegisterDecimalFormatter(System.String, System.String, System.String, System.String)bool w_r8tssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8tssss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef double (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(Byte)bool w_r8u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(uint8_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(UInt16)bool w_r8u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(uint16_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(UInt32)bool w_r8u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(uint32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// Double ToDouble(UInt64)bool w_r8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef double (*FuncToCall)(uint64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<double>::toScript(env, ret));        return true;
}
// System.String get_BaseDirectory()bool w_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_s");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppString* (*FuncToCall)(const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.Object)bool w_sO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.Object, System.Object)bool w_sOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.Object, System.Object, System.Object)bool w_sOOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.Object, System.Object, System.Object, System.Object, ...)bool w_sOOOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOOOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                                                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToJson(System.Object, Boolean)bool w_sOb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.Object, System.IFormatProvider)bool w_sOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ConvertDefaultValueToString(System.Object, System.String)bool w_sOs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetAssetPath(UnityEditor.Search.SearchItem ByRef)bool w_sPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sPo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef Il2CppString* (*FuncToCall)(void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToBase64String(System.ReadOnlySpan`1[System.Byte], System.Base64FormattingOptions)bool w_sS_S_p_i4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char])bool w_sS_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char])bool w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.DateTimeOffset)bool w_sS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_u8_i2_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.DateTimeOffset, System.String)bool w_sS_S_u8_i2_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_u8_i2_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(struct S_S_u8_i2_ p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String op_Explicit(UnityEngine.Rendering.ShaderTagId)bool w_sS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.Guid)bool w_sS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.Decimal)bool w_sS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.Decimal, System.IFormatProvider)bool w_sS_i4i4i4i4u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.TimeSpan)bool w_sS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_i8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetWriterName(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle)bool w_sS_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_pi4i4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetReaderName(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, Int32)bool w_sS_pi4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_pi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(struct S_pi4i4_ p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToHtmlStringRGB(UnityEngine.Color)bool w_sS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String DelayedTextField(UnityEngine.Rect, UnityEngine.GUIContent, Int32, System.String)bool w_sS_r4r4r4r4_oi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_oi4s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String DelayedTextField(UnityEngine.Rect, UnityEngine.GUIContent, Int32, System.String, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_oi4so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_oi4so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, UnityEngine.GUIContent, System.String)bool w_sS_r4r4r4r4_os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_os");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, UnityEngine.GUIContent, System.String, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_oso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_oso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, System.String)bool w_sS_r4r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(UnityEngine.Rect, System.String, Char)bool w_sS_r4r4r4r4_sc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sc");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    Il2CppChar p3 = converter::Converter<Il2CppChar>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppChar p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(UnityEngine.Rect, System.String, Char, Int32)bool w_sS_r4r4r4r4_sci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sci4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    Il2CppChar p3 = converter::Converter<Il2CppChar>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppChar p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(UnityEngine.Rect, System.String, Char, Int32, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_sci4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sci4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    Il2CppChar p3 = converter::Converter<Il2CppChar>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppChar p3, int32_t p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(UnityEngine.Rect, System.String, Char, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_sco(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sco");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    Il2CppChar p3 = converter::Converter<Il2CppChar>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppChar p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, System.String, Int32)bool w_sS_r4r4r4r4_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_si4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, System.String, Int32, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_si4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, System.String, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, System.String, System.String)bool w_sS_r4r4r4r4_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.Rect, System.String, System.String, UnityEngine.GUIStyle)bool w_sS_r4r4r4r4_sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_sso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget)bool w_sS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_s_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_s_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetNicePropertyDisplayName(UnityEditor.EditorCurveBinding, UnityEditor.SerializedObject)bool w_sS_sosi4i4i4i4i4i4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_sosi4i4i4i4i4i4i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetGlobalKeywordName(UnityEngine.Rendering.ShaderKeyword)bool w_sS_su4bbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_su4bbb_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_su4bbb_* pp1 = DataTransfer::GetPointer<S_su4bbb_>(env, _sv1);
    S_su4bbb_ p1 = pp1 ? *pp1 : S_su4bbb_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_su4bbb_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.Collections.Specialized.BitVector32)bool w_sS_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_u4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GUIDToAssetPath(UnityEditor.GUID)bool w_sS_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_u4u4u4u4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.DateTime)bool w_sS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.DateTime, System.Xml.XmlDateTimeSerializationMode)bool w_sS_u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.DateTime, System.IFormatProvider)bool w_sS_u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.DateTime, System.String)bool w_sS_u8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString()bool w_sT(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sT");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppString* (*FuncToCall)(void*,const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.Object[])bool w_sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.String[])bool w_sVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sVs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean)bool w_sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, System.IFormatProvider)bool w_sbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sbo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Char)bool w_sc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sc");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(Char, System.Object[])bool w_scVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(Char, System.String[])bool w_scVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scVs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Char, System.IFormatProvider)bool w_sco(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sco");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(Char, System.String[], Int32, Int32)bool w_scoi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scoi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(SByte)bool w_si1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(int8_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(SByte, System.IFormatProvider)bool w_si1o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si1o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int8_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int16)bool w_si2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(int16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int16, Int32)bool w_si2i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(int16_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int16, System.IFormatProvider)bool w_si2o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int16_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ConvertFromUtf32(Int32)bool w_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String DoPasswordField(Int32, UnityEngine.Rect, UnityEngine.GUIContent, System.String, UnityEngine.GUIStyle)bool w_si4S_r4r4r4r4_oso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4S_r4r4r4r4_oso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppString* p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String DoPasswordField(Int32, UnityEngine.Rect, System.String, UnityEngine.GUIStyle)bool w_si4S_r4r4r4r4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4S_r4r4r4r4_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int32, Int32)bool w_si4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetPlaybackEngineDirectory(UnityEditor.BuildTarget, UnityEditor.BuildOptions, Boolean)bool w_si4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetPlaybackEngineDirectory(UnityEditor.BuildTargetGroup, UnityEditor.BuildTarget, UnityEditor.BuildOptions)bool w_si4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetPlaybackEngineDirectory(UnityEditor.BuildTargetGroup, UnityEditor.BuildTarget, UnityEditor.BuildOptions, Boolean)bool w_si4i4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, bool p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetFormattedCounterValue(Int32, UnityEngine.Profiling.ProfilerArea, System.String)bool w_si4i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int32, System.IFormatProvider)bool w_si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetFormattedCounterValue(Int32, System.String, System.String)bool w_si4ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind, System.String, System.String, System.Exception)bool w_si4sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4sso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int64)bool w_si8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(int64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int64, Int32)bool w_si8i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(int64_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Int64, System.IFormatProvider)bool w_si8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.Collections.Generic.IEnumerable`1[System.String])bool w_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetHierarchyPath(UnityEngine.GameObject, Boolean)bool w_soDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetMethodSignature(System.Reflection.MethodBase, Boolean, Boolean)bool w_soDbDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soDbDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GameObjectPath(UnityEngine.GameObject, Int32)bool w_soDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetName(System.Type, System.Object)bool w_soO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.Type, System.Object, System.String)bool w_soOs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soOs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetKeywordName(UnityEngine.Shader, UnityEngine.Rendering.ShaderKeyword)bool w_soS_su4bbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soS_su4bbb_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_su4bbb_* pp2 = DataTransfer::GetPointer<S_su4bbb_>(env, _sv2);
    S_su4bbb_ p2 = pp2 ? *pp2 : S_su4bbb_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, struct S_su4bbb_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetInspectorTitle(UnityEngine.Object, Boolean)bool w_sob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Mono.Security.ASN1, Boolean, System.String, Boolean)bool w_sobsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sobsb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, bool p2, Il2CppString* p3, bool p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Byte[], Int32)bool w_soi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Byte[], Int32, Int32)bool w_soi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToBase64String(Byte[], Int32, Int32, System.Base64FormattingOptions)bool w_soi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String UrlDecode(Byte[], Int32, Int32, System.Text.Encoding)bool w_soi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String CalculateTransformPath(UnityEngine.Transform, UnityEngine.Transform)bool w_soo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String CreateFromDataContractSerializer(System.Type, System.Reflection.MemberInfo[], System.Xml.XmlNamespaceManager ByRef)bool w_sooPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sooPo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String CreateFromDataContractSerializer(System.Type, System.Reflection.MemberInfo[], System.Text.StringBuilder, System.Xml.XmlNamespaceManager ByRef)bool w_soooPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soooPo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String FormatItem(UnityEditor.Search.SearchContext, UnityEditor.Search.SearchItem, System.String)bool w_soos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GenerateManifest(System.Type, System.String)bool w_sos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object)bool w_sosO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object)bool w_sosOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object, System.Object)bool w_sosOOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosOOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object[])bool w_sosVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.GUIContent, System.String, UnityEngine.GUILayoutOption[])bool w_sosVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GenerateManifest(System.Type, System.String, System.Diagnostics.Tracing.EventManifestOptions)bool w_sosi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String BuildStreamedSceneAssetBundle(System.String[], System.String, UnityEditor.BuildTarget, UInt32 ByRef)bool w_sosi4Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4Pu4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, int32_t p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String BuildStreamedSceneAssetBundle(System.String[], System.String, UnityEditor.BuildTarget, UInt32 ByRef, UnityEditor.BuildOptions)bool w_sosi4Pu4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4Pu4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, int32_t p3, void* p4, int32_t p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String BuildStreamedSceneAssetBundle(System.String[], System.String, UnityEditor.BuildTarget, UnityEditor.BuildOptions)bool w_sosi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(UnityEngine.GUIContent, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_sosoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosoVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PtrToStringAnsi(IntPtr)bool w_sp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sp");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PtrToStringAnsi(IntPtr, Int32)bool w_spi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_spi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetStringField(IntPtr, IntPtr)bool w_spp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_spp");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String CallStringMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_sppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sppPS_bi1ci2i4i8r4r8p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef Il2CppString* (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String CallStringMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_sppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sppS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String CallStringMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_sppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sppo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Single)bool w_sr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(float p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Single, System.IFormatProvider)bool w_sr4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(float p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Double)bool w_sr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(double p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Double, System.IFormatProvider)bool w_sr8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr8o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(double p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Copy(System.String)bool w_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.String, System.Object)bool w_ssO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.String, System.Object, System.Object)bool w_ssOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.String, System.Object, System.Object, System.Object)bool w_ssOOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssOOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                                                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Format(System.String, System.Object[])bool w_ssVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(System.String, UnityEngine.GUILayoutOption[])bool w_ssVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(System.String, System.String[])bool w_ssVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String RemoveInvalidCharsFromFileName(System.String, Boolean)bool w_ssb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(System.String, Char, UnityEngine.GUILayoutOption[])bool w_sscVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sscVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppChar p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(System.String, Char, Int32, UnityEngine.GUILayoutOption[])bool w_ssci4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssci4Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppChar p2, int32_t p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(System.String, Char, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_ssci4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssci4oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppChar p2, int32_t p3, Il2CppObject* p4, void* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PasswordField(System.String, Char, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_sscoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sscoVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppChar p2, Il2CppObject* p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetEnvironmentVariable(System.String, System.EnvironmentVariableTarget)bool w_ssi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(System.String, Int32, UnityEngine.GUILayoutOption[])bool w_ssi4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String MakeVersionSafeName(System.String, System.Runtime.Versioning.ResourceScope, System.Runtime.Versioning.ResourceScope)bool w_ssi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String MakeVersionSafeName(System.String, System.Runtime.Versioning.ResourceScope, System.Runtime.Versioning.ResourceScope, System.Type)bool w_ssi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4i4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(System.String, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_ssi4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(System.String, System.Collections.Generic.IEnumerable`1[System.String])bool w_sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_ssoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssoVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Join(System.String, System.String[], Int32, Int32)bool w_ssoi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssoi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Substring(System.String, Double)bool w_ssr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssr8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, double p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Substring(System.String, Double, Double)bool w_ssr8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssr8r8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, double p2, double p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.String, System.String)bool w_sss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(System.String, System.String, UnityEngine.GUILayoutOption[])bool w_sssVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ParseArgument(System.String, System.String, Int32, Int32)bool w_sssi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String OpenFilePanelWithFilters(System.String, System.String, System.String[])bool w_ssso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String TextField(System.String, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_sssoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, void* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions)bool w_sssoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)bool w_sssoi4S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_i8_* pp5 = DataTransfer::GetPointer<S_i8_>(env, _sv5);
    S_i8_ p5 = pp5 ? *pp5 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, struct S_i8_ p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.String, System.String, System.String)bool w_ssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String MSFormatDateTime(System.String, System.String, System.String, Boolean)bool w_ssssb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, bool p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetRegistryStringValue(System.String, System.String, System.String, UnityEditorInternal.RegistryView)bool w_ssssi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)bool w_ssssi4S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_i8_* pp5 = DataTransfer::GetPointer<S_i8_>(env, _sv5);
    S_i8_ p5 = pp5 ? *pp5 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, struct S_i8_ p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Concat(System.String, System.String, System.String, System.String)bool w_sssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String SaveFilePanelInProject(System.String, System.String, System.String, System.String, System.String)bool w_ssssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String InvokeDiffTool(System.String, System.String, System.String, System.String, System.String, System.String)bool w_sssssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssssss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
     // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(env, _sv6);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String get_Name()bool w_st(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_st");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppString* (*FuncToCall)(void*,const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String InQuotes(NiceIO.SlashMode)bool w_stDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetFriendlyName(System.Type, System.Type[])bool w_stDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ResolveAlias(System.String)bool w_stDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetEnumName(System.Object)bool w_stO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetString(Byte*, Int32)bool w_stPu1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stPu1i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetString(System.ReadOnlySpan`1[System.Byte])bool w_stS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetArtifactFilePath(UnityEditor.Experimental.ArtifactKey, System.String)bool w_stS_S_u4u4u4u4_o_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stS_S_u4u4u4u4_o_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_u4u4u4u4_o_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(env, _sv1);
    S_S_u4u4u4u4_o_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_o_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,struct S_S_u4u4u4u4_o_ p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String OnGUI(UnityEngine.Rect, System.String)bool w_stS_r4r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stS_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String OnGUI(UnityEngine.Rect, System.String, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUIStyle)bool w_stS_r4r4r4r4_sooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stS_r4r4r4r4_sooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppString* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetCertHashString(System.Security.Cryptography.HashAlgorithmName)bool w_stS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stS_s_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef Il2CppString* (*FuncToCall)(void*,struct S_s_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetArtifactFilePath(UnityEditor.GUID, System.String)bool w_stS_u4u4u4u4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stS_u4u4u4u4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,struct S_u4u4u4u4_ p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Trim(Char[])bool w_stVc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stVc");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToXmlString(Boolean)bool w_stb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, Int32)bool w_stbDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, Boolean)bool w_stbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, Boolean, Int32)bool w_stbbDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbbDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, bool p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, Boolean, Boolean, Int32, Int32)bool w_stbbbi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbbbi4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, bool p2, bool p3, int32_t p4, int32_t p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, Boolean, Int32, Int32)bool w_stbbi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbbi4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, bool p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Indent(System.String, Boolean, Int32)bool w_stbi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbi4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Boolean, Int32, Int32)bool w_stbi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbi4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Trim(Char)bool w_stc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stc");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(Char, Char)bool w_stcc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stcc");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PadLeft(Int32)bool w_sti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType, Boolean)bool w_sti4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String PadLeft(Int32, Char)bool w_sti4c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4c");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Remove(Int32, Int32)bool w_sti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetItemMergedSamplesMetadata(Int32, Int32, Int32)bool w_sti4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Insert(Int32, System.String)bool w_sti4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToLower(System.Globalization.CultureInfo)bool w_sto(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sto");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetLabel(UnityEditor.Search.SearchContext, Boolean)bool w_stoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ResolveAlias(UnityEditor.Search.SearchExpression, System.String)bool w_stoDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoDs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ConvertToInvariantString(System.ComponentModel.ITypeDescriptorContext, System.Object)bool w_stoO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ReadContentAsString(System.String[], Int32 ByRef)bool w_stoPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoPi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_stoS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoS_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ImportAnyElement(System.Xml.Schema.XmlSchemaAny, Boolean, System.Xml.Serialization.XmlSchemas, System.Xml.Serialization.XmlSchemaImporter, System.CodeDom.CodeCompileUnit, System.CodeDom.CodeNamespace, System.Xml.Serialization.CodeGenerationOptions, System.CodeDom.Compiler.CodeDomProvider)bool w_stobooooi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stobooooi4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, int32_t p7, Il2CppObject* p8, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetString(Byte[], Int32, Int32)bool w_stoi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetSavedLicenseKey(System.Type, System.Reflection.Assembly)bool w_stoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ConvertToString(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.Object)bool w_stooO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stooO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ImportSchemaType(System.Xml.Schema.XmlSchemaType, System.Xml.Schema.XmlSchemaObject, System.Xml.Serialization.XmlSchemas, System.Xml.Serialization.XmlSchemaImporter, System.CodeDom.CodeCompileUnit, System.CodeDom.CodeNamespace, System.Xml.Serialization.CodeGenerationOptions, System.CodeDom.Compiler.CodeDomProvider)bool w_stooooooi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stooooooi4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, int32_t p7, Il2CppObject* p8, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String UploadString(System.Uri, System.String)bool w_stos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String NumberFormat(System.Collections.Generic.IList`1[System.Xml.XPath.XPathItem], System.String, Double, System.String, System.String, Double)bool w_stosr8ssr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stosr8ssr8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!converter::Converter<double>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
 // LuaValToCSVal P any
    double p6 = converter::Converter<double>::toCpp(env, _sv6);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, double p3, Il2CppString* p4, Il2CppString* p5, double p6, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String UploadString(System.Uri, System.String, System.String)bool w_stoss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stoss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String FormatValue(Single)bool w_str4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_str4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void*,float p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String FormatTime(Single, Single, TimeFormat)bool w_str4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_str4r4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,float p1, float p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String FormatNumberStatic(Double, Double)bool w_str8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_str8r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,double p1, double p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String FormatNumberDynamic(Double, System.String, System.Xml.XmlQualifiedName, System.String)bool w_str8sos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_str8sos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef Il2CppString* (*FuncToCall)(void*,double p1, Il2CppString* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.String)bool w_sts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String AddUnique(System.String, System.Object)bool w_stsO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String OnGUI(System.String, UnityEngine.GUILayoutOption[])bool w_stsVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetString(System.String, Boolean)bool w_stsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetTag(System.String, Boolean, System.String)bool w_stsbDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsbDs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetTag(System.String, Boolean, System.String)bool w_stsbs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsbs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetAscii(System.String, Int32)bool w_stsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetAscii(System.String, Int32, Int32)bool w_stsi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(System.String, System.IFormatProvider)bool w_stso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32)bool w_stsoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32, Int32)bool w_stsoi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String DecryptSection(System.String, System.Configuration.ProtectedConfigurationProvider, System.Configuration.ProtectedConfigurationSection)bool w_stsoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String)bool w_stss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String, Boolean, System.Globalization.CultureInfo)bool w_stssbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssbo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String, System.StringComparison)bool w_stssi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String Replace(System.String, System.String, Int32, Int32)bool w_stssi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ImportSchemaType(System.String, System.String, System.Xml.Schema.XmlSchemaObject, System.Xml.Serialization.XmlSchemas, System.Xml.Serialization.XmlSchemaImporter, System.CodeDom.CodeCompileUnit, System.CodeDom.CodeNamespace, System.Xml.Serialization.CodeGenerationOptions, System.CodeDom.Compiler.CodeDomProvider)bool w_stssoooooi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssoooooi4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp9 = wrapData->TypeInfos[9];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, int32_t p8, Il2CppObject* p9, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String UploadString(System.String, System.String, System.String)bool w_stsss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String GetAudioLanguage(UInt16)bool w_stu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void*,uint16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt32)bool w_stu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt32, System.String)bool w_stu4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu4s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Byte)bool w_su1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(uint8_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Byte, Int32)bool w_su1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppString* (*FuncToCall)(uint8_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(Byte, System.IFormatProvider)bool w_su1o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(uint8_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt16)bool w_su2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(uint16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt16, System.IFormatProvider)bool w_su2o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su2o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(uint16_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt32)bool w_su4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt32, System.IFormatProvider)bool w_su4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt64)bool w_su8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef Il2CppString* (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// System.String ToString(UInt64, System.IFormatProvider)bool w_su8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppString* (*FuncToCall)(uint64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppString*>::toScript(env, ret));        return true;
}
// Byte get_Revision()bool w_u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint8_t (*FuncToCall)(const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(System.Object)bool w_u1O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ReadByte(System.Object, Int32)bool w_u1Oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1Oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(System.Object, System.IFormatProvider)bool w_u1Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte VolatileRead(Byte ByRef)bool w_u1Pu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1Pu1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef uint8_t (*FuncToCall)(void* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_u1S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef uint8_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(System.Decimal)bool w_u1S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte op_Explicit(System.Numerics.BigInteger)bool w_u1S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(System.DateTime)bool w_u1S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Boolean)bool w_u1b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(bool p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Char)bool w_u1c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(SByte)bool w_u1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(int8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Int16)bool w_u1i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(int16_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Int32)bool w_u1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Int64)bool w_u1i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(int64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte GetByte(System.Array, Int32)bool w_u1oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ReadByte(IntPtr)bool w_u1p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1p");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(void* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ReadByte(IntPtr, Int32)bool w_u1pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte GetByteField(IntPtr, IntPtr)bool w_u1pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(void* p1, void* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte CallByteMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_u1ppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1ppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef uint8_t (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Single)bool w_u1r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(float p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Double)bool w_u1r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(double p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Parse(System.String)bool w_u1s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Parse(System.String, System.Globalization.NumberStyles)bool w_u1si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_u1si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Parse(System.String, System.IFormatProvider)bool w_u1so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// System.Security.SecurityRuleSet get_RuleSet()bool w_u1t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint8_t (*FuncToCall)(void*,const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(System.Object)bool w_u1tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint8_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte get_Item(Int32)bool w_u1ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(void*,int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ReadByte(Int64)bool w_u1ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(void*,int64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte PrintPtr(IntPtr)bool w_u1tp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1tp");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(void*,void* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte GetByte(System.String)bool w_u1ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint8_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte NextByte(Byte)bool w_u1tu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1tu1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(void*,uint8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte NextByte(Byte, Byte)bool w_u1tu1u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1tu1u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(void*,uint8_t p1, uint8_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(Byte)bool w_u1u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(uint8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Max(Byte, Byte)bool w_u1u1u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
    typedef uint8_t (*FuncToCall)(uint8_t p1, uint8_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte Clamp(Byte, Byte, Byte)bool w_u1u1u1u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1u1u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(env, _sv3);        
        
    typedef uint8_t (*FuncToCall)(uint8_t p1, uint8_t p2, uint8_t p3, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(UInt16)bool w_u1u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(uint16_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(UInt32)bool w_u1u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(uint32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// Byte ToByte(UInt64)bool w_u1u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef uint8_t (*FuncToCall)(uint64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint8_t>::toScript(env, ret));        return true;
}
// UInt16 get_controlledAudioTrackMaxCount()bool w_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint16_t (*FuncToCall)(const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.Object)bool w_u2O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.Object, System.IFormatProvider)bool w_u2Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 GetCategoryByName(Char*, Int32)bool w_u2Pci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2Pci4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint16_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 CreateCategory(Char*, Int32, Unity.Profiling.ProfilerCategoryColor)bool w_u2Pci4u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2Pci4u2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(env, _sv3);        
        
    typedef uint16_t (*FuncToCall)(void* p1, int32_t p2, uint16_t p3, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 VolatileRead(UInt16 ByRef)bool w_u2Pu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2Pu2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef uint16_t (*FuncToCall)(void* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.ReadOnlySpan`1[System.Byte])bool w_u2S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_u2S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef uint16_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.Decimal)bool w_u2S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 op_Explicit(System.Numerics.BigInteger)bool w_u2S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 op_Implicit(Unity.Profiling.ProfilerCategory)bool w_u2S_u2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_u2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_u2_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.DateTime)bool w_u2S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Boolean)bool w_u2b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(bool p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Char)bool w_u2c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(SByte)bool w_u2i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(int8_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Int16)bool w_u2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(int16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Int32)bool w_u2i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Int64)bool w_u2i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(int64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Byte[], Int32)bool w_u2oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Single)bool w_u2r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(float p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Double)bool w_u2r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(double p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.String)bool w_u2s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.String, Int32)bool w_u2si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_u2si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.String, System.IFormatProvider)bool w_u2so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ReadUInt16()bool w_u2t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint16_t (*FuncToCall)(void*,const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(System.Object)bool w_u2tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint16_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UnityEditor.ObjectChangeKind GetEventType(Int32)bool w_u2ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(void*,int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ReadUInt16(Int64)bool w_u2ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(void*,int64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 GetUInt16(System.String)bool w_u2ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint16_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 GetAudioChannelCount(UInt16)bool w_u2tu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2tu2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(void*,uint16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 NextUShort(UInt16, UInt16)bool w_u2tu2u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2tu2u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef uint16_t (*FuncToCall)(void*,uint16_t p1, uint16_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(Byte)bool w_u2u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(uint8_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(UInt16)bool w_u2u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(uint16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 Max(UInt16, UInt16)bool w_u2u2u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef uint16_t (*FuncToCall)(uint16_t p1, uint16_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 Clamp(UInt16, UInt16, UInt16)bool w_u2u2u2u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2u2u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(env, _sv3);        
        
    typedef uint16_t (*FuncToCall)(uint16_t p1, uint16_t p2, uint16_t p3, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(UInt32)bool w_u2u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(uint32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt16 ToUInt16(UInt64)bool w_u2u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef uint16_t (*FuncToCall)(uint64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint16_t>::toScript(env, ret));        return true;
}
// UInt32 get_memoryBudgetKB()bool w_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint32_t (*FuncToCall)(const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.Object)bool w_u4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.Object, System.IFormatProvider)bool w_u4Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 VolatileRead(UInt32 ByRef)bool w_u4Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef uint32_t (*FuncToCall)(void* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.ReadOnlySpan`1[System.Byte])bool w_u4S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_u4S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef uint32_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.Decimal)bool w_u4S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 op_Explicit(System.Numerics.BigInteger)bool w_u4S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.DateTime)bool w_u4S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Boolean)bool w_u4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(bool p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Char)bool w_u4c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(SByte)bool w_u4i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(int8_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Int16)bool w_u4i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(int16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Int32)bool w_u4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ComputeMipmapSize(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat)bool w_u4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef uint32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ComputeMipChainSize(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32)bool w_u4i4i4i4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4Di4");
    
    auto TIp4 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef uint32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, void* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ComputeMipmapSize(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat)bool w_u4i4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef uint32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ComputeMipChainSize(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32)bool w_u4i4i4i4i4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4i4Di4");
    
    auto TIp5 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef uint32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Int64)bool w_u4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(int64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 op_Explicit(System.Xml.Linq.XAttribute)bool w_u4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4o");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Byte[], Int32)bool w_u4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ArchiveAndCompress(UnityEditor.Build.Content.ResourceFile[], System.String, UnityEngine.BuildCompression)bool w_u4osS_i4i4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4osS_i4i4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_i4i4u4_* pp3 = DataTransfer::GetPointer<S_i4i4u4_>(env, _sv3);
    S_i4i4u4_ p3 = pp3 ? *pp3 : S_i4i4u4_ {};
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, struct S_i4i4u4_ p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ArchiveAndCompress(UnityEditor.Build.Content.ResourceFile[], System.String, UnityEngine.BuildCompression, Boolean)bool w_u4osS_i4i4u4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4osS_i4i4u4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_i4i4u4_* pp3 = DataTransfer::GetPointer<S_i4i4u4_>(env, _sv3);
    S_i4i4u4_ p3 = pp3 ? *pp3 : S_i4i4u4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, struct S_i4i4u4_ p3, bool p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 op_Modulus(Mono.Math.BigInteger, UInt32)bool w_u4ou4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ou4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 op_Explicit(UIntPtr)bool w_u4p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4p");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(void* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 xlua_objlen(IntPtr, Int32)bool w_u4pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Single)bool w_u4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(float p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Double)bool w_u4r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(double p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.String)bool w_u4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.String, Int32)bool w_u4si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_u4si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.String, System.IFormatProvider)bool w_u4so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetRegistryUInt32Value(System.String, System.String, UInt32, UnityEditorInternal.RegistryView)bool w_u4ssu4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ssu4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, uint32_t p3, int32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32()bool w_u4t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(System.Object)bool w_u4tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint32_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ConsumeSampleFrames(Unity.Collections.NativeArray`1[System.Single])bool w_u4tS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef uint32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetUInt32(Unity.Profiling.Stats.Counter)bool w_u4tS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef uint32_t (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetIndexStart(Int32)bool w_u4ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ReadUInt32(Int64)bool w_u4ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(void*,int64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_u4toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4toS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef uint32_t (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetUInt32(System.String)bool w_u4ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetAudioSampleRate(UInt16)bool w_u4tu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(void*,uint16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 NextUInt(UInt32)bool w_u4tu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 NextUInt(UInt32, UInt32)bool w_u4tu4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(Byte)bool w_u4u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(uint8_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(UInt16)bool w_u4u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(uint16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(UInt32)bool w_u4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 GetLatestTimings(UInt32, UnityEngine.FrameTiming[])bool w_u4u4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 Max(UInt32, UInt32)bool w_u4u4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 Clamp(UInt32, UInt32, UInt32)bool w_u4u4u4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u4u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(env, _sv3);        
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt32 ToUInt32(UInt64)bool w_u4u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef uint32_t (*FuncToCall)(uint64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint32_t>::toScript(env, ret));        return true;
}
// UInt64 GetGpuTimerFrequency()bool w_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint64_t (*FuncToCall)(const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.Object)bool w_u8O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.Object, System.IFormatProvider)bool w_u8Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 VolatileRead(UInt64 ByRef)bool w_u8Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef uint64_t (*FuncToCall)(void* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.ReadOnlySpan`1[System.Byte])bool w_u8S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_u8S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef uint64_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 GetSceneCullingMask(UnityEngine.SceneManagement.Scene)bool w_u8S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_i4_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.Decimal)bool w_u8S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 op_Explicit(System.Numerics.BigInteger)bool w_u8S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.DateTime)bool w_u8S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Boolean)bool w_u8b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(bool p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Char)bool w_u8c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(SByte)bool w_u8i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(int8_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Int16)bool w_u8i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(int16_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Int32)bool w_u8i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Int64)bool w_u8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(int64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 GetLocalIdentifierInFileForPersistentObject(UnityEngine.Object)bool w_u8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8o");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Byte[], Int32)bool w_u8oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 op_Explicit(UIntPtr)bool w_u8p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8p");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(void* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 lua_touint64(IntPtr, Int32)bool w_u8pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint64_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Single)bool w_u8r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(float p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Double)bool w_u8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(double p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.String)bool w_u8s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.String, Int32)bool w_u8si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_u8si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.String, System.IFormatProvider)bool w_u8so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64()bool w_u8t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(System.Object)bool w_u8tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef uint64_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 GetDurationMicroSeconds(Unity.Profiling.Stats.Counter)bool w_u8tS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef uint64_t (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 GetSampleStartTimeNs(Int32)bool w_u8ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(void*,int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ReadUInt64(Int64)bool w_u8ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(void*,int64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_u8toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8toS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef uint64_t (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 GetUInt64(System.String)bool w_u8ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef uint64_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 NextULong(UInt64)bool w_u8tu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(void*,uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 NextULong(UInt64, UInt64)bool w_u8tu8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu8u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef uint64_t (*FuncToCall)(void*,uint64_t p1, uint64_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(Byte)bool w_u8u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(uint8_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(UInt16)bool w_u8u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(uint16_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(UInt32)bool w_u8u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(uint32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ToUInt64(UInt64)bool w_u8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef uint64_t (*FuncToCall)(uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 ModifyMaskIfGameObjectIsHiddenForPrefabModeInContext(UInt64, UnityEngine.GameObject)bool w_u8u8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef uint64_t (*FuncToCall)(uint64_t p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 Max(UInt64, UInt64)bool w_u8u8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef uint64_t (*FuncToCall)(uint64_t p1, uint64_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// UInt64 Clamp(UInt64, UInt64, UInt64)bool w_u8u8u8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8u8u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(env, _sv3);        
        
    typedef uint64_t (*FuncToCall)(uint64_t p1, uint64_t p2, uint64_t p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<uint64_t>::toScript(env, ret));        return true;
}
// Void ClearCachedData()bool w_v(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_v");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void (*FuncToCall)(const void* method);
    void ret = ((FuncToCall)methodPointer)(  method);
    

        return true;
}
// Void ShowDetails(Boolean)bool w_vDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void True(System.Nullable`1[System.Boolean])bool w_vN_bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vN_bb_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    N_bb_* pp1 = DataTransfer::GetPointer<N_bb_>(env, _sv1);
    N_bb_ p1 = pp1 ? *pp1 : N_bb_ {};
        
    typedef void (*FuncToCall)(struct N_bb_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void True(System.Nullable`1[System.Boolean], System.String, System.Object[])bool w_vN_bb_sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vN_bb_sVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    N_bb_* pp1 = DataTransfer::GetPointer<N_bb_>(env, _sv1);
    N_bb_ p1 = pp1 ? *pp1 : N_bb_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(struct N_bb_ p1, Il2CppString* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void IsNaN(System.Nullable`1[System.Double])bool w_vN_br8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vN_br8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    N_br8_* pp1 = DataTransfer::GetPointer<N_br8_>(env, _sv1);
    N_br8_ p1 = pp1 ? *pp1 : N_br8_ {};
        
    typedef void (*FuncToCall)(struct N_br8_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void IsNaN(System.Nullable`1[System.Double], System.String, System.Object[])bool w_vN_br8_sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vN_br8_sVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    N_br8_* pp1 = DataTransfer::GetPointer<N_br8_>(env, _sv1);
    N_br8_ p1 = pp1 ? *pp1 : N_br8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(struct N_br8_ p1, Il2CppString* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void KeepAlive(System.Object)bool w_vO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void CopySerializedManagedFieldsOnly(System.Object, System.Object)bool w_vOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AreEqual(System.Object, System.Object, System.String, System.Object[])bool w_vOOsVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOOsVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                                                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Enter(System.Object, Boolean ByRef)bool w_vOPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOPb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void CopyObjectAddressToPtr(System.Object, Void*)bool w_vOPv(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOPv");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!pesapi_is_binary(env, _sv2) && !pesapi_is_null(env, _sv2) && !pesapi_is_undefined(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Combine(System.Object, System.Guid, Int32, System.Delegate)bool w_vOS_i4i2i2u1u1u1u1u1u1u1u1_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOS_i4i2i2u1u1u1u1u1u1u1u1_i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, int32_t p3, Il2CppObject* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void TryEnter(System.Object, System.TimeSpan, Boolean ByRef)bool w_vOS_i8_Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOS_i8_Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ChangeWrapperHandleStrength(System.Object, Boolean)bool w_vOb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void TryEnter(System.Object, Int32, Boolean ByRef)bool w_vOi4Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteInt16(System.Object, Int32, Char)bool w_vOi4c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4c");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    Il2CppChar p3 = converter::Converter<Il2CppChar>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppChar p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteInt16(System.Object, Int32, Int16)bool w_vOi4i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4i2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int16_t p3 = converter::Converter<int16_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int16_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteInt32(System.Object, Int32, Int32)bool w_vOi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteInt64(System.Object, Int32, Int64)bool w_vOi4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int64_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteIntPtr(System.Object, Int32, IntPtr)bool w_vOi4p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4p");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteByte(System.Object, Int32, Byte)bool w_vOi4u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOi4u1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, uint8_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Log(System.Object, UnityEngine.Object)bool w_vOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void GetObjectData(System.Object, System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)bool w_vOoS_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOoS_Oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_Oi4_* pp3 = DataTransfer::GetPointer<S_Oi4_>(env, _sv3);
    S_Oi4_ p3 = pp3 ? *pp3 : S_Oi4_ {};
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_Oi4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ByVal(System.Object, NUnit.Framework.Constraints.IResolveConstraint, System.String, System.Object[])bool w_vOosVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOosVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void GetNativeVariantForObject(System.Object, IntPtr)bool w_vOp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void StructureToPtr(System.Object, IntPtr, Boolean)bool w_vOpb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOpb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!!true) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, void* p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Write(System.Object, System.String)bool w_vOs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void NotNull(System.Object, System.String, System.Object[])bool w_vOsVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOsVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void VolatileWrite(System.Object ByRef, System.Object)bool w_vPOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPOO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetActivityId(System.Guid ByRef)bool w_vPS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void GetJobRange(Unity.Jobs.LowLevel.Unsafe.JobRanges ByRef, Int32, Int32 ByRef, Int32 ByRef)bool w_vPS_i4i4i4p_i4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4i4i4p_i4Pi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4i4p_* p1 = DataTransfer::GetPointer<S_i4i4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Draw(UnityEditorInternal.NativeProfilerTimeline_DrawArgs ByRef)bool w_vPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_* p1 = DataTransfer::GetPointer<S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void RenderPrimitives(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, Int32, Int32)bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4i4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4i4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, int32_t p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void RenderPrimitivesIndirect(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32)bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oDi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, Il2CppObject* p3, void* p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void RenderPrimitivesIndexed(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32, Int32)bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oi4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4oi4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, Il2CppObject* p3, int32_t p4, void* p5, void* p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void RenderPrimitivesIndexedIndirect(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, UnityEngine.GraphicsBuffer, Int32, Int32)bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4ooDi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_i4ooDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, void* p5, void* p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void RenderMeshPrimitives(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, Int32, Int32)bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void RenderMesh(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, Int32, UnityEngine.Matrix4x4, System.Nullable`1[UnityEngine.Matrix4x4])bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_DN_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_oi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_DN_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, Il2CppObject* p2, int32_t p3, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void RenderMeshIndirect(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, UnityEngine.GraphicsBuffer, Int32, Int32)bool w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ooDi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ooDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_* p1 = DataTransfer::GetPointer<S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4u4i4S_S_r4r4r4_S_r4r4r4__oi4i4ooi4bi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void GrabHandleInfo(Handle ByRef, Int32)bool w_vPS_i8ssi4o_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i8ssi4o_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S_i8ssi4o_* p1 = DataTransfer::GetPointer<S_i8ssi4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i8ssi4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void PrepareUndisposable(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef)bool w_vPS_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4i4_* p1 = DataTransfer::GetPointer<S_pi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Dispose(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef, Unity.Collections.LowLevel.Unsafe.DisposeSentinel ByRef)bool w_vPS_pi4i4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4i4_* p1 = DataTransfer::GetPointer<S_pi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Create(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef, Unity.Collections.LowLevel.Unsafe.DisposeSentinel ByRef, Int32, Unity.Collections.Allocator)bool w_vPS_pi4i4_Poi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_Poi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4i4_* p1 = DataTransfer::GetPointer<S_pi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, int32_t p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetStaticSafetyId(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef, Int32)bool w_vPS_pi4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_pi4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4i4_* p1 = DataTransfer::GetPointer<S_pi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Free(System.Threading.NativeOverlapped*)bool w_vPS_ppi4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_ppi4i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_ppi4i4p_* p1 = DataTransfer::GetPointer<S_ppi4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_ppi4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)bool w_vPS_r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)bool w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef)bool w_vPS_r4r4r4_PS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, UnityEngine.Vector3 ByRef)bool w_vPS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, Single ByRef)bool w_vPS_r4r4r4_PS_r4r4r4r4_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4r4_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void QuantisedVectorHash(UnityEngine.Vector3 ByRef, UnityEngine.Hash128 ByRef)bool w_vPS_r4r4r4_PS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_u8u8_* p2 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion, UnityEngine.Vector3 ByRef)bool w_vPS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(void* p1, struct S_r4r4r4r4_ p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion, Single ByRef)bool w_vPS_r4r4r4_S_r4r4r4r4_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_S_r4r4r4r4_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, struct S_r4r4r4r4_ p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void QuaternionNormalize(UnityEngine.Quaternion ByRef)bool w_vPS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetDefaults(UnityEditor.UnwrapParam ByRef)bool w_vPS_r4r4r4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4i4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Initialize(UnityEditorInternal.NativeProfilerTimeline_InitializeArgs ByRef)bool w_vPS_r4r4r4r4r4poi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4poi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4poi4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4r4poi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4r4poi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void QuantisedMatrixHash(UnityEngine.Matrix4x4 ByRef, UnityEngine.Hash128 ByRef)bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_u8u8_* p2 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void CalculateProjectionMatrixFromPhysicalProperties(UnityEngine.Matrix4x4 ByRef, Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, GateFitParameters)bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, float p2, struct S_r4r4_ p3, struct S_r4r4_ p4, float p5, float p6, void* p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef)bool w_vPS_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_su4_* p1 = DataTransfer::GetPointer<S_su4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_su4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean)bool w_vPS_su4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S_su4_* p1 = DataTransfer::GetPointer<S_su4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_su4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void CompleteAll(Unity.Jobs.JobHandle ByRef, Unity.Jobs.JobHandle ByRef)bool w_vPS_u8i4i4p_PS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u8i4i4p_PS_u8i4i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u8i4i4p_* p1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_u8i4i4p_* p2 = DataTransfer::GetPointer<S_u8i4i4p_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8i4i4p_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void CompleteAll(Unity.Jobs.JobHandle ByRef, Unity.Jobs.JobHandle ByRef, Unity.Jobs.JobHandle ByRef)bool w_vPS_u8i4i4p_PS_u8i4i4p_PS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u8i4i4p_PS_u8i4i4p_PS_u8i4i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u8i4i4p_* p1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_u8i4i4p_* p2 = DataTransfer::GetPointer<S_u8i4i4p_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8i4i4p_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_u8i4i4p_* p3 = DataTransfer::GetPointer<S_u8i4i4p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_u8i4i4p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void AppendHash(UnityEngine.Hash128 ByRef, UnityEngine.Hash128 ByRef)bool w_vPS_u8u8_PS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u8u8_PS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u8u8_* p1 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_u8u8_* p2 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Write(Boolean ByRef, Boolean)bool w_vPbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPbb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void VolatileWrite(SByte ByRef, SByte)bool w_vPi1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi1i1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int8_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void VolatileWrite(Int16 ByRef, Int16)bool w_vPi2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi2i2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int16_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void sFuncInParam(Int32 ByRef)bool w_vPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void GetMaxThreads(Int32 ByRef, Int32 ByRef)bool w_vPi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void EngineThread_UnityMain(Int32 ByRef, System.String ByRef)bool w_vPi4Ps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4Ps");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void VolatileWrite(Int32 ByRef, Int32)bool w_vPi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void OutRefFunc2(Int32 ByRef, Int32, Int32 ByRef)bool w_vPi4i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void VolatileWrite(Int64 ByRef, Int64)bool w_vPi8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi8i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Clear(Unity.Collections.LowLevel.Unsafe.DisposeSentinel ByRef)bool w_vPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void GetZoneAndOrigin(System.Collections.ArrayList ByRef, System.Collections.ArrayList ByRef)bool w_vPoPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPoPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void OutRefFunc12(ITestLuaClass ByRef, ITestLuaClass, ITestLuaClass ByRef)bool w_vPooPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPooPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef void (*FuncToCall)(void* p1, Il2CppObject* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void VolatileWrite(IntPtr ByRef, IntPtr)bool w_vPpp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPpp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void GetBrushWorldSizeLimits(Single ByRef, Single ByRef, Single, Int32, Int32, Int32)bool w_vPr4Pr4r4i4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPr4Pr4r4i4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, void* p2, float p3, int32_t p4, void* p5, void* p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void MinMaxSlider(Single ByRef, Single ByRef, Single, Single, UnityEngine.GUILayoutOption[])bool w_vPr4Pr4r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPr4Pr4r4r4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, void* p2, float p3, float p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void VolatileWrite(Single ByRef, Single)bool w_vPr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPr4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, float p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void VolatileWrite(Double ByRef, Double)bool w_vPr8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPr8r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, double p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void CreateIndex(System.String ByRef, UnityEditor.Search.IndexingOptions ByRef, System.Collections.Generic.IEnumerable`1[System.String], System.Collections.Generic.IEnumerable`1[System.String], System.Collections.Generic.IEnumerable`1[System.String], System.Action`3[System.String,System.String,System.Action])bool w_vPsPu1oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPsPu1oooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef void (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void VolatileWrite(Byte ByRef, Byte)bool w_vPu1u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1u1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, uint8_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void VolatileWrite(UInt16 ByRef, UInt16)bool w_vPu2u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu2u2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, uint16_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void GetRenderingResolution(UInt32 ByRef, UInt32 ByRef)bool w_vPu4Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void ForwardRawInput(UInt32*, UInt32*, UInt32, Byte*, UInt32)bool w_vPu4Pu4u4Pu1u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4Pu4u4Pu1u4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, uint32_t p3, void* p4, uint32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void VolatileWrite(UInt32 ByRef, UInt32)bool w_vPu4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4u4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, uint32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void VolatileWrite(UInt64 ByRef, UInt64)bool w_vPu8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu8u8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, uint64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void FlushCounterValue(Void*)bool w_vPv(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPv");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void MemCpyReplicate(Void*, Void*, Int32, Int32)bool w_vPvPvi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!pesapi_is_binary(env, _sv2) && !pesapi_is_null(env, _sv2) && !pesapi_is_undefined(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, int32_t p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void MemCpy(Void*, Void*, Int64)bool w_vPvPvi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!pesapi_is_binary(env, _sv2) && !pesapi_is_null(env, _sv2) && !pesapi_is_undefined(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, int64_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void MemoryCopy(Void*, Void*, Int64, Int64)bool w_vPvPvi8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvi8i8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!pesapi_is_binary(env, _sv2) && !pesapi_is_null(env, _sv2) && !pesapi_is_undefined(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, int64_t p3, int64_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void MemoryCopy(Void*, Void*, UInt64, UInt64)bool w_vPvPvu8u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvPvu8u8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!pesapi_is_binary(env, _sv2) && !pesapi_is_null(env, _sv2) && !pesapi_is_undefined(env, _sv2)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv3)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    uint64_t p4 = converter::Converter<uint64_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(void* p1, void* p2, uint64_t p3, uint64_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void FreeTracked(Void*, Unity.Collections.Allocator)bool w_vPvi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void MemCpyStride(Void*, Int32, Void*, Int32, Int32, Int32)bool w_vPvi4Pvi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvi4Pvi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!pesapi_is_binary(env, _sv3) && !pesapi_is_null(env, _sv3) && !pesapi_is_undefined(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(void* p1, int32_t p2, void* p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void MemClear(Void*, Int64)bool w_vPvi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvi8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(void* p1, int64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void MemSet(Void*, Byte, Int64)bool w_vPvu1i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu1i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(void* p1, uint8_t p2, int64_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ComputeHash128(Void*, UInt64, UnityEngine.Hash128*)bool w_vPvu8PS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu8PS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_u8u8_* p3 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_u8u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(void* p1, uint64_t p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ComputeHash128(Void*, UInt64, UInt64*, UInt64*)bool w_vPvu8Pu8Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPvu8Pu8Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, uint64_t p2, void* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void ApplyAndDisposeWritableMeshData(MeshDataArray, UnityEngine.Mesh, UnityEngine.Rendering.MeshUpdateFlags)bool w_vS_Ppi4i4i4S_pi4i4__oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Ppi4i4i4S_pi4i4__oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Ppi4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Ppi4i4i4S_pi4i4__>(env, _sv1);
    S_Ppi4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Ppi4i4i4S_pi4i4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_Ppi4i4i4S_pi4i4__ p1, Il2CppObject* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Copy(ReadOnly, Unity.Collections.NativeArray`1[T])bool w_vS_Pvi4S_pi4i4__S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4S_pi4i4__S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef void (*FuncToCall)(struct S_Pvi4S_pi4i4__ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Copy(ReadOnly, Unity.Collections.NativeArray`1[T], Int32)bool w_vS_Pvi4S_pi4i4__S_Pvi4i4i4S_pi4i4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4S_pi4i4__S_Pvi4i4i4S_pi4i4_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_Pvi4S_pi4i4__ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Copy(ReadOnly, Int32, Unity.Collections.NativeArray`1[T], Int32, Int32)bool w_vS_Pvi4S_pi4i4__i4S_Pvi4i4i4S_pi4i4_i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4S_pi4i4__i4S_Pvi4i4i4S_pi4i4_i4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_Pvi4S_pi4i4__ p1, int32_t p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, int32_t p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void Copy(ReadOnly, Int32, T[], Int32, Int32)bool w_vS_Pvi4S_pi4i4__i4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4S_pi4i4__i4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_Pvi4S_pi4i4__ p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void Copy(ReadOnly, T[])bool w_vS_Pvi4S_pi4i4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4S_pi4i4__o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_Pvi4S_pi4i4__ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Copy(ReadOnly, T[], Int32)bool w_vS_Pvi4S_pi4i4__oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4S_pi4i4__oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pvi4S_pi4i4__>(env, _sv1);
    S_Pvi4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pvi4S_pi4i4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_Pvi4S_pi4i4__ p1, Il2CppObject* p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void CompleteAll(Unity.Collections.NativeArray`1[Unity.Jobs.JobHandle])bool w_vS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Copy(Unity.Collections.NativeArray`1[T], Unity.Collections.NativeArray`1[T])bool w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Copy(Unity.Collections.NativeArray`1[T], Unity.Collections.NativeArray`1[T], Int32)bool w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void LookupArtifacts(Unity.Collections.NativeArray`1[UnityEditor.GUID], Unity.Collections.NativeArray`1[UnityEditor.Experimental.ArtifactID], System.Type)bool w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Copy(Unity.Collections.NativeArray`1[T], Int32, Unity.Collections.NativeArray`1[T], Int32, Int32)bool w_vS_Pvi4i4i4S_pi4i4_i4_i4S_Pvi4i4i4S_pi4i4_i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_i4S_Pvi4i4i4S_pi4i4_i4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, int32_t p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void Copy(Unity.Collections.NativeArray`1[T], Int32, T[], Int32, Int32)bool w_vS_Pvi4i4i4S_pi4i4_i4_i4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_i4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void Copy(Unity.Collections.NativeArray`1[T], T[])bool w_vS_Pvi4i4i4S_pi4i4_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Copy(Unity.Collections.NativeArray`1[T], T[], Int32)bool w_vS_Pvi4i4i4S_pi4i4_i4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_Pvi4i4i4S_pi4i4_i4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ZeroMemory(System.Span`1[System.Byte])bool w_vS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void InstanceIDsToValidArray(System.ReadOnlySpan`1[System.Int32], System.Span`1[System.Boolean])bool w_vS_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawLineStrip(System.ReadOnlySpan`1[UnityEngine.Vector3], Boolean)bool w_vS_S_p_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WriteInt16BigEndian(System.Span`1[System.Byte], Int16)bool w_vS_S_p_i4_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_i2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, int16_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WriteInt32BigEndian(System.Span`1[System.Byte], Int32)bool w_vS_S_p_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WriteInt64BigEndian(System.Span`1[System.Byte], Int64)bool w_vS_S_p_i4_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, int64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WriteUInt16BigEndian(System.Span`1[System.Byte], UInt16)bool w_vS_S_p_i4_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_u2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, uint16_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WriteUInt32BigEndian(System.Span`1[System.Byte], UInt32)bool w_vS_S_p_i4_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_u4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, uint32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WriteUInt64BigEndian(System.Span`1[System.Byte], UInt64)bool w_vS_S_p_i4_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_i4_u8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_p_i4_ p1, uint64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetTypedReference(TypedReference, System.Object)bool w_vS_S_p_pp_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_p_pp_O");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                            }
     // LuaValToCSVal struct
    S_S_p_pp_* pp1 = DataTransfer::GetPointer<S_S_p_pp_>(env, _sv1);
    S_S_p_pp_ p1 = pp1 ? *pp1 : S_S_p_pp_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_S_p_pp_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawRay(UnityEngine.Ray)bool w_vS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void RebuildBroadphaseRegions(UnityEngine.Bounds, Int32)bool w_vS_S_r4r4r4_S_r4r4r4__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void CollectSourcesInStage(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, Boolean, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], Boolean, UnityEngine.SceneManagement.Scene, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource])bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobS_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobS_i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(env, _sv7);        
        
     // LuaValToCSVal struct
    S_i4_* pp8 = DataTransfer::GetPointer<S_i4_>(env, _sv8);
    S_i4_ p8 = pp8 ? *pp8 : S_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, int32_t p2, int32_t p3, int32_t p4, bool p5, Il2CppObject* p6, bool p7, struct S_i4_ p8, Il2CppObject* p9, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        return true;
}
// Void CollectSources(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, Boolean, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], Boolean, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource])bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4bobo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, int32_t p2, int32_t p3, int32_t p4, bool p5, Il2CppObject* p6, bool p7, Il2CppObject* p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void CollectSourcesInStage(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], UnityEngine.SceneManagement.Scene, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource])bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oS_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oS_i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal struct
    S_i4_* pp6 = DataTransfer::GetPointer<S_i4_>(env, _sv6);
    S_i4_ p6 = pp6 ? *pp6 : S_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, int32_t p2, int32_t p3, int32_t p4, Il2CppObject* p5, struct S_i4_ p6, Il2CppObject* p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void CollectSources(UnityEngine.Bounds, Int32, UnityEngine.AI.NavMeshCollectGeometry, Int32, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildMarkup], System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource])bool w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_r4r4r4_S_r4r4r4__i4i4i4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef void (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, int32_t p2, int32_t p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void Widen(System.Numerics.Vector`1[System.Byte], System.Numerics.Vector`1[System.UInt16] ByRef, System.Numerics.Vector`1[System.UInt16] ByRef)bool w_vS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__PS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
     // LuaValToCSVal Pstruct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* p2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* p3 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence)bool w_vS__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef void (*FuncToCall)(struct S__ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void CloseConnection(UnityEngine.NetworkPlayer, Boolean)bool w_vS__b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS__b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S__ p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence, UnityEngine.Rendering.SynchronisationStage)bool w_vS__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS__i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S__ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetReceivingEnabled(UnityEngine.NetworkPlayer, Int32, Boolean)bool w_vS__i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS__i4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S__ p1, int32_t p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void set_jobOptions(UnityEngine.PhysicsJobOptions2D)bool w_vS_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_>(env, _sv1);
    S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef void (*FuncToCall)(struct S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void RemoveNavMeshData(UnityEngine.AI.NavMeshDataInstance)bool w_vS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef void (*FuncToCall)(struct S_i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void MoveCacheBefore(UnityEngine.Cache, UnityEngine.Cache)bool w_vS_i4_S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_S_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
     // LuaValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};
        
    typedef void (*FuncToCall)(struct S_i4_ p1, struct S_i4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetLightingSettingsForScene(UnityEngine.SceneManagement.Scene, UnityEngine.LightingSettings)bool w_vS_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_i4_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetSceneCullingMask(UnityEngine.SceneManagement.Scene, UInt64)bool w_vS_i4_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4_u8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_i4_ p1, uint64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetCurrentThreadActivityId(System.Guid)bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetCurrentThreadActivityId(System.Guid, System.Guid ByRef)bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_PS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_PS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void EmitFrameMetaData(System.Guid, Int32, System.Array)bool w_vS_i4i2i2u1u1u1u1u1u1u1u1_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i2i2u1u1u1u1u1u1u1u1_i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void set_state(State)bool w_vS_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
        
    typedef void (*FuncToCall)(struct S_i4i4i4i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Write(System.Decimal)bool w_vS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Greater(System.Decimal, System.Decimal)bool w_vS_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Greater(System.Decimal, System.Decimal, System.String, System.Object[])bool w_vS_i4i4i4i4u8_S_i4i4i4i4u8_sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_S_i4i4i4i4u8_sVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, Il2CppString* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Zero(System.Decimal, System.String, System.Object[])bool w_vS_i4i4i4i4u8_sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4i4u8_sVO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_i4i4i4i4u8_ p1, Il2CppString* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ShowSelector(UnityEditor.Presets.PresetType, UnityEditor.Presets.Preset, Boolean, UnityEditor.Presets.PresetSelectorReceiver)bool w_vS_i4os_obo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4os_obo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_i4os_* pp1 = DataTransfer::GetPointer<S_i4os_>(env, _sv1);
    S_i4os_ p1 = pp1 ? *pp1 : S_i4os_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef void (*FuncToCall)(struct S_i4os_ p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer)bool w_vS_i4p_S_i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
     // LuaValToCSVal struct
    S_i4p_* pp2 = DataTransfer::GetPointer<S_i4p_>(env, _sv2);
    S_i4p_ p2 = pp2 ? *pp2 : S_i4p_ {};
        
    typedef void (*FuncToCall)(struct S_i4p_ p1, struct S_i4p_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32)bool w_vS_i4p_S_i4p_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
     // LuaValToCSVal struct
    S_i4p_* pp2 = DataTransfer::GetPointer<S_i4p_>(env, _sv2);
    S_i4p_ p2 = pp2 ? *pp2 : S_i4p_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_i4p_ p1, struct S_i4p_ p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace)bool w_vS_i4p_S_i4p_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
     // LuaValToCSVal struct
    S_i4p_* pp2 = DataTransfer::GetPointer<S_i4p_>(env, _sv2);
    S_i4p_ p2 = pp2 ? *pp2 : S_i4p_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_i4p_ p1, struct S_i4p_ p2, int32_t p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32)bool w_vS_i4p_S_i4p_i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4p_S_i4p_i4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
     // LuaValToCSVal struct
    S_i4p_* pp2 = DataTransfer::GetPointer<S_i4p_>(env, _sv2);
    S_i4p_ p2 = pp2 ? *pp2 : S_i4p_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_i4p_ p1, struct S_i4p_ p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void Sleep(System.TimeSpan)bool w_vS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef void (*FuncToCall)(struct S_i8_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetRenderTarget(UnityEngine.RenderTargetSetup)bool w_vS_oS_i4p_i4i4i4ooi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_oS_i4p_i4i4i4ooi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oS_i4p_i4i4i4ooi4i4_* pp1 = DataTransfer::GetPointer<S_oS_i4p_i4i4i4ooi4i4_>(env, _sv1);
    S_oS_i4p_i4i4i4ooi4i4_ p1 = pp1 ? *pp1 : S_oS_i4p_i4i4i4ooi4i4_ {};
        
    typedef void (*FuncToCall)(struct S_oS_i4p_i4i4i4ooi4i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Advise(JetBrains.Lifetimes.Lifetime, JetBrains.Rider.Model.Unity.BackendUnity.BackendUnityModel)bool w_vS_o_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_o_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_o_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetPlayerLoop(UnityEngine.LowLevel.PlayerLoopSystem)bool w_vS_ooopp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_ooopp_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooopp_* pp1 = DataTransfer::GetPointer<S_ooopp_>(env, _sv1);
    S_ooopp_ p1 = pp1 ? *pp1 : S_ooopp_ {};
        
    typedef void (*FuncToCall)(struct S_ooopp_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void RunClassConstructor(System.RuntimeTypeHandle)bool w_vS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef void (*FuncToCall)(struct S_p_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetInt32(Unity.Profiling.Stats.Counter, Int32)bool w_vS_p_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_p_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_p_ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void PrepareMethod(System.RuntimeMethodHandle, System.RuntimeTypeHandle[])bool w_vS_p_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_p_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_p_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetFloat(Unity.Profiling.Stats.Counter, Single)bool w_vS_p_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_p_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_p_ p1, float p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetUInt32(Unity.Profiling.Stats.Counter, UInt32)bool w_vS_p_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_p_u4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_p_ p1, uint32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Release(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle)bool w_vS_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_pi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
    typedef void (*FuncToCall)(struct S_pi4i4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetAllowSecondaryVersionWriting(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, Boolean)bool w_vS_pi4i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_pi4i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_pi4i4_ p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence, UnityEngine.Rendering.SynchronisationStage)bool w_vS_pi4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_pi4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_pi4i4_ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SamplePlayableGraph(UnityEngine.Playables.PlayableGraph, Int32, Single)bool w_vS_pu4_i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_pu4_i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_pu4_ p1, int32_t p2, float p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void set_compositionCursorPos(UnityEngine.Vector2)bool w_vS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void ScaleAroundPivot(UnityEngine.Vector2, UnityEngine.Vector2)bool w_vS_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4_S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Vertex(UnityEngine.Vector3)bool w_vS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3, UnityEngine.Quaternion ByRef, UnityEngine.Vector3 ByRef)bool w_vS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void TransformHandle(UnityEngine.Vector3, UnityEngine.Quaternion ByRef, Single ByRef)bool w_vS_r4r4r4_PS_r4r4r4r4_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_PS_r4r4r4r4_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3)bool w_vS_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawBezier(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, UnityEngine.Texture2D, Single)bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, Il2CppObject* p6, float p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawWireArc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawWireArc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single, Single)bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, float p5, float p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color)bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single)bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single, Boolean)bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, bool p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, Single)bool w_vS_r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawWireDisc(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)bool w_vS_r4r4r4_S_r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Label(UnityEngine.Vector3, UnityEngine.Texture)bool w_vS_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void GetInterpolatedProbe(UnityEngine.Vector3, UnityEngine.Renderer, UnityEngine.Rendering.SphericalHarmonicsL2 ByRef)bool w_vS_r4r4r4_oPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_oPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppObject* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Label(UnityEngine.Vector3, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_vS_r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawWireSphere(UnityEngine.Vector3, Single)bool w_vS_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawFrustum(UnityEngine.Vector3, Single, Single, Single, Single)bool w_vS_r4r4r4_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, float p2, float p3, float p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawIcon(UnityEngine.Vector3, System.String)bool w_vS_r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppString* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawIcon(UnityEngine.Vector3, System.String, Boolean)bool w_vS_r4r4r4_sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_sb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppString* p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawIcon(UnityEngine.Vector3, System.String, Boolean, UnityEngine.Color)bool w_vS_r4r4r4_sbS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_sbS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppString* p2, bool p3, struct S_r4r4r4r4_ p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Label(UnityEngine.Vector3, System.String, UnityEngine.GUIStyle)bool w_vS_r4r4r4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void set_color(UnityEngine.Color)bool w_vS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void RGBToHSV(UnityEngine.Color, Single ByRef, Single ByRef, Single ByRef)bool w_vS_r4r4r4r4_Pr4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_Pr4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, void* p2, void* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void MinMaxSlider(UnityEngine.Rect, Single ByRef, Single ByRef, Single, Single)bool w_vS_r4r4r4r4_Pr4Pr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_Pr4Pr4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, void* p2, void* p3, float p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void BeginClip(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Vector2, Boolean)bool w_vS_r4r4r4r4_S_r4r4_S_r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4_S_r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, bool p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DrawRect(UnityEngine.Rect, UnityEngine.Color)bool w_vS_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawSolidRectangleWithOutline(UnityEngine.Rect, UnityEngine.Color, UnityEngine.Color)bool w_vS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawGradientRect(UnityEngine.Rect, UnityEngine.Color, UnityEngine.Color, Single, Boolean)bool w_vS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, bool p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void RenderGameViewCameras(UnityEngine.Rect, UnityEngine.Rect, Boolean, Boolean)bool w_vS_r4r4r4r4_S_r4r4r4r4_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_bb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void CalculateFrameTransform(UnityEngine.Rect, UnityEngine.Rect, Int32, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)bool w_vS_r4r4r4r4_S_r4r4r4r4_i4PS_r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_i4PS_r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, int32_t p3, void* p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void HandlePrefixLabel(UnityEngine.Rect, UnityEngine.Rect, UnityEngine.GUIContent)bool w_vS_r4r4r4r4_S_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void HandlePrefixLabel(UnityEngine.Rect, UnityEngine.Rect, UnityEngine.GUIContent, Int32)bool w_vS_r4r4r4r4_S_r4r4r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void HandlePrefixLabel(UnityEngine.Rect, UnityEngine.Rect, UnityEngine.GUIContent, Int32, UnityEngine.GUIStyle)bool w_vS_r4r4r4r4_S_r4r4r4r4_oi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_oi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, int32_t p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawInRangeOverlay(UnityEngine.Rect, UnityEngine.Color, Single, Single)bool w_vS_r4r4r4r4_S_r4r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_S_r4r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void RenderGameViewCameras(UnityEngine.Rect, Boolean, Boolean)bool w_vS_r4r4r4r4_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_bb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void AddCursorRect(UnityEngine.Rect, UnityEditor.MouseCursor)bool w_vS_r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AddCursorRect(UnityEngine.Rect, UnityEditor.MouseCursor, Int32)bool w_vS_r4r4r4r4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture)bool w_vS_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void ConnectionTargetSelectionDropdown(UnityEngine.Rect, UnityEngine.Networking.PlayerConnection.IConnectionState, UnityEngine.GUIStyle)bool w_vS_r4r4r4r4_oDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void MinMaxSlider(UnityEngine.Rect, UnityEngine.GUIContent, Single ByRef, Single ByRef, Single, Single)bool w_vS_r4r4r4r4_oPr4Pr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oPr4Pr4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, void* p3, void* p4, float p5, float p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawTextureWithTexCoords(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect)bool w_vS_r4r4r4r4_oS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void CurveField(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.Color, UnityEngine.Rect)bool w_vS_r4r4r4r4_oS_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void CurveField(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.Color, UnityEngine.Rect, UnityEngine.GUIContent)bool w_vS_r4r4r4r4_oS_r4r4r4r4_S_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_S_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawTextureWithTexCoords(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Boolean)bool w_vS_r4r4r4r4_oS_r4r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, bool p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32)bool w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Color)bool w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv8);
    S_r4r4r4r4_ p8 = pp8 ? *pp8 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, struct S_r4r4r4r4_ p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Color, UnityEngine.Material)bool w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4S_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4S_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv8);
    S_r4r4r4r4_ p8 = pp8 ? *pp8 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, struct S_r4r4r4r4_ p8, Il2CppObject* p9, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Color, UnityEngine.Material, Int32)bool w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4S_r4r4r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4S_r4r4r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 10) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv10)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv8);
    S_r4r4r4r4_ p8 = pp8 ? *pp8 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
 // LuaValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(env, _sv10);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, struct S_r4r4r4r4_ p8, Il2CppObject* p9, int32_t p10, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Material)bool w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, Il2CppObject* p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Material, Int32)bool w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oS_r4r4r4r4_i4i4i4i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv9)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
 // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(env, _sv9);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, Il2CppObject* p8, int32_t p9, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode)bool w_vS_r4r4r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Boolean)bool w_vS_r4r4r4r4_oi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, bool p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Boolean, Single)bool w_vS_r4r4r4r4_oi4br4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4br4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, bool p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Boolean, Single, UnityEngine.Color, UnityEngine.Vector4, UnityEngine.Vector4)bool w_vS_r4r4r4r4_oi4br4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4br4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv8);
    S_r4r4r4r4_ p8 = pp8 ? *pp8 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, bool p4, float p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, struct S_r4r4r4r4_ p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Boolean, Single, UnityEngine.Color, UnityEngine.Vector4, Single)bool w_vS_r4r4r4r4_oi4br4S_r4r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4br4S_r4r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, bool p4, float p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, float p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Boolean, Single, UnityEngine.Color, Single, Single)bool w_vS_r4r4r4r4_oi4br4S_r4r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4br4S_r4r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, bool p4, float p5, struct S_r4r4r4r4_ p6, float p7, float p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void IntSlider(UnityEngine.Rect, UnityEditor.SerializedProperty, Int32, Int32)bool w_vS_r4r4r4r4_oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture, Int32, Int32, Int32, Int32)bool w_vS_r4r4r4r4_oi4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4i4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture, Int32, Int32, Int32, Int32, UnityEngine.Material)bool w_vS_r4r4r4r4_oi4i4i4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4i4i4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, Int32, Int32, Int32, Int32, UnityEngine.Material, Int32)bool w_vS_r4r4r4r4_oi4i4i4i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4i4i4i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, int32_t p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void IntSlider(UnityEngine.Rect, UnityEditor.SerializedProperty, Int32, Int32, UnityEngine.GUIContent)bool w_vS_r4r4r4r4_oi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void IntSlider(UnityEngine.Rect, UnityEditor.SerializedProperty, Int32, Int32, System.String)bool w_vS_r4r4r4r4_oi4i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4i4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppString* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DisplayCustomMenu(UnityEngine.Rect, UnityEngine.GUIContent[], Int32, SelectMenuItemFunction, System.Object)bool w_vS_r4r4r4r4_oi4oO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4oO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DisplayCustomMenu(UnityEngine.Rect, UnityEngine.GUIContent[], Int32, SelectMenuItemFunction, System.Object, Boolean)bool w_vS_r4r4r4r4_oi4oOb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4oOb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, bool p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawTextureAlpha(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Single)bool w_vS_r4r4r4r4_oi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DrawTextureAlpha(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Single, Single)bool w_vS_r4r4r4r4_oi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, float p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawTextureTransparent(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Single, Single, UnityEngine.Rendering.ColorWriteMask)bool w_vS_r4r4r4r4_oi4r4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4r4r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, float p4, float p5, int32_t p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawTextureTransparent(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.ScaleMode, Single, Single, UnityEngine.Rendering.ColorWriteMask, Single)bool w_vS_r4r4r4r4_oi4r4r4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oi4r4r4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, float p4, float p5, int32_t p6, float p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material)bool w_vS_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawCurveSwatch(UnityEngine.Rect, UnityEngine.AnimationCurve, UnityEditor.SerializedProperty, UnityEngine.Color, UnityEngine.Color)bool w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, struct S_r4r4r4r4_ p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawCurveSwatch(UnityEngine.Rect, UnityEngine.AnimationCurve, UnityEditor.SerializedProperty, UnityEngine.Color, UnityEngine.Color, UnityEngine.Rect)bool w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, struct S_r4r4r4r4_ p5, struct S_r4r4r4r4_ p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawCurveSwatch(UnityEngine.Rect, UnityEngine.AnimationCurve, UnityEditor.SerializedProperty, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color)bool w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, struct S_r4r4r4r4_ p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawCurveSwatch(UnityEngine.Rect, UnityEngine.AnimationCurve, UnityEditor.SerializedProperty, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, UnityEngine.Rect)bool w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv7);
    S_r4r4r4r4_ p7 = pp7 ? *pp7 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv8);
    S_r4r4r4r4_ p8 = pp8 ? *pp8 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, struct S_r4r4r4r4_ p5, struct S_r4r4r4r4_ p6, struct S_r4r4r4r4_ p7, struct S_r4r4r4r4_ p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material, Int32)bool w_vS_r4r4r4r4_ooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void DisplayCustomMenu(UnityEngine.Rect, UnityEngine.GUIContent[], System.Func`2[System.Int32,System.Boolean], Int32, SelectMenuItemFunction, System.Object, Boolean)bool w_vS_r4r4r4r4_ooi4oODb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooi4oODb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, void* p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawPreviewTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material, UnityEngine.ScaleMode, Single)bool w_vS_r4r4r4r4_ooi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawPreviewTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material, UnityEngine.ScaleMode, Single, Single)bool w_vS_r4r4r4r4_ooi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, float p5, float p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DrawPreviewTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material, UnityEngine.ScaleMode, Single, Single, UnityEngine.Rendering.ColorWriteMask)bool w_vS_r4r4r4r4_ooi4r4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooi4r4r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, float p5, float p6, int32_t p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void DrawPreviewTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material, UnityEngine.ScaleMode, Single, Single, UnityEngine.Rendering.ColorWriteMask, Single)bool w_vS_r4r4r4r4_ooi4r4r4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooi4r4r4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, float p5, float p6, int32_t p7, float p8, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        return true;
}
// Void ObjectField(UnityEngine.Rect, UnityEditor.SerializedProperty, System.Type, UnityEngine.GUIContent)bool w_vS_r4r4r4r4_ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void MultiPropertyField(UnityEngine.Rect, UnityEngine.GUIContent[], UnityEditor.SerializedProperty, UnityEngine.GUIContent, PropertyVisibility)bool w_vS_r4r4r4r4_oooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oooi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void IntPopup(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent[], Int32[], UnityEngine.GUIContent)bool w_vS_r4r4r4r4_oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DoObjectField(UnityEngine.Rect, UnityEditor.SerializedProperty, System.Type, UnityEngine.GUIContent, UnityEditor.Search.SearchContext, UnityEngine.Search.SearchViewFlags)bool w_vS_r4r4r4r4_ooooDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ooooDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, void* p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void DisplayCustomMenuWithSeparators(UnityEngine.Rect, System.String[], Boolean[], Boolean[], Int32[], SelectMenuItemFunction, System.Object)bool w_vS_r4r4r4r4_oooooO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_oooooO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        return true;
}
// Void Slider(UnityEngine.Rect, UnityEditor.SerializedProperty, Single, Single)bool w_vS_r4r4r4r4_or4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_or4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, float p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Slider(UnityEngine.Rect, UnityEditor.SerializedProperty, Single, Single, UnityEngine.GUIContent)bool w_vS_r4r4r4r4_or4r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_or4r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, float p3, float p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void Slider(UnityEngine.Rect, UnityEditor.SerializedProperty, Single, Single, System.String)bool w_vS_r4r4r4r4_or4r4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_or4r4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, float p3, float p4, Il2CppString* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void DrawAgentDiagram(UnityEngine.Rect, Single, Single, Single, Single)bool w_vS_r4r4r4r4_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, float p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void ProgressBar(UnityEngine.Rect, Single, System.String)bool w_vS_r4r4r4r4_r4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_r4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Label(UnityEngine.Rect, System.String)bool w_vS_r4r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void MinMaxSlider(UnityEngine.Rect, System.String, Single ByRef, Single ByRef, Single, Single)bool w_vS_r4r4r4r4_sPr4Pr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_sPr4Pr4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, void* p3, void* p4, float p5, float p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void HelpBox(UnityEngine.Rect, System.String, UnityEditor.MessageType)bool w_vS_r4r4r4r4_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_si4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Label(UnityEngine.Rect, System.String, UnityEngine.GUIStyle)bool w_vS_r4r4r4r4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void LabelField(UnityEngine.Rect, System.String, System.String)bool w_vS_r4r4r4r4_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_ss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void LabelField(UnityEngine.Rect, System.String, System.String, UnityEngine.GUIStyle)bool w_vS_r4r4r4r4_sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_sso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void set_matrix(UnityEngine.Matrix4x4)bool w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void GetFrustumPlaneAt(UnityEngine.Matrix4x4, UnityEngine.Vector3, Single, UnityEngine.Vector3[])bool w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void CalculateFrustumPlanes(UnityEngine.Matrix4x4, UnityEngine.Plane[])bool w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void set_ambientProbe(UnityEngine.Rendering.SphericalHarmonicsL2)bool w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void SetNoBackupFlag(UnityEngine.CachedAssetBundle)bool w_vS_sS_u8u8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_sS_u8u8__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sS_u8u8__* pp1 = DataTransfer::GetPointer<S_sS_u8u8__>(env, _sv1);
    S_sS_u8u8__ p1 = pp1 ? *pp1 : S_sS_u8u8__ {};
        
    typedef void (*FuncToCall)(struct S_sS_u8u8__ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void GetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget, System.String[] ByRef)bool w_vS_s_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef void (*FuncToCall)(struct S_s_ p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetIncrementalIl2CppBuild(UnityEditor.Build.NamedBuildTarget, Boolean)bool w_vS_s_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_s_ p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetArchitecture(UnityEditor.Build.NamedBuildTarget, Int32)bool w_vS_s_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_s_ p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetTierSettings(UnityEditor.Build.NamedBuildTarget, UnityEngine.Rendering.GraphicsTier, UnityEditor.Rendering.TierSettings)bool w_vS_s_i4S_i4i4bbbbbbbbi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_i4S_i4i4bbbbbbbbi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_i4i4bbbbbbbbi4i4_* pp3 = DataTransfer::GetPointer<S_i4i4bbbbbbbbi4i4_>(env, _sv3);
    S_i4i4bbbbbbbbi4i4_ p3 = pp3 ? *pp3 : S_i4i4bbbbbbbbi4i4_ {};
        
    typedef void (*FuncToCall)(struct S_s_ p1, int32_t p2, struct S_i4i4bbbbbbbbi4i4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget, System.String[])bool w_vS_s_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(struct S_s_ p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetIcons(UnityEditor.Build.NamedBuildTarget, UnityEngine.Texture2D[], UnityEditor.IconKind)bool w_vS_s_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_s_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetPlatformIcons(UnityEditor.Build.NamedBuildTarget, UnityEditor.PlatformIconKind, UnityEditor.PlatformIcon[])bool w_vS_s_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(struct S_s_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetScriptingDefineSymbols(UnityEditor.Build.NamedBuildTarget, System.String)bool w_vS_s_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_s_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void (*FuncToCall)(struct S_s_ p1, Il2CppString* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AddPropertyModification(UnityEditor.EditorCurveBinding, UnityEditor.PropertyModification, Boolean)bool w_vS_sosi4i4i4i4i4i4i4_ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_sosi4i4i4i4i4i4i4_ob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, Il2CppObject* p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetCategoryEnabled(Unity.Profiling.ProfilerCategory, Boolean)bool w_vS_u2_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u2_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(struct S_u2_ p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void ReadInts(UnityEngine.Animations.AnimationStream, Unity.Collections.NativeArray`1[UnityEngine.Animations.PropertySceneHandle], Unity.Collections.NativeArray`1[System.Int32])bool w_vS_u4pppppp_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u4pppppp_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef void (*FuncToCall)(struct S_u4pppppp_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteInts(UnityEngine.Animations.AnimationStream, Unity.Collections.NativeArray`1[UnityEngine.Animations.PropertyStreamHandle], Unity.Collections.NativeArray`1[System.Int32], Boolean)bool w_vS_u4pppppp_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u4pppppp_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(struct S_u4pppppp_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, bool p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SaveAssetIfDirty(UnityEditor.GUID)bool w_vS_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u4u4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
    typedef void (*FuncToCall)(struct S_u4u4u4u4_ p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void RemotingTrace(System.Object[])bool w_vVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vVO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void DrawPolyLine(UnityEngine.Vector3[])bool w_vVS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vVS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Invoke(System.Action[])bool w_vVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vVo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef void (*FuncToCall)(void* p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void set_MonitoringIsEnabled(Boolean)bool w_vb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef void (*FuncToCall)(bool p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void Assert(Boolean, System.Object)bool w_vbO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbO");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Assert(Boolean, System.Object, UnityEngine.Object)bool w_vbOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbOo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteIf(Boolean, System.Object, System.String)bool w_vbOs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbOs");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(bool p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Clear(Boolean, Boolean, UnityEngine.Color)bool w_vbbS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbbS_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(bool p1, bool p2, struct S_r4r4r4r4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Clear(Boolean, Boolean, UnityEngine.Color, Single)bool w_vbbS_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbbS_r4r4r4r4_r4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(bool p1, bool p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetAnimCullTotalSwitch(Boolean, Int32)bool w_vbi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbi4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(bool p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetTcpKeepAlive(Boolean, Int32, Int32)bool w_vbi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbi4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(bool p1, int32_t p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Assert(Boolean, UnityEngine.Object)bool w_vbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbo");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AssertFormat(Boolean, UnityEngine.Object, System.String, System.Object[])bool w_vbosVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbosVO");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(bool p1, Il2CppObject* p2, Il2CppString* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void RemotingAssert(Boolean, System.String)bool w_vbs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbs");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void (*FuncToCall)(bool p1, Il2CppString* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AssertFormat(Boolean, System.String, System.Object[])bool w_vbsVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbsVO");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(bool p1, Il2CppString* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Assert(Boolean, System.String, UnityEngine.Object)bool w_vbso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbso");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(bool p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Assert(Boolean, System.String, System.String)bool w_vbss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbss");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(bool p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Assert(Boolean, System.String, System.String, System.Object[])bool w_vbssVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbssVO");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(bool p1, Il2CppString* p2, Il2CppString* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Write(Char)bool w_vc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef void (*FuncToCall)(Il2CppChar p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void AreEqual(Char, Char)bool w_vcc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vcc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(Il2CppChar p1, Il2CppChar p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AreEqual(Char, Char, System.String)bool w_vccs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vccs");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(Il2CppChar p1, Il2CppChar p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void AreEqual(SByte, SByte)bool w_vi1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi1i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(int8_t p1, int8_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AreEqual(SByte, SByte, System.String)bool w_vi1i1s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi1i1s");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(int8_t p1, int8_t p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void AreEqual(Int16, Int16)bool w_vi2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi2i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(int16_t p1, int16_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void AreEqual(Int16, Int16, System.String)bool w_vi2i2s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi2i2s");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(int16_t p1, int16_t p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Collect(Int32)bool w_vi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef void (*FuncToCall)(int32_t p1, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1,  method);
    

        return true;
}
// Void PackAllAtlases(UnityEditor.BuildTarget, Boolean)bool w_vi4Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Db");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Finish(Int32, Status)bool w_vi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Di4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void OutRefFunc1(Int32, Int32 ByRef, Int32 ByRef)bool w_vi4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Pi4Pi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, void* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void GetScriptingDefineSymbolsForGroup(UnityEditor.BuildTargetGroup, System.String[] ByRef)bool w_vi4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Po");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef void (*FuncToCall)(int32_t p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetAdditionalBakedProbes(Int32, System.ReadOnlySpan`1[UnityEngine.Vector3])bool w_vi4S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_S_p_i4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_S_p_i4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetAdditionalBakedProbes(Int32, System.ReadOnlySpan`1[UnityEngine.Vector3], Boolean)bool w_vi4S_S_p_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_S_p_i4_b");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, struct S_S_p_i4_ p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void ChangeEditMode(SceneViewEditMode, UnityEngine.Bounds, UnityEditor.Editor)bool w_vi4S_S_r4r4r4_S_r4r4r4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_S_r4r4r4_S_r4r4r4__o");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, struct S_S_r4r4r4_S_r4r4r4__ p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void MultiTexCoord(Int32, UnityEngine.Vector3)bool w_vi4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SelectionFrame(Int32, UnityEngine.Vector3, UnityEngine.Quaternion, Single)bool w_vi4S_r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void CubeHandleCap(Int32, UnityEngine.Vector3, UnityEngine.Quaternion, Single, UnityEngine.EventType)bool w_vi4S_r4r4r4_S_r4r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4_S_r4r4r4r4_r4i4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, int32_t p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void SetGlobalVector(Int32, UnityEngine.Vector4)bool w_vi4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetGlobalMatrix(Int32, UnityEngine.Matrix4x4)bool w_vi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetQualityLevel(Int32, Boolean)bool w_vi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(int32_t p1, bool p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void BakeMesh(Int32, Boolean, UnityEngine.MeshColliderCookingOptions)bool w_vi4bi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4bi4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, bool p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Collect(Int32, System.GCCollectionMode)bool w_vi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawProceduralNow(UnityEngine.MeshTopology, Int32, Int32)bool w_vi4i4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4Di4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Allocate(Int32, Int32, UnityEngine.Jobs.TransformAccessArray ByRef)bool w_vi4i4PS_pS_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4PS_pS_pi4i4__");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_pS_pi4i4__* p3 = DataTransfer::GetPointer<S_pS_pi4i4__>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_pS_pi4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetCustomErrorMessage(Int32, Unity.Collections.LowLevel.Unsafe.AtomicSafetyErrorType, Byte*, Int32)bool w_vi4i4Pu1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4Pu1i4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, void* p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetShaderSettingsForPlatform(UnityEditor.BuildTargetGroup, UnityEngine.Rendering.ShaderHardwareTier, UnityEditor.Rendering.PlatformShaderSettings)bool w_vi4i4S_bbbi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4S_bbbi4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_bbbi4_* pp3 = DataTransfer::GetPointer<S_bbbi4_>(env, _sv3);
    S_bbbi4_ p3 = pp3 ? *pp3 : S_bbbi4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, struct S_bbbi4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetTierSettings(UnityEditor.BuildTargetGroup, UnityEngine.Rendering.GraphicsTier, UnityEditor.Rendering.TierSettings)bool w_vi4i4S_i4i4bbbbbbbbi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4S_i4i4bbbbbbbbi4i4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_i4i4bbbbbbbbi4i4_* pp3 = DataTransfer::GetPointer<S_i4i4bbbbbbbbi4i4_>(env, _sv3);
    S_i4i4bbbbbbbbi4i4_ p3 = pp3 ? *pp3 : S_i4i4bbbbbbbbi4i4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, struct S_i4i4bbbbbbbbi4i4_ p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Collect(Int32, System.GCCollectionMode, Boolean)bool w_vi4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Collect(Int32, System.GCCollectionMode, Boolean, Boolean)bool w_vi4i4bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4bb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, bool p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetResolution(Int32, Int32, Boolean, Int32)bool w_vi4i4bi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4bi4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode)bool w_vi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, UnityEngine.RefreshRate)bool w_vi4i4i4S_u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4S_u4u4_");
    
    auto TIp4 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_u4u4_* pp4 = DataTransfer::GetPointer<S_u4u4_>(env, _sv4);
    S_u4u4_ p4 = pp4 ? *pp4 : S_u4u4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, struct S_u4u4_ p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, Int32)bool w_vi4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void MoveBufferArea(Int32, Int32, Int32, Int32, Int32, Int32)bool w_vi4i4i4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void MoveBufferArea(Int32, Int32, Int32, Int32, Int32, Int32, Char, System.ConsoleColor, System.ConsoleColor)bool w_vi4i4i4i4i4i4ci4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4i4i4ci4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv9)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    Il2CppChar p7 = converter::Converter<Il2CppChar>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(env, _sv9);        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppChar p7, int32_t p8, int32_t p9, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        return true;
}
// Void Report(Int32, Int32, Int32, System.String)bool w_vi4i4i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4s");
    
    auto TIp4 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void GetStatisticsAvailable(UnityEngine.Profiling.ProfilerArea, Int32, Int32[])bool w_vi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4o");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void GetUISystemEventMarkersBatch(Int32, Int32, UnityEditorInternal.EventMarker[], System.String[])bool w_vi4i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4oo");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void LogFormat(UnityEngine.LogType, UnityEngine.LogOption, UnityEngine.Object, System.String, System.Object[])bool w_vi4i4osVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4osVO");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void GetStatisticsValues(Int32, Int32, Single, Single[], Single ByRef)bool w_vi4i4r4oPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4r4oPr4");
    
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, float p3, Il2CppObject* p4, void* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void AreEqual(Int32, Int32, System.String)bool w_vi4i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4s");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void Greater(Int32, Int32, System.String, System.Object[])bool w_vi4i4sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4sVO");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetRemainingTime(Int32, Int64)bool w_vi4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(int32_t p1, int64_t p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetRandomWriteTarget(Int32, UnityEngine.RenderTexture)bool w_vi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void DrawProceduralIndirectNow(UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32)bool w_vi4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oDi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawClampedDetailPatchGUI(Int32, System.Collections.Generic.List`1[UnityEngine.Vector4], UnityEngine.Vector2, UnityEngine.Terrain, UnityEditor.TerrainTools.IOnSceneGUI)bool w_vi4oS_r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oS_r4r4_oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, struct S_r4r4_ p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void SetRandomWriteTarget(Int32, UnityEngine.ComputeBuffer, Boolean)bool w_vi4ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4ob");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, bool p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void SetGlobalTexture(Int32, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)bool w_vi4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawProceduralNow(UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32)bool w_vi4oi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4Di4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetGlobalConstantBuffer(Int32, UnityEngine.ComputeBuffer, Int32, Int32)bool w_vi4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4i4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void SetPlatformIcons(UnityEditor.BuildTargetGroup, UnityEditor.PlatformIconKind, UnityEditor.PlatformIcon[])bool w_vi4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void DrawProceduralIndirectNow(UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, UnityEngine.ComputeBuffer, Int32)bool w_vi4ooDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4ooDi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void RunTests(Int32, System.String[], System.String[], System.String[], System.String[], System.Nullable`1[System.Int32])bool w_vi4ooooN_bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4ooooN_bi4_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal struct
    N_bi4_* pp6 = DataTransfer::GetPointer<N_bi4_>(env, _sv6);
    N_bi4_ p6 = pp6 ? *pp6 : N_bi4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, struct N_bi4_ p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void StartNameEditingIfProjectWindowExists(Int32, UnityEditor.ProjectWindowCallback.EndNameEditAction, System.String, UnityEngine.Texture2D, System.String)bool w_vi4osos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4osos");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, Il2CppString* p5, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        return true;
}
// Void StartNameEditingIfProjectWindowExists(Int32, UnityEditor.ProjectWindowCallback.EndNameEditAction, System.String, UnityEngine.Texture2D, System.String, Boolean)bool w_vi4ososb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4ososb");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppString* p3, Il2CppObject* p4, Il2CppString* p5, bool p6, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        return true;
}
// Void ThrowExceptionForHR(Int32, IntPtr)bool w_vi4p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4p");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef void (*FuncToCall)(int32_t p1, void* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void SetLayerCost(Int32, Single)bool w_vi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef void (*FuncToCall)(int32_t p1, float p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void MultiTexCoord2(Int32, Single, Single)bool w_vi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef void (*FuncToCall)(int32_t p1, float p2, float p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void MultiTexCoord3(Int32, Single, Single, Single)bool w_vi4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4r4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef void (*FuncToCall)(int32_t p1, float p2, float p3, float p4, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        return true;
}
// Void Report(Int32, Single, System.String)bool w_vi4r4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4r4s");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef void (*FuncToCall)(int32_t p1, float p2, Il2CppString* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
// Void WriteCustomEvent(Int32, System.String)bool w_vi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4s");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        return true;
}
// Void Zero(Int32, System.String, System.Object[])bool w_vi4sVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sVO");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, void* p3, const void* method);
    void ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        return true;
}
}

