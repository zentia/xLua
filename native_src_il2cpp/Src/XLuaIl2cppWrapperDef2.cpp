// Auto Gen
    
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// Boolean Equals(System.Threading.Tasks.ValueTask)bool w_btS_Oi2b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Oi2b_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi2b_* pp1 = DataTransfer::GetPointer<S_Oi2b_>(env, _sv1);
    S_Oi2b_ p1 = pp1 ? *pp1 : S_Oi2b_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_Oi2b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.SequencePosition)bool w_btS_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_Oi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryCopyTo(System.Memory`1[T])bool w_btS_Oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_Oi4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Threading.Tasks.ValueTask`1[TResult])bool w_btS_Ooi2b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Ooi2b_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Ooi2b_* pp1 = DataTransfer::GetPointer<S_Ooi2b_>(env, _sv1);
    S_Ooi2b_ p1 = pp1 ? *pp1 : S_Ooi2b_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_Ooi2b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Unity.Collections.NativeSlice`1[T])bool w_btS_Pu1i4i4i4i4S_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Pu1i4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv1);
    S_Pu1i4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_Pu1i4i4i4i4S_pi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Unity.Collections.NativeArray`1[T])bool w_btS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Net.Security.SslApplicationProtocol)bool w_btS_S_Oi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_Oi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_Oi4i4__* pp1 = DataTransfer::GetPointer<S_S_Oi4i4__>(env, _sv1);
    S_S_Oi4i4__ p1 = pp1 ? *pp1 : S_S_Oi4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_Oi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleTransformOrigin)bool w_btS_S_S_r4i4_S_r4i4_r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_r4i4_S_r4i4_r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4_i4_>(env, _sv1);
    S_S_S_r4i4_S_r4i4_r4_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4i4_r4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_r4i4_S_r4i4_r4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleTranslate)bool w_btS_S_S_r4i4_S_r4i4_r4b_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_r4i4_S_r4i4_r4b_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4b_i4_>(env, _sv1);
    S_S_S_r4i4_S_r4i4_r4b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4i4_r4b_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_r4i4_S_r4i4_r4b_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleRotate)bool w_btS_S_S_r4i4_S_r4r4r4_b_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_r4i4_S_r4r4r4_b_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4r4r4_b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4r4r4_b_i4_>(env, _sv1);
    S_S_S_r4i4_S_r4r4r4_b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4r4r4_b_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_r4i4_S_r4r4r4_b_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.VisibleReflectionProbe)bool w_btS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_>(env, _sv1);
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleScale)bool w_btS_S_S_r4r4r4_b_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_r4r4r4_b_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4r4r4_b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_b_i4_>(env, _sv1);
    S_S_S_r4r4r4_b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_b_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_r4r4r4_b_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.DrawingSettings)bool w_btS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_>(env, _sv1);
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.RenderStateBlock)bool w_btS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_>(env, _sv1);
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p1 = pp1 ? *pp1 : S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleEnum`1[T])bool w_btS_S__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S__i4_* pp1 = DataTransfer::GetPointer<S_S__i4_>(env, _sv1);
    S_S__i4_ p1 = pp1 ? *pp1 : S_S__i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleBackgroundSize)bool w_btS_S_i4S_r4i4_S_r4i4__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4S_r4i4_S_r4i4__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4S_r4i4_S_r4i4__i4_* pp1 = DataTransfer::GetPointer<S_S_i4S_r4i4_S_r4i4__i4_>(env, _sv1);
    S_S_i4S_r4i4_S_r4i4__i4_ p1 = pp1 ? *pp1 : S_S_i4S_r4i4_S_r4i4__i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4S_r4i4_S_r4i4__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleBackgroundPosition)bool w_btS_S_i4S_r4i4__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4S_r4i4__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4S_r4i4__i4_* pp1 = DataTransfer::GetPointer<S_S_i4S_r4i4__i4_>(env, _sv1);
    S_S_i4S_r4i4__i4_ p1 = pp1 ? *pp1 : S_S_i4S_r4i4__i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4S_r4i4__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Range)bool w_btS_S_i4_S_i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4_S_i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4_S_i4__* pp1 = DataTransfer::GetPointer<S_S_i4_S_i4__>(env, _sv1);
    S_S_i4_S_i4__ p1 = pp1 ? *pp1 : S_S_i4_S_i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4_S_i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleBackgroundRepeat)bool w_btS_S_i4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4_i4_* pp1 = DataTransfer::GetPointer<S_S_i4i4_i4_>(env, _sv1);
    S_S_i4i4_i4_ p1 = pp1 ? *pp1 : S_S_i4i4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.FilteringSettings)bool w_btS_S_i4i4_i4u4i4S_i2i2_S_i2i2__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4i4_i4u4i4S_i2i2_S_i2i2__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4_i4u4i4S_i2i2_S_i2i2__* pp1 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2_S_i2i2__>(env, _sv1);
    S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ p1 = pp1 ? *pp1 : S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.BoundsInt)bool w_btS_S_i4i4i4_S_i4i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4i4i4_S_i4i4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Unity.Properties.PropertyPath)bool w_btS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* pp1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, _sv1);
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ p1 = pp1 ? *pp1 : S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleCursor)bool w_btS_S_oS_r4r4_i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_oS_r4r4_i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_oS_r4r4_i4_i4_* pp1 = DataTransfer::GetPointer<S_S_oS_r4r4_i4_i4_>(env, _sv1);
    S_S_oS_r4r4_i4_i4_ p1 = pp1 ? *pp1 : S_S_oS_r4r4_i4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_oS_r4r4_i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleBackground)bool w_btS_S_oooo_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_oooo_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_oooo_i4_* pp1 = DataTransfer::GetPointer<S_S_oooo_i4_>(env, _sv1);
    S_S_oooo_i4_ p1 = pp1 ? *pp1 : S_S_oooo_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_oooo_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.RendererListParams)bool w_btS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* pp1 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(env, _sv1);
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p1 = pp1 ? *pp1 : S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.ShadowDrawingSettings)bool w_btS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* pp1 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(env, _sv1);
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p1 = pp1 ? *pp1 : S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte])bool w_btS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAdvanceToAny(System.ReadOnlySpan`1[T], Boolean)bool w_btS_S_p_i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.Span`1[System.Char], Int32 ByRef)bool w_btS_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.Span`1[System.Char], Int32 ByRef, System.ReadOnlySpan`1[System.Char])bool w_btS_S_p_i4_Pi4DS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_Pi4DS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.Span`1[System.Char], Int32 ByRef, System.ReadOnlySpan`1[System.Char], System.IFormatProvider)bool w_btS_S_p_i4_Pi4DS_S_p_i4_Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_Pi4DS_S_p_i4_Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Int32 ByRef, Boolean, Boolean)bool w_btS_S_p_i4_Pi4DbDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_Pi4DbDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifySignatureForData(System.ReadOnlySpan`1[System.Byte], System.Security.Cryptography.X509Certificates.X509Certificate2 ByRef, System.Security.Cryptography.X509Certificates.X509Certificate2Collection)bool w_btS_S_p_i4_PoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_PoDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifySignature(System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte])bool w_btS_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryComputeHash(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], Int32 ByRef)bool w_btS_S_p_i4_S_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte], System.Security.Cryptography.HashAlgorithmName)bool w_btS_S_p_i4_S_S_p_i4_S_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_S_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_s_* pp3 = DataTransfer::GetPointer<S_s_>(env, _sv3);
    S_s_ p3 = pp3 ? *pp3 : S_s_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_s_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TrySignData(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], System.Security.Cryptography.HashAlgorithmName, Int32 ByRef)bool w_btS_S_p_i4_S_S_p_i4_S_s_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_S_s_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_s_* pp3 = DataTransfer::GetPointer<S_s_>(env, _sv3);
    S_s_ p3 = pp3 ? *pp3 : S_s_ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_s_ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(System.ReadOnlySpan`1[System.Byte], System.ReadOnlySpan`1[System.Byte], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)bool w_btS_S_p_i4_S_S_p_i4_S_s_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_S_s_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_s_* pp3 = DataTransfer::GetPointer<S_s_>(env, _sv3);
    S_s_ p3 = pp3 ? *pp3 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_s_ p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TrySignHash(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding, Int32 ByRef)bool w_btS_S_p_i4_S_S_p_i4_S_s_oPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_S_s_oPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_s_* pp3 = DataTransfer::GetPointer<S_s_>(env, _sv3);
    S_s_ p3 = pp3 ? *pp3 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_s_ p3, Il2CppObject* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryDecrypt(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], System.Security.Cryptography.RSAEncryptionPadding, Int32 ByRef)bool w_btS_S_p_i4_S_S_p_i4_oPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_S_p_i4_oPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifySignatureForHash(System.ReadOnlySpan`1[System.Byte], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.X509Certificates.X509Certificate2 ByRef, System.Security.Cryptography.X509Certificates.X509Certificate2Collection)bool w_btS_S_p_i4_S_s_PoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_S_s_PoDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_s_* pp2 = DataTransfer::GetPointer<S_s_>(env, _sv2);
    S_s_ p2 = pp2 ? *pp2 : S_s_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_s_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.StringComparison)bool w_btS_S_p_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.Span`1[System.Char], Int32, Int32 ByRef)bool w_btS_S_p_i4_i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifySignatureForHash(System.ReadOnlySpan`1[System.Byte], System.Security.Cryptography.Oid, System.Security.Cryptography.X509Certificates.X509Certificate2 ByRef, System.Security.Cryptography.X509Certificates.X509Certificate2Collection)bool w_btS_S_p_i4_oPoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_oPoDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, Il2CppObject* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan`1[System.Byte], System.Security.Cryptography.PbeParameters, System.Span`1[System.Byte], Int32 ByRef)bool w_btS_S_p_i4_oS_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_oS_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, Il2CppObject* p2, struct S_S_p_i4_ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.LocalKeyword)bool w_btS_S_p_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_su4_* pp1 = DataTransfer::GetPointer<S_S_p_su4_>(env, _sv1);
    S_S_p_su4_ p1 = pp1 ? *pp1 : S_S_p_su4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_su4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Animations.AnimationClipPlayable)bool w_btS_S_pu4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_pu4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_pu4__* pp1 = DataTransfer::GetPointer<S_S_pu4__>(env, _sv1);
    S_S_pu4__ p1 = pp1 ? *pp1 : S_S_pu4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_pu4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.TransformOrigin)bool w_btS_S_r4i4_S_r4i4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4i4_S_r4i4_r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(env, _sv1);
    S_S_r4i4_S_r4i4_r4_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4i4_S_r4i4_r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.Translate)bool w_btS_S_r4i4_S_r4i4_r4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4i4_S_r4i4_r4b_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(env, _sv1);
    S_S_r4i4_S_r4i4_r4b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4b_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4i4_S_r4i4_r4b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.Rotate)bool w_btS_S_r4i4_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4i4_S_r4r4r4_b_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(env, _sv1);
    S_S_r4i4_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4r4r4_b_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4i4_S_r4r4r4_b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleLength)bool w_btS_S_r4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_i4_>(env, _sv1);
    S_S_r4i4_i4_ p1 = pp1 ? *pp1 : S_S_r4i4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.TextShadow)bool w_btS_S_r4r4_r4S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4_r4S_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(env, _sv1);
    S_S_r4r4_r4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_r4S_r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4_r4S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Bounds)bool w_btS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Frame(UnityEngine.Bounds, Boolean)bool w_btS_S_r4r4r4_S_r4r4r4__Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4__Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single)bool w_btS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IntersectRay(UnityEngine.Ray, Single ByRef)bool w_btS_S_r4r4r4_S_r4r4r4__Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4__Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Pose)bool w_btS_S_r4r4r4_S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.Scale)bool w_btS_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_b_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(env, _sv1);
    S_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4r4r4_b_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Numerics.Plane)bool w_btS_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.CameraProperties)bool w_btS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_>(env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UI.ColorBlock)bool w_btS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_>(env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleColor)bool w_btS_S_r4r4r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(env, _sv1);
    S_S_r4r4r4r4_i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4r4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.SortingSettings)bool w_btS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.BlendState)bool w_btS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Numerics.Vector`1[T])bool w_btS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord)bool w_btS_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_* pp1 = DataTransfer::GetPointer<S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_>(env, _sv1);
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p1 = pp1 ? *pp1 : S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Build.Content.ObjectIdentifier)bool w_btS_S_u4u4u4u4_i8i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u4u4u4u4_i8i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(env, _sv1);
    S_S_u4u4u4u4_i8i4s_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_i8i4s_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u4u4u4u4_i8i4s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsValid(UnityEngine.Experimental.AI.NavMeshLocation)bool w_btS_S_u8_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(env, _sv1);
    S_S_u8_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsAmbiguousTime(System.DateTimeOffset)bool w_btS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8_i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.GlobalObjectId)bool w_btS_S_u8u8_S_u4u4u4u4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8u8_S_u4u4u4u4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_S_u4u4u4u4_i4_* pp1 = DataTransfer::GetPointer<S_S_u8u8_S_u4u4u4u4_i4_>(env, _sv1);
    S_S_u8u8_S_u4u4u4u4_i4_ p1 = pp1 ? *pp1 : S_S_u8u8_S_u4u4u4u4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8u8_S_u4u4u4u4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Experimental.Rendering.SceneStateHash)bool w_btS_S_u8u8_S_u8u8_S_u8u8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8u8_S_u8u8_S_u8u8__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_S_u8u8_S_u8u8__* pp1 = DataTransfer::GetPointer<S_S_u8u8_S_u8u8_S_u8u8__>(env, _sv1);
    S_S_u8u8_S_u8u8_S_u8u8__ p1 = pp1 ? *pp1 : S_S_u8u8_S_u8u8_S_u8u8__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8u8_S_u8u8_S_u8u8__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.XR.MeshInfo)bool w_btS_S_u8u8_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8u8_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_i4i4_* pp1 = DataTransfer::GetPointer<S_S_u8u8_i4i4_>(env, _sv1);
    S_S_u8u8_i4i4_ p1 = pp1 ? *pp1 : S_S_u8u8_i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8u8_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.XR.MeshGenerationResult)bool w_btS_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.XR.MeshTransform)bool w_btS_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple)bool w_btS__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef bool (*FuncToCall)(void*,struct S__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAdvanceTo(T, Boolean)bool w_btS__Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS__Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.SceneManagement.StageHandle)bool w_btS_bS_i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_bS_i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_bS_i4__* pp1 = DataTransfer::GetPointer<S_bS_i4__>(env, _sv1);
    S_bS_i4__ p1 = pp1 ? *pp1 : S_bS_i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_bS_i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsTouching(UnityEngine.ContactFilter2D)bool w_btS_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_bbbbbbS_i4_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Threading.AsyncFlowControl)bool w_btS_boo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_boo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_boo_* pp1 = DataTransfer::GetPointer<S_boo_>(env, _sv1);
    S_boo_ p1 = pp1 ? *pp1 : S_boo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_boo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ConsoleKeyInfo)bool w_btS_ci4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ci4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ci4i4_* pp1 = DataTransfer::GetPointer<S_ci4i4_>(env, _sv1);
    S_ci4i4_ p1 = pp1 ? *pp1 : S_ci4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ci4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.SortingLayerRange)bool w_btS_i2i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i2i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i2i2_* pp1 = DataTransfer::GetPointer<S_i2i2_>(env, _sv1);
    S_i2i2_ p1 = pp1 ? *pp1 : S_i2i2_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i2i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleTextShadow)bool w_btS_i4S_S_r4r4_r4S_r4r4r4r4___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_S_r4r4_r4S_r4r4r4r4___");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_S_r4r4_r4S_r4r4r4r4___* pp1 = DataTransfer::GetPointer<S_i4S_S_r4r4_r4S_r4r4r4r4___>(env, _sv1);
    S_i4S_S_r4r4_r4S_r4r4r4r4___ p1 = pp1 ? *pp1 : S_i4S_S_r4r4_r4S_r4r4r4r4___ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_S_r4r4_r4S_r4r4r4r4___ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.ScriptableCullingParameters)bool w_btS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* pp1 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(env, _sv1);
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p1 = pp1 ? *pp1 : S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleFontDefinition)bool w_btS_i4S_oo__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_oo__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_oo__* pp1 = DataTransfer::GetPointer<S_i4S_oo__>(env, _sv1);
    S_i4S_oo__ p1 = pp1 ? *pp1 : S_i4S_oo__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_oo__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.BackgroundSize)bool w_btS_i4S_r4i4_S_r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_r4i4_S_r4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(env, _sv1);
    S_i4S_r4i4_S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4_S_r4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_r4i4_S_r4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.BackgroundPosition)bool w_btS_i4S_r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_r4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4__>(env, _sv1);
    S_i4S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_r4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.LODParameters)bool w_btS_i4S_r4r4r4_r4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_r4r4r4_r4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4r4r4_r4r4i4_* pp1 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4r4i4_>(env, _sv1);
    S_i4S_r4r4r4_r4r4i4_ p1 = pp1 ? *pp1 : S_i4S_r4r4r4_r4r4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_r4r4r4_r4r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.VisibleLight)bool w_btS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* pp1 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_>(env, _sv1);
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p1 = pp1 ? *pp1 : S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.ShadowSplitData)bool w_btS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(env, _sv1);
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p1 = pp1 ? *pp1 : S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Index)bool w_btS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UI.Navigation)bool w_btS_i4boooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4boooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4boooo_* pp1 = DataTransfer::GetPointer<S_i4boooo_>(env, _sv1);
    S_i4boooo_ p1 = pp1 ? *pp1 : S_i4boooo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4boooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Guid)bool w_btS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BlockUntilRecvMsg(System.Guid, Int32)bool w_btS_i4i2i2u1u1u1u1u1u1u1u1_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i2i2u1u1u1u1u1u1u1u1_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPrimaryInteropAssembly(System.Guid, Int32, Int32, Int32, System.String ByRef, System.String ByRef)bool w_btS_i4i2i2u1u1u1u1u1u1u1u1_i4i4i4PsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i2i2u1u1u1u1u1u1u1u1_i4i4i4PsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        
     // LuaValToCSVal Ps
    Il2CppString* up6 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv6); // string ref
    Il2CppString** p6 = &up6;
        
    typedef bool (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, int32_t p3, int32_t p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TrySend(System.Guid, Byte[])bool w_btS_i4i2i2u1u1u1u1u1u1u1u1_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TrySend(System.Guid, Byte[], Int32)bool w_btS_i4i2i2u1u1u1u1u1u1u1u1_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i2i2u1u1u1u1u1u1u1u1_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(UnityEngine.Vector2Int)bool w_btS_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.AttachmentDescriptor)bool w_btS_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_* pp1 = DataTransfer::GetPointer<S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_>(env, _sv1);
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p1 = pp1 ? *pp1 : S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Threading.LockCookie)bool w_btS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetTileAnimationData(UnityEngine.Vector3Int, UnityEngine.Tilemaps.ITilemap, UnityEngine.Tilemaps.TileAnimationData ByRef)bool w_btS_i4i4i4_oPS_or4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4_oPS_or4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_or4r4i4_* p3 = DataTransfer::GetPointer<S_or4r4i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_or4r4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4_ p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean StartUp(UnityEngine.Vector3Int, UnityEngine.Tilemaps.ITilemap, UnityEngine.GameObject)bool w_btS_i4i4i4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4_oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Overlaps(UnityEngine.RectInt)bool w_btS_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Reflection.Emit.ExceptionHandler)bool w_btS_i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Decimal)bool w_btS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.RenderTargetIdentifier)bool w_btS_i4i4i4pi4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4i4pi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.RasterState)bool w_btS_i4i4r4u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4r4u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4r4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i4r4u1u1u1u1_>(env, _sv1);
    S_i4i4r4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i4r4u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4i4r4u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleList`1[T])bool w_btS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Presets.PresetType)bool w_btS_i4os_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4os_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4os_* pp1 = DataTransfer::GetPointer<S_i4os_>(env, _sv1);
    S_i4os_ p1 = pp1 ? *pp1 : S_i4os_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4os_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(UnityEngine.UIElements.StylePropertyName)bool w_btS_i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Unity.Properties.PropertyPathPart)bool w_btS_i4si4O_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4si4O_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4si4O_* pp1 = DataTransfer::GetPointer<S_i4si4O_>(env, _sv1);
    S_i4si4O_ p1 = pp1 ? *pp1 : S_i4si4O_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4si4O_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsCameraDrawModeSupported(CameraMode)bool w_btS_i4ss_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4ss_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4ss_* pp1 = DataTransfer::GetPointer<S_i4ss_>(env, _sv1);
    S_i4ss_ p1 = pp1 ? *pp1 : S_i4ss_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4ss_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Compare(UnityEngine.TextCore.FaceInfo)bool w_btS_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.TimeSpan)bool w_btS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Change(System.TimeSpan, System.TimeSpan)bool w_btS_i8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8_S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i8_ p1, struct S_i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Wait(System.TimeSpan, System.Threading.CancellationToken)bool w_btS_i8_S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8_S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i8_ p1, struct S_o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WaitOne(System.TimeSpan, Boolean)bool w_btS_i8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,struct S_i8_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.TimerState)bool w_btS_i8i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8i8_* pp1 = DataTransfer::GetPointer<S_i8i8_>(env, _sv1);
    S_i8i8_ p1 = pp1 ? *pp1 : S_i8i8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i8i8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Diagnostics.CounterSample)bool w_btS_i8i8i8i8i8i8i8i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8i8i8i8i8i8i8i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp1 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(env, _sv1);
    S_i8i8i8i8i8i8i8i4_ p1 = pp1 ? *pp1 : S_i8i8i8i8i8i8i8i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_i8i8i8i8i8i8i8i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Threading.CancellationTokenRegistration)bool w_btS_oS_oi4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oS_oi4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oS_oi4__* pp1 = DataTransfer::GetPointer<S_oS_oi4__>(env, _sv1);
    S_oS_oi4__ p1 = pp1 ? *pp1 : S_oS_oi4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oS_oi4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.Cursor)bool w_btS_oS_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oS_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oS_r4r4_i4_* pp1 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(env, _sv1);
    S_oS_r4r4_i4_ p1 = pp1 ? *pp1 : S_oS_r4r4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oS_r4r4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`1[T1])bool w_btS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.StyleFont)bool w_btS_oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4_* pp1 = DataTransfer::GetPointer<S_oi4_>(env, _sv1);
    S_oi4_ p1 = pp1 ? *pp1 : S_oi4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ArraySegment`1[T])bool w_btS_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv1);
    S_oi4i4_ p1 = pp1 ? *pp1 : S_oi4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oi4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Add(ShaderVariant)bool w_btS_oi4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oi4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4o_* pp1 = DataTransfer::GetPointer<S_oi4o_>(env, _sv1);
    S_oi4o_ p1 = pp1 ? *pp1 : S_oi4o_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oi4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`2[T1,T2])bool w_btS_oo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oo_* pp1 = DataTransfer::GetPointer<S_oo_>(env, _sv1);
    S_oo_ p1 = pp1 ? *pp1 : S_oo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`3[T1,T2,T3])bool w_btS_ooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooo_* pp1 = DataTransfer::GetPointer<S_ooo_>(env, _sv1);
    S_ooo_ p1 = pp1 ? *pp1 : S_ooo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`4[T1,T2,T3,T4])bool w_btS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.UIElements.UQueryBuilder`1[T])bool w_btS_ooooi4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ooooi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooooi4i4i4_* pp1 = DataTransfer::GetPointer<S_ooooi4i4i4_>(env, _sv1);
    S_ooooi4i4i4_ p1 = pp1 ? *pp1 : S_ooooi4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ooooi4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`5[T1,T2,T3,T4,T5])bool w_btS_ooooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ooooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooooo_* pp1 = DataTransfer::GetPointer<S_ooooo_>(env, _sv1);
    S_ooooo_ p1 = pp1 ? *pp1 : S_ooooo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ooooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`6[T1,T2,T3,T4,T5,T6])bool w_btS_oooooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oooooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooooo_* pp1 = DataTransfer::GetPointer<S_oooooo_>(env, _sv1);
    S_oooooo_ p1 = pp1 ? *pp1 : S_oooooo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oooooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`8[T1,T2,T3,T4,T5,T6,T7,TRest])bool w_btS_oooooooS___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_oooooooS___");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooooooS___* pp1 = DataTransfer::GetPointer<S_oooooooS___>(env, _sv1);
    S_oooooooS___ p1 = pp1 ? *pp1 : S_oooooooS___ {};
        
    typedef bool (*FuncToCall)(void*,struct S_oooooooS___ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ValueTuple`7[T1,T2,T3,T4,T5,T6,T7])bool w_btS_ooooooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ooooooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooooooo_* pp1 = DataTransfer::GetPointer<S_ooooooo_>(env, _sv1);
    S_ooooooo_ p1 = pp1 ? *pp1 : S_ooooooo_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ooooooo_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RemoveRemap(SourceAssetIdentifier)bool w_btS_os_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_os_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_os_* pp1 = DataTransfer::GetPointer<S_os_>(env, _sv1);
    S_os_ p1 = pp1 ? *pp1 : S_os_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_os_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.CullingResults)bool w_btS_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__* pp1 = DataTransfer::GetPointer<S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__>(env, _sv1);
    S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ p1 = pp1 ? *pp1 : S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.ScriptableRenderContext)bool w_btS_pS_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_pS_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pS_pi4i4__* pp1 = DataTransfer::GetPointer<S_pS_pi4i4__>(env, _sv1);
    S_pS_pi4i4__ p1 = pp1 ? *pp1 : S_pS_pi4i4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_pS_pi4i4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.ModuleHandle)bool w_btS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Playables.PlayableHandle)bool w_btS_pu4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_pu4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_pu4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.BoneWeight1)bool w_btS_r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditorInternal.AnimationKeyTime)bool w_btS_r4i4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4i4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4i4r4_* pp1 = DataTransfer::GetPointer<S_r4i4r4_>(env, _sv1);
    S_r4i4r4_ p1 = pp1 ? *pp1 : S_r4i4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4i4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(UnityEngine.Vector2)bool w_btS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsRaycastLocationValid(UnityEngine.Vector2, UnityEngine.Camera)bool w_btS_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetDestination(UnityEngine.Vector3)bool w_btS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef)bool w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SweepTest(UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)bool w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SweepTest(UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)bool w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, void* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SweepTest(UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, UnityEngine.QueryTriggerInteraction)bool w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, void* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SameSide(UnityEngine.Vector3, UnityEngine.Vector3)bool w_btS_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_btS_r4r4r4_S_r4r4r4_Dr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_S_r4r4r4_Dr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_btS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_Dr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_Dr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, void* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)bool w_btS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_btS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_Dr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_Dr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, struct S_r4r4r4r4_ p5, void* p6, void* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_btS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_Dr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_Dr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p5 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, void* p5, void* p6, void* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(UnityEngine.Vector3, Boolean)bool w_btS_r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CalculatePath(UnityEngine.Vector3, UnityEngine.AI.NavMeshPath)bool w_btS_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_btS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_Dr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_Dr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, void* p4, void* p5, void* p6, void* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Overlaps(UnityEngine.Rect)bool w_btS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Overlaps(UnityEngine.Rect, Boolean)bool w_btS_r4r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.BoneWeight)bool w_btS_r4r4r4r4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4i4i4i4_>(env, _sv1);
    S_r4r4r4r4i4i4i4i4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.TextCore.GlyphMetrics)bool w_btS_r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Numerics.Matrix3x2)bool w_btS_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Matrix4x4)bool w_btS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.SphericalHarmonicsL2)bool w_btS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Numerics.Complex)bool w_btS_r8r8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r8r8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r8r8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Security.Cryptography.HashAlgorithmName)bool w_btS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.Vector2], UnityEngine.Vector2 ByRef)bool w_btS_s_PS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_PS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.Vector3], UnityEngine.Vector3 ByRef)bool w_btS_s_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.Quaternion], UnityEngine.Quaternion ByRef)bool w_btS_s_PS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_PS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.XR.Hand], UnityEngine.XR.Hand ByRef)bool w_btS_s_PS_u8u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_PS_u8u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal Pstruct
    S_u8u4_* p2 = DataTransfer::GetPointer<S_u8u4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8u4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.Boolean], Boolean ByRef)bool w_btS_s_Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.Single], Single ByRef)bool w_btS_s_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.UInt32], UInt32 ByRef)bool w_btS_s_Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetCertHash(System.Security.Cryptography.HashAlgorithmName, System.Span`1[System.Byte], Int32 ByRef)bool w_btS_s_S_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.Vector2], System.DateTime, UnityEngine.Vector2 ByRef)bool w_btS_s_S_u8_PS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_u8_PS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p3 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_u8_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.Vector3], System.DateTime, UnityEngine.Vector3 ByRef)bool w_btS_s_S_u8_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_u8_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_u8_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[UnityEngine.Quaternion], System.DateTime, UnityEngine.Quaternion ByRef)bool w_btS_s_S_u8_PS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_u8_PS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_u8_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.Boolean], System.DateTime, Boolean ByRef)bool w_btS_s_S_u8_Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_u8_Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_u8_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.Single], System.DateTime, Single ByRef)bool w_btS_s_S_u8_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_u8_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_u8_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.UInt32], System.DateTime, UInt32 ByRef)bool w_btS_s_S_u8_Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_S_u8_Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, struct S_u8_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFeatureValue(UnityEngine.XR.InputFeatureUsage`1[System.Byte[]], Byte[])bool w_btS_s_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_s_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,struct S_s_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.MPE.ChannelInfo)bool w_btS_si4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_si4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4_* pp1 = DataTransfer::GetPointer<S_si4_>(env, _sv1);
    S_si4_ p1 = pp1 ? *pp1 : S_si4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_si4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.MPE.ChannelClientInfo)bool w_btS_si4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_si4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_si4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(UnityEditor.Search.StringView, System.StringComparison)bool w_btS_si4i4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_si4i4_Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,struct S_si4i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Search.StringView, System.StringComparison)bool w_btS_si4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_si4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,struct S_si4i4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Security.Cryptography.CngProperty)bool w_btS_si4oN_bi4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_si4oN_bi4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4oN_bi4__* pp1 = DataTransfer::GetPointer<S_si4oN_bi4__>(env, _sv1);
    S_si4oN_bi4__ p1 = pp1 ? *pp1 : S_si4oN_bi4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_si4oN_bi4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Search.SearchDocument)bool w_btS_si4ssi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_si4ssi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4ssi4_* pp1 = DataTransfer::GetPointer<S_si4ssi4_>(env, _sv1);
    S_si4ssi4_ p1 = pp1 ? *pp1 : S_si4ssi4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_si4ssi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.EditorCurveBinding)bool w_btS_sosi4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_sosi4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_sosi4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Search.SearchField)bool w_btS_ssO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ssO_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ssO_* pp1 = DataTransfer::GetPointer<S_ssO_>(env, _sv1);
    S_ssO_ p1 = pp1 ? *pp1 : S_ssO_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ssO_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Experimental.AssetMoveInfo)bool w_btS_ss_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_ss_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ss_* pp1 = DataTransfer::GetPointer<S_ss_>(env, _sv1);
    S_ss_ p1 = pp1 ? *pp1 : S_ss_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_ss_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.ShaderMessage)bool w_btS_sssi4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_sssi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sssi4i4i4_* pp1 = DataTransfer::GetPointer<S_sssi4i4i4_>(env, _sv1);
    S_sssi4i4i4_ p1 = pp1 ? *pp1 : S_sssi4i4i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_sssi4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Search.SearchProposition)bool w_btS_sssi4i4osS_r4r4r4r4_oO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_sssi4i4osS_r4r4r4r4_oO_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sssi4i4osS_r4r4r4r4_oO_* pp1 = DataTransfer::GetPointer<S_sssi4i4osS_r4r4r4r4_oO_>(env, _sv1);
    S_sssi4i4osS_r4r4r4r4_oO_ p1 = pp1 ? *pp1 : S_sssi4i4osS_r4r4r4r4_oO_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_sssi4i4osS_r4r4r4r4_oO_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.ManagedReferenceMissingType)bool w_btS_sssi8s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_sssi8s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sssi8s_* pp1 = DataTransfer::GetPointer<S_sssi8s_>(env, _sv1);
    S_sssi8s_ p1 = pp1 ? *pp1 : S_sssi8s_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_sssi8s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsEnabled(UnityEngine.Rendering.GlobalKeyword)bool w_btS_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_su4_* pp1 = DataTransfer::GetPointer<S_su4_>(env, _sv1);
    S_su4_ p1 = pp1 ? *pp1 : S_su4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_su4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsEnabled(UnityEngine.Rendering.ShaderKeyword)bool w_btS_su4bbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_su4bbb_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_su4bbb_* pp1 = DataTransfer::GetPointer<S_su4bbb_>(env, _sv1);
    S_su4bbb_ p1 = pp1 ? *pp1 : S_su4bbb_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_su4bbb_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.DepthState)bool w_btS_u1i1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u1i1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u1i1_* pp1 = DataTransfer::GetPointer<S_u1i1_>(env, _sv1);
    S_u1i1_ p1 = pp1 ? *pp1 : S_u1i1_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u1i1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Buffers.StandardFormat)bool w_btS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1_>(env, _sv1);
    S_u1u1_ p1 = pp1 ? *pp1 : S_u1u1_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Reflection.Emit.OpCode)bool w_btS_u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Rendering.StencilState)bool w_btS_u1u1u1u1u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_u1u1u1u1u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord)bool w_btS_u4S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4S_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(env, _sv1);
    S_u4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_u4S_r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4S_r4r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.GraphicsBufferHandle)bool w_btS_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.XR.HapticCapabilities)bool w_btS_u4bbu4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4bbu4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4bbu4u4u4_* pp1 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(env, _sv1);
    S_u4bbu4u4u4_ p1 = pp1 ? *pp1 : S_u4bbu4u4u4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4bbu4u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsValid(UnityEngine.Animations.AnimationStream)bool w_btS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4pppppp_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4pppppp_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.RefreshRate)bool w_btS_u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.GUID)bool w_btS_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4u4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4u4u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEditor.Search.PropertyDatabaseRecordKey)bool w_btS_u8S_u8u8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8S_u8u8__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8S_u8u8__* pp1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, _sv1);
    S_u8S_u8u8__ p1 = pp1 ? *pp1 : S_u8S_u8u8__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8S_u8u8__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoadProperty(UnityEditor.Search.PropertyDatabaseRecordKey, System.Object ByRef)bool w_btS_u8S_u8u8__PO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8S_u8u8__PO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8S_u8u8__* pp1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, _sv1);
    S_u8S_u8u8__ p1 = pp1 ? *pp1 : S_u8S_u8u8__ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,struct S_u8S_u8u8__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoadAlias(UnityEditor.Search.PropertyDatabaseRecordKey, System.String ByRef)bool w_btS_u8S_u8u8__Ps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8S_u8u8__Ps");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8S_u8u8__* pp1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, _sv1);
    S_u8S_u8u8__ p1 = pp1 ? *pp1 : S_u8S_u8u8__ {};
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,struct S_u8S_u8u8__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsAmbiguousTime(System.DateTime)bool w_btS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPortalPoints(UnityEngine.Experimental.AI.PolygonId, UnityEngine.Experimental.AI.PolygonId, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)bool w_btS_u8_S_u8_PS_r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8_S_u8_PS_r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(void*,struct S_u8_ p1, struct S_u8_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.XR.InputDevice)bool w_btS_u8b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8b_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8b_* pp1 = DataTransfer::GetPointer<S_u8b_>(env, _sv1);
    S_u8b_ p1 = pp1 ? *pp1 : S_u8b_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8b_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.DisplayInfo)bool w_btS_u8i4i4S_u4u4_S_i4i4i4i4_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8i4i4S_u4u4_S_i4i4i4i4_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8i4i4S_u4u4_S_i4i4i4i4_s_* pp1 = DataTransfer::GetPointer<S_u8i4i4S_u4u4_S_i4i4i4i4_s_>(env, _sv1);
    S_u8i4i4S_u4u4_S_i4i4i4i4_s_ p1 = pp1 ? *pp1 : S_u8i4i4S_u4u4_S_i4i4i4i4_s_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Unity.Jobs.JobHandle)bool w_btS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8i4i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8i4i4p_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.XR.Hand)bool w_btS_u8u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8u4_* pp1 = DataTransfer::GetPointer<S_u8u4_>(env, _sv1);
    S_u8u4_ p1 = pp1 ? *pp1 : S_u8u4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.Hash128)bool w_btS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Store(UnityEngine.Hash128, System.Object)bool w_btS_u8u8_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8u8_O");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                            }
     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,struct S_u8u8_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean HasExtension(System.String[])bool w_btVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btVs");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Boolean)bool w_btb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetCullingParameters(Boolean, UnityEngine.Rendering.ScriptableCullingParameters ByRef)bool w_btbPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btbPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p2 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,bool p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FrameSelected(Boolean, Boolean)bool w_btbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btbb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,bool p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean EndsWith(Char)bool w_btc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean HasCharacter(Char, Boolean, Boolean)bool w_btcDbDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcDbDb");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean StartsWith(Char, System.StringComparison)bool w_btcDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcDi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetCharacterInfo(Char, UnityEngine.CharacterInfo ByRef)bool w_btcPS_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcPS_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_* p2 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetCharacterInfo(Char, UnityEngine.CharacterInfo ByRef, Int32)bool w_btcPS_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcPS_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_i4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_* p2 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetCharacterInfo(Char, UnityEngine.CharacterInfo ByRef, Int32, UnityEngine.FontStyle)bool w_btcPS_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcPS_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_i4i4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_* p2 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4S_r4r4r4r4_S_r4r4r4r4_r4i4i4b_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, void* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Add(Char, Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btcPi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcPi4Pi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Fallback(Char, Char, Int32)bool w_btcci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btcci4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Contains(Char, System.StringComparison)bool w_btci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btci4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyChar(Char, Int32, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btci4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btci4Pi4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean InsertAt(Char, Int32, Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btci4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btci4Pi4Pi4");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Replace(Char, Int32, Int32, Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btci4i4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btci4i4Pi4Pi4");
    
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, int32_t p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(SByte)bool w_bti1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,int8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Int16)bool w_bti2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,int16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsNormalized(System.Text.NormalizationForm)bool w_bti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValue(Int32, System.Object ByRef)bool w_bti4PO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PO");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetShadowCasterBounds(Int32, UnityEngine.Bounds ByRef)bool w_bti4PS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4__* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ComputeSpotShadowMatricesAndCullingPrimitives(Int32, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef)bool w_bti4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
     // LuaValToCSVal Pstruct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p4 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetUnityObjectNativeTypeInfo(Int32, UnityObjectNativeTypeInfo ByRef)bool w_bti4PS_si4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_si4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_si4_* p2 = DataTransfer::GetPointer<S_si4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_si4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetUnityObjectInfo(Int32, UnityObjectInfo ByRef)bool w_bti4PS_si4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_si4i4u8_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_si4i4u8_* p2 = DataTransfer::GetPointer<S_si4i4u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_si4i4u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLookup(Int32, System.Xml.XmlDictionaryString ByRef)bool w_bti4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Po");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetSpatializerFloat(Int32, Single ByRef)bool w_bti4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Pr4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindTextureStack(Int32, System.String ByRef, Int32 ByRef)bool w_bti4PsPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PsPi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetOverrideSampleSettings(UnityEditor.BuildTargetGroup, UnityEditor.AudioImporterSampleSettings)bool w_bti4S_i4i4u4i4r4i4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4S_i4i4u4i4r4i4b_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4i4u4i4r4i4b_* pp2 = DataTransfer::GetPointer<S_i4i4u4i4r4i4b_>(env, _sv2);
    S_i4i4u4i4r4i4b_ p2 = pp2 ? *pp2 : S_i4i4u4i4r4i4b_ {};
        
    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_i4i4u4i4r4i4b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Wait(Int32, System.Threading.CancellationToken)bool w_bti4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4S_o_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ModifyVertexesColorByIndex(Int32, UnityEngine.Color)bool w_bti4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4S_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WaitOne(Int32, Boolean)bool w_bti4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Change(Int32, Int32)bool w_bti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RemoveAt(Int32, Int32, Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_bti4i4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4Pi4Pi4");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsLeapMonth(Int32, Int32, Int32)bool w_bti4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ComputeDirectionalShadowMatricesAndCullingPrimitives(Int32, Int32, Int32, UnityEngine.Vector3, Int32, Single, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef)bool w_bti4i4i4S_r4r4r4_i4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4i4S_r4r4r4_i4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p7 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv7)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up7;
    if (!p7) {
        memset(&up7, 0, sizeof(p7));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p8 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv8)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up8;
    if (!p8) {
        memset(&up8, 0, sizeof(p8));
    }
        
     // LuaValToCSVal Pstruct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p9 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(env, pesapi_unboxing(env, _sv9)); // valuetype ref
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ up9;
    if (!p9) {
        memset(&up9, 0, sizeof(p9));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, struct S_r4r4r4_ p4, int32_t p5, float p6, void* p7, void* p8, void* p9, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Reinitialize(Int32, Int32, UnityEngine.TextureFormat, Boolean)bool w_bti4i4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4i4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsLeapDay(Int32, Int32, Int32, Int32)bool w_bti4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AddFrame(Int32, Int32, Int32, UnityEngine.TextureFormat, Unity.Collections.NativeArray`1[System.Byte])bool w_bti4i4i4i4S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4i4i4S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp5 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp5 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv5);
    S_Pvi4i4i4S_pi4i4_i4_ p5 = pp5 ? *pp5 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, struct S_Pvi4i4i4S_pi4i4_i4_ p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AddFrame(Int32, Int32, Int32, UnityEngine.TextureFormat, Unity.Collections.NativeArray`1[System.Byte], UnityEditor.Media.MediaTime)bool w_bti4i4i4i4S_Pvi4i4i4S_pi4i4_i4_S_i8S_i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4i4i4S_Pvi4i4i4S_pi4i4_i4_S_i8S_i4i4__");
    
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp5 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv5);
    S_Pvi4i4i4S_pi4i4_i4_ p5 = pp5 ? *pp5 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_i8S_i4i4__* pp6 = DataTransfer::GetPointer<S_i8S_i4i4__>(env, _sv6);
    S_i8S_i4i4__ p6 = pp6 ? *pp6 : S_i8S_i4i4__ {};
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, struct S_Pvi4i4i4S_pi4i4_i4_ p5, struct S_i8S_i4i4__ p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ComputePointShadowMatricesAndCullingPrimitives(Int32, UnityEngine.CubemapFace, Single, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef)bool w_bti4i4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
     // LuaValToCSVal Pstruct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* p6 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(env, pesapi_unboxing(env, _sv6)); // valuetype ref
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(p6));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, float p3, void* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsEnabled(System.Diagnostics.Tracing.EventLevel, System.Diagnostics.Tracing.EventKeywords)bool w_bti4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsEnabled(System.Diagnostics.Tracing.EventLevel, System.Diagnostics.Tracing.EventKeywords, System.Diagnostics.Tracing.EventChannel)bool w_bti4i8u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i8u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int64_t p2, uint8_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetFingerBones(UnityEngine.XR.HandFinger, System.Collections.Generic.List`1[UnityEngine.XR.Bone])bool w_bti4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ModifyAccessRule(System.Security.AccessControl.AccessControlModification, System.Security.AccessControl.AccessRule, Boolean ByRef)bool w_bti4oPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4oPb");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RemoveAccess(System.Security.AccessControl.AccessControlType, System.Security.Principal.SecurityIdentifier, Int32, System.Security.AccessControl.InheritanceFlags, System.Security.AccessControl.PropagationFlags)bool w_bti4oi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4oi4i4i4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RemoveAccess(System.Security.AccessControl.AccessControlType, System.Security.Principal.SecurityIdentifier, Int32, System.Security.AccessControl.InheritanceFlags, System.Security.AccessControl.PropagationFlags, System.Security.AccessControl.ObjectAceFlags, System.Guid, System.Guid)bool w_bti4oi4i4i4i4S_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4oi4i4i4i4S_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp7 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv7);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p7 = pp7 ? *pp7 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp8 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv8);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p8 = pp8 ? *pp8 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p7, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RemoveAccess(System.Security.AccessControl.AccessControlType, System.Security.Principal.SecurityIdentifier, System.Security.AccessControl.ObjectAccessRule)bool w_bti4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetSpatializerFloat(Int32, Single)bool w_bti4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SamplePathPosition(Int32, Single, UnityEngine.AI.NavMeshHit ByRef)bool w_bti4r4PS_S_r4r4r4_S_r4r4r4_r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4r4PS_S_r4r4r4_S_r4r4r4_r4i4i4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, float p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Int64)bool w_bti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Change(Int64, Int64)bool w_bti8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti8i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,int64_t p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetSelection(UnityEditor.Profiling.IProfilerFrameTimeViewSampleSelectionController, Int64, System.String, System.String, Int32, System.Collections.Generic.List`1[System.Int32], UInt64)bool w_bti8ssi4DoDu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti8ssi4DoDu8");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,int64_t p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetSelection(UnityEditor.Profiling.IProfilerFrameTimeViewSampleSelectionController, Int64, System.String, System.String, System.String, System.String, UInt64)bool w_bti8sssDsDu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti8sssDsDu8");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,int64_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.TimeZoneInfo)bool w_bto(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bto");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BakeMesh(UnityEngine.Mesh, Boolean)bool w_btoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsValid(System.ComponentModel.ITypeDescriptorContext, System.Object)bool w_btoO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryBinaryOperation(System.Dynamic.BinaryOperationBinder, System.Object, System.Object ByRef)bool w_btoOPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoOPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(Byte[], System.Object, Byte[])bool w_btoOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetMember(System.Dynamic.GetMemberBinder, System.Object ByRef)bool w_btoPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetMirrorViewBlitDesc(UnityEngine.RenderTexture, XRMirrorViewBlitDesc ByRef)bool w_btoPS_pbbi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPS_pbbi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_pbbi4_* p2 = DataTransfer::GetPointer<S_pbbi4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_pbbi4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetMirrorViewBlitDesc(UnityEngine.RenderTexture, XRMirrorViewBlitDesc ByRef, Int32)bool w_btoPS_pbbi4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPS_pbbi4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_pbbi4_* p2 = DataTransfer::GetPointer<S_pbbi4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_pbbi4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPortCenterOverride(UnityEditor.Experimental.GraphView.Port, UnityEngine.Vector2 ByRef)bool w_btoPS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetInstructionToken(Mono.Cecil.Cil.Instruction, Mono.Cecil.MetadataToken ByRef)bool w_btoPS_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPS_u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_u4_* p2 = DataTransfer::GetPointer<S_u4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAdd(System.Xml.XmlDictionaryString, Int32 ByRef)bool w_btoPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValue(TKey, TValue ByRef)bool w_btoPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAddCharacters(UInt32[], UInt32[] ByRef, Boolean)bool w_btoPoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPoDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifySignatureForSignerInfo(System.Security.Cryptography.Pkcs.SignerInfo, System.Security.Cryptography.X509Certificates.X509Certificate2 ByRef, System.Security.Cryptography.X509Certificates.X509Certificate2Collection)bool w_btoPoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPoDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AcceptsElement(UnityEditor.Experimental.GraphView.GraphElement, System.String ByRef)bool w_btoPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsTouching(UnityEngine.Collider2D, UnityEngine.ContactFilter2D)bool w_btoS_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AddFrame(UnityEngine.Texture2D, UnityEditor.Media.MediaTime)bool w_btoS_i8S_i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_i8S_i4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8S_i4i4__* pp2 = DataTransfer::GetPointer<S_i8S_i4i4__>(env, _sv2);
    S_i8S_i4i4__ p2 = pp2 ? *pp2 : S_i8S_i4i4__ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_i8S_i4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAdd(T, System.TimeSpan)bool w_btoS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_btoS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, T ByRef)bool w_btoS_oooo_PS__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_PS__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
     // LuaValToCSVal Pstruct
    S__* p3 = DataTransfer::GetPointer<S__>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, UnityEngine.Color ByRef)bool w_btoS_oooo_PS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_PS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, UnityEngine.Hash128 ByRef)bool w_btoS_oooo_PS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_PS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
     // LuaValToCSVal Pstruct
    S_u8u8_* p3 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_u8u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, Boolean ByRef)bool w_btoS_oooo_Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, Int32 ByRef)bool w_btoS_oooo_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, Int64 ByRef)bool w_btoS_oooo_Pi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, System.Type ByRef)bool w_btoS_oooo_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, Single ByRef)bool w_btoS_oooo_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, Double ByRef)bool w_btoS_oooo_Pr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, System.String ByRef)bool w_btoS_oooo_Ps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Ps");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, UInt32 ByRef)bool w_btoS_oooo_Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext, UInt64 ByRef)bool w_btoS_oooo_Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_oooo_Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Security.Policy.CodeGroup, Boolean)bool w_btob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btob");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AddGraphicsThreadMirrorViewBlit(UnityEngine.Rendering.CommandBuffer, Boolean, Int32)bool w_btobi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btobi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, bool p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Fallback(Byte[], Int32)bool w_btoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindIndex(System.Xml.XPath.XPathNavigator, Int32, System.Xml.Xsl.Runtime.XmlILIndex ByRef)bool w_btoi4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAdd(T, Int32, System.Threading.CancellationToken)bool w_btoi4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, struct S_o_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RenderToCubemap(UnityEngine.RenderTexture, Int32, MonoOrStereoscopicEye)bool w_btoi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(Byte[], Int32, Int32, Byte[])bool w_btoi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(Byte[], Int32, Int32, Byte[], System.Security.Cryptography.HashAlgorithmName)bool w_btoi4i4oS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4i4oS_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_s_* pp5 = DataTransfer::GetPointer<S_s_>(env, _sv5);
    S_s_ p5 = pp5 ? *pp5 : S_s_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, struct S_s_ p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(Byte[], Int32, Int32, Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)bool w_btoi4i4oS_s_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4i4oS_s_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_s_* pp5 = DataTransfer::GetPointer<S_s_>(env, _sv5);
    S_s_ p5 = pp5 ? *pp5 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, struct S_s_ p5, Il2CppObject* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifySignature(System.Security.Cryptography.HashAlgorithm, Byte[])bool w_btoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BakeMesh(UnityEngine.Mesh, UnityEngine.Camera, Boolean)bool w_btooDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TrySetIndex(System.Dynamic.SetIndexBinder, System.Object[], System.Object)bool w_btooO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryInvokeMember(System.Dynamic.InvokeMemberBinder, System.Object[], System.Object ByRef)bool w_btooPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PerformDrop(UnityEditor.EditorWindow, UnityEditor.DropInfo, UnityEngine.Vector2)bool w_btooS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyData(Byte[], Byte[], System.Security.Cryptography.HashAlgorithmName)bool w_btooS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooS_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_s_* pp3 = DataTransfer::GetPointer<S_s_>(env, _sv3);
    S_s_ p3 = pp3 ? *pp3 : S_s_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, struct S_s_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyHash(Byte[], Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)bool w_btooS_s_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooS_s_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_s_* pp3 = DataTransfer::GetPointer<S_s_>(env, _sv3);
    S_s_ p3 = pp3 ? *pp3 : S_s_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, struct S_s_ p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryUpdate(TKey, TValue, TValue)bool w_btooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DragPerform(UnityEngine.UIElements.DragPerformEvent, System.Collections.Generic.IEnumerable`1[UnityEditor.Experimental.GraphView.ISelectable], UnityEditor.Experimental.GraphView.IDropTarget, UnityEditor.Experimental.GraphView.ISelection)bool w_btoooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginRename(UnityEditor.IMGUI.Controls.TreeViewItem, Single)bool w_btor4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btor4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean hasMethod(System.Type, System.String)bool w_btos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btos");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ShouldTrace(System.Diagnostics.TraceEventCache, System.String, System.Diagnostics.TraceEventType, Int32, System.String, System.Object[], System.Object, System.Object[])bool w_btosi4i4soOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btosi4i4soOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];
    auto TIp8 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, int32_t p3, int32_t p4, Il2CppString* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean VerifyHash(Byte[], System.String, Byte[])bool w_btoso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Check(IntPtr)bool w_btp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btp");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean luaTableCheck(IntPtr, Int32)bool w_btpi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btpi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Assignable(IntPtr, Int32, System.Type)bool w_btpi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btpi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,void* p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryDelayWrapLoader(IntPtr, System.Type)bool w_btpo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btpo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Single)bool w_btr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btr4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Single, Single)bool w_btr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btr4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProjectionMatrix(Single, Single, UnityEngine.Matrix4x4 ByRef)bool w_btr4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btr4r4PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,float p1, float p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Double)bool w_btr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btr8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,double p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean EqualityOperator(Double, System.Collections.Generic.IList`1[System.Xml.XPath.XPathItem], System.Collections.Generic.IList`1[System.Xml.XPath.XPathItem])bool w_btr8oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btr8oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,double p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean EndsWith(System.String)bool w_bts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean LoadImageFromFile(System.String, Boolean)bool w_btsDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.String, System.StringComparison)bool w_btsDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetSelection(UnityEditor.Profiling.IProfilerFrameTimeViewSampleSelectionController, System.String, Int64, System.String, System.String, UInt64)bool w_btsDi8DsDsDu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsDi8DsDsDu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(System.String, UnityEditor.AssetImporters.TexturePropertyDescription ByRef)bool w_btsPS_S_r4r4_S_r4r4_oss_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPS_S_r4r4_S_r4r4_oss_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_S_r4r4_S_r4r4_oss_* p2 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_oss_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4_S_r4r4_oss_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Populate(System.String, UnityEngine.TextGenerationSettings ByRef)bool w_btsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p2 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PopulateWithErrors(System.String, UnityEngine.TextGenerationSettings ByRef, UnityEngine.GameObject)bool w_btsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p2 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(System.String, UnityEngine.Vector4 ByRef)bool w_btsPS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetField(System.String, UnityEditor.Search.SearchField ByRef)bool w_btsPS_ssO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPS_ssO_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_ssO_* p2 = DataTransfer::GetPointer<S_ssO_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_ssO_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(System.String, Int32 ByRef)bool w_btsPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPlatformTextureSettings(System.String, Int32 ByRef, UnityEditor.TextureImporterFormat ByRef)bool w_btsPi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPlatformTextureSettings(System.String, Int32 ByRef, UnityEditor.TextureImporterFormat ByRef, Int32 ByRef)bool w_btsPi4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPi4Pi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPlatformTextureSettings(System.String, Int32 ByRef, UnityEditor.TextureImporterFormat ByRef, Int32 ByRef, Boolean ByRef)bool w_btsPi4Pi4Pi4Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPi4Pi4Pi4Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean HasCharacters(System.String, System.Collections.Generic.List`1[System.Char] ByRef)bool w_btsPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean HasCharacters(System.String, UInt32[] ByRef, Boolean, Boolean)bool w_btsPoDbDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPoDbDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetFloatBuffer(System.String, Single[] ByRef, Int32)bool w_btsPoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetFloat(System.String, Single ByRef)bool w_btsPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetFloatParameterInfo(System.String, Single ByRef, Single ByRef, Single ByRef)bool w_btsPr4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPr4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(System.String, System.String ByRef)bool w_btsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAddCharacters(System.String, System.String ByRef, Boolean)bool w_btsPsDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPsDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetOverrideSampleSettings(System.String, UnityEditor.AudioImporterSampleSettings)bool w_btsS_i4i4u4i4r4i4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsS_i4i4u4i4r4i4b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4u4i4r4i4b_* pp2 = DataTransfer::GetPointer<S_i4i4u4i4r4i4b_>(env, _sv2);
    S_i4i4u4i4r4i4b_ p2 = pp2 ? *pp2 : S_i4i4u4i4r4i4b_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, struct S_i4i4u4i4r4i4b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Populate(System.String, UnityEngine.TextGenerationSettings)bool w_btsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* pp2 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, _sv2);
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2 = pp2 ? *pp2 : S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ {};
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PopulateWithErrors(System.String, UnityEngine.TextGenerationSettings, UnityEngine.GameObject)bool w_btsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* pp2 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, _sv2);
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2 = pp2 ? *pp2 : S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetBool(System.String, Boolean)bool w_btsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean EndsWith(System.String, Boolean, System.Globalization.CultureInfo)bool w_btsbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsbo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean EndsWith(System.String, System.StringComparison)bool w_btsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean OnOpenedAsset(System.String, Int32, Int32)bool w_btsi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean InsertAt(System.String, Int32, Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btsi4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4Pi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDefinitionAllowed(System.String, System.Configuration.ConfigurationAllowDefinition, System.Configuration.ConfigurationAllowExeDefinition)bool w_btsi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Replace(System.String, Int32, Int32, Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btsi4i4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4i4Pi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginRename(System.String, Int32, Single)bool w_btsi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetValue(System.String, UnityEditor.Search.SearchContext, UnityEditor.Search.SearchField ByRef)bool w_btsoPS_ssO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsoPS_ssO_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_ssO_* p3 = DataTransfer::GetPointer<S_ssO_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_ssO_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GUIWrongShader(System.String, UnityEngine.Material, NodeType)bool w_btsoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetFloat(System.String, Single)bool w_btsr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.String, System.String)bool w_btss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Store(System.String, System.String, System.Object)bool w_btssO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btssO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetAnimationCurve(System.String, System.String, UnityEngine.AnimationCurve ByRef)bool w_btssPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btssPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsPrefix(System.String, System.String, System.Globalization.CompareOptions)bool w_btssi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btssi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean OpenInRider(System.String, System.String, Int32, Int32)bool w_btssi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btssi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean MoveToFollowing(System.String, System.String, System.Xml.XPath.XPathNavigator)bool w_btsso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean OpenFile(System.String, System.String, System.String, Int32, Int32)bool w_btsssi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsssi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WriteMessageEvent(System.String, Byte, Int64)bool w_btsu1i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsu1i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, uint8_t p2, int64_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(Byte)bool w_btu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,uint8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsEnabled(Byte, Int64)bool w_btu1i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu1i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,uint8_t p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UInt16)bool w_btu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,uint16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AddSamples(UInt16, Unity.Collections.NativeArray`1[System.Single])bool w_btu2S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu2S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(void*,uint16_t p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UInt32)bool w_btu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean HasCharacter(UInt32, Boolean, Boolean)bool w_btu4DbDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4DbDb");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SendHapticBuffer(UInt32, Byte[])bool w_btu4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SendHapticImpulse(UInt32, Single, Single)bool w_btu4r4Dr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4r4Dr4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, float p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Change(UInt32, UInt32)bool w_btu4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetOptimalSettings(UInt32, UInt32, UnityEngine.NVIDIA.DLSSQuality, UnityEngine.NVIDIA.OptimalDLSSSettingsData ByRef)bool w_btu4u4i4PS_u4u4r4u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4u4i4PS_u4u4r4u4u4u4u4_");
    
    auto TIp4 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_u4u4r4u4u4u4u4_* p4 = DataTransfer::GetPointer<S_u4u4r4u4u4u4u4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_u4u4r4u4u4u4u4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, uint32_t p2, int32_t p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UInt64)bool w_btu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(void*,uint64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetGfxResourceInfo(UInt64, GfxResourceInfo ByRef)bool w_btu8PS_u8i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu8PS_u8i4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_u8i4_* p2 = DataTransfer::GetPointer<S_u8i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(void*,uint64_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoad(UInt64, System.Collections.Generic.IEnumerable`1[System.Object] ByRef)bool w_btu8Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu8Po");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,uint64_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Store(UInt64, UnityEngine.Hash128, System.Object)bool w_btu8S_u8u8_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu8S_u8u8_O");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_u8u8_* pp2 = DataTransfer::GetPointer<S_u8u8_>(env, _sv2);
    S_u8u8_ p2 = pp2 ? *pp2 : S_u8u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,uint64_t p1, struct S_u8u8_ p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoadAsset(UInt64, System.Func`5[System.UInt64,System.String,System.String,System.Int32,System.Boolean], System.Func`7[System.UInt64,System.Int64,System.String,System.UInt64,System.Int64,System.String,System.Boolean])bool w_btu8oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu8oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,uint64_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoadProperty(UInt64, System.String, UnityEditor.Search.PropertyDatabaseRecordKey ByRef, System.Object ByRef, System.String ByRef)bool w_btu8sPS_u8S_u8u8__POPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu8sPS_u8S_u8u8__POPs");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Pstruct
    S_u8S_u8u8__* p3 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_u8S_u8u8__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
        
     // LuaValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        
    typedef bool (*FuncToCall)(void*,uint64_t p1, Il2CppString* p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Byte)bool w_bu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(uint8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Byte, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bu1S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu1S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(uint8_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(UInt16)bool w_bu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(uint16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(UInt16, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bu2S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu2S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(uint16_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(UInt32)bool w_bu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(uint32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGlyphIndex(UInt32, UInt32 ByRef)bool w_bu4Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4Pu4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(uint32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(UInt32, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bu4S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(uint32_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGlyphWithUnicodeValue(UInt32, UnityEngine.TextCore.LowLevel.GlyphLoadFlags, UnityEngine.TextCore.Glyph ByRef)bool w_bu4i4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4i4Po");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(uint32_t p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAddGlyphToTexture(UInt32, Int32, UnityEngine.TextCore.LowLevel.GlyphPackingMode, System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], UnityEngine.TextCore.LowLevel.GlyphRenderMode, UnityEngine.Texture2D, UnityEngine.TextCore.Glyph ByRef)bool w_bu4i4i4ooi4oPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4i4i4ooi4oPo");
    
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up8 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv8)); // object ret
    Il2CppObject** p8 = &up8;
        
    typedef bool (*FuncToCall)(uint32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(UInt64)bool w_bu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(uint64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(UInt64, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bu8S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu8S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(uint64_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_LessThan(UInt64, System.Numerics.BigInteger)bool w_bu8S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu8S_i4o_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
    typedef bool (*FuncToCall)(uint64_t p1, struct S_i4o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Char get_DefaultPasswordChar()bool w_c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_c");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppChar (*FuncToCall)(const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.Object)bool w_cO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.Object, System.IFormatProvider)bool w_cOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.ReadOnlySpan`1[System.Byte])bool w_cS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef Il2CppChar (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.Decimal)bool w_cS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppChar (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.DateTime)bool w_cS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef Il2CppChar (*FuncToCall)(struct S_u8_ p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Boolean)bool w_cb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(bool p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToUpper(Char)bool w_cc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(Il2CppChar p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToUpper(Char, System.Globalization.CultureInfo)bool w_cco(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cco");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(SByte)bool w_ci1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(int8_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Int16)bool w_ci2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(int16_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Int32)bool w_ci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(int32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Int64)bool w_ci8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(int64_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Byte[], Int32)bool w_coi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_coi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppChar (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char GetCharArrayElement(IntPtr, Int32)bool w_cpi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cpi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppChar (*FuncToCall)(void* p1, int32_t p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char GetCharField(IntPtr, IntPtr)bool w_cpp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cpp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef Il2CppChar (*FuncToCall)(void* p1, void* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char CallCharMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_cppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef Il2CppChar (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char CallCharMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_cppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef Il2CppChar (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char CallCharMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_cppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppChar (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Single)bool w_cr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cr4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(float p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Double)bool w_cr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cr8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(double p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char Parse(System.String)bool w_cs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cs");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef Il2CppChar (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char HexUnescape(System.String, Int32 ByRef)bool w_csPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_csPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppChar (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.String, System.IFormatProvider)bool w_cso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char get_Current()bool w_ct(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ct");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppChar (*FuncToCall)(void*,const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(System.Object)bool w_ctO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ctO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppChar (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToLower(Char)bool w_ctc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ctc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char get_Chars(Int32)bool w_cti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ReadChar(Int64)bool w_cti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(void*,int64_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char GetChar(System.String)bool w_cts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef Il2CppChar (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(Byte)bool w_cu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(uint8_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(UInt16)bool w_cu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(uint16_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(UInt32)bool w_cu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// Char ToChar(UInt64)bool w_cu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef Il2CppChar (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<Il2CppChar>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.Object)bool w_i1O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int8_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.Object, System.IFormatProvider)bool w_i1Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int8_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte VolatileRead(SByte ByRef)bool w_i1Pi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1Pi1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int8_t (*FuncToCall)(void* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_i1S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int8_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.Decimal)bool w_i1S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef int8_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte op_Explicit(System.Numerics.BigInteger)bool w_i1S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef int8_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.DateTime)bool w_i1S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef int8_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Boolean)bool w_i1b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(bool p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Char)bool w_i1c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(SByte)bool w_i1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(int8_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte Max(SByte, SByte)bool w_i1i1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i1i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
    typedef int8_t (*FuncToCall)(int8_t p1, int8_t p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte Clamp(SByte, SByte, SByte)bool w_i1i1i1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i1i1i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int8_t p3 = converter::Converter<int8_t>::toCpp(env, _sv3);        
        
    typedef int8_t (*FuncToCall)(int8_t p1, int8_t p2, int8_t p3, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Int16)bool w_i1i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(int16_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Int32)bool w_i1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(int32_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Int64)bool w_i1i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(int64_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte GetSByteArrayElement(IntPtr, Int32)bool w_i1pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int8_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte GetSByteField(IntPtr, IntPtr)bool w_i1pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef int8_t (*FuncToCall)(void* p1, void* p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte CallSByteMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_i1ppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef int8_t (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte CallSByteMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_i1ppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef int8_t (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte CallSByteMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_i1ppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int8_t (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Single)bool w_i1r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(float p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Double)bool w_i1r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(double p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.String)bool w_i1s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef int8_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.String, Int32)bool w_i1si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_i1si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.String, System.IFormatProvider)bool w_i1so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int8_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ReadSByte()bool w_i1t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef int8_t (*FuncToCall)(void*,const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(System.Object)bool w_i1tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int8_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte NextSByte(SByte)bool w_i1ti1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ti1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(void*,int8_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte NextSByte(SByte, SByte)bool w_i1ti1i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ti1i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
    typedef int8_t (*FuncToCall)(void*,int8_t p1, int8_t p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ReadSByte(Int64)bool w_i1ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(void*,int64_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte GetSByte(System.String)bool w_i1ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef int8_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(Byte)bool w_i1u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(uint8_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(UInt16)bool w_i1u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(uint16_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(UInt32)bool w_i1u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(uint32_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// SByte ToSByte(UInt64)bool w_i1u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef int8_t (*FuncToCall)(uint64_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int8_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.Object)bool w_i2O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int16_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ReadInt16(System.Object, Int32)bool w_i2Oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2Oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.Object, System.IFormatProvider)bool w_i2Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int16_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 VolatileRead(Int16 ByRef)bool w_i2Pi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2Pi2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int16_t (*FuncToCall)(void* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.ReadOnlySpan`1[System.Byte])bool w_i2S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef int16_t (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_i2S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int16_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.Decimal)bool w_i2S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef int16_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 op_Explicit(System.Numerics.BigInteger)bool w_i2S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef int16_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.DateTime)bool w_i2S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef int16_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Boolean)bool w_i2b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(bool p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Char)bool w_i2c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(SByte)bool w_i2i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(int8_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Int16)bool w_i2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(int16_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 Max(Int16, Int16)bool w_i2i2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i2i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(int16_t p1, int16_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 Clamp(Int16, Int16, Int16)bool w_i2i2i2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i2i2i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int16_t p3 = converter::Converter<int16_t>::toCpp(env, _sv3);        
        
    typedef int16_t (*FuncToCall)(int16_t p1, int16_t p2, int16_t p3, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Int32)bool w_i2i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(int32_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Int64)bool w_i2i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(int64_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Byte[], Int32)bool w_i2oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ReadInt16(IntPtr)bool w_i2p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2p");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(void* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ReadInt16(IntPtr, Int32)bool w_i2pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 GetShortField(IntPtr, IntPtr)bool w_i2pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(void* p1, void* p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 CallShortMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_i2ppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef int16_t (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 CallShortMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_i2ppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef int16_t (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 CallShortMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_i2ppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int16_t (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Single)bool w_i2r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(float p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Double)bool w_i2r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(double p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.String)bool w_i2s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef int16_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.String, Int32)bool w_i2si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_i2si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.String, System.IFormatProvider)bool w_i2so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int16_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 get_MajorRevision()bool w_i2t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef int16_t (*FuncToCall)(void*,const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(System.Object)bool w_i2tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int16_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 NextShort(Int16)bool w_i2ti2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ti2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(void*,int16_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 NextShort(Int16, Int16)bool w_i2ti2i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ti2i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef int16_t (*FuncToCall)(void*,int16_t p1, int16_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ReadInt16(Int64)bool w_i2ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(void*,int64_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 GetInt16(System.String)bool w_i2ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef int16_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(Byte)bool w_i2u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(uint8_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(UInt16)bool w_i2u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(uint16_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(UInt32)bool w_i2u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(uint32_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int16 ToInt16(UInt64)bool w_i2u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef int16_t (*FuncToCall)(uint64_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int16_t>::toScript(env, ret));        return true;
}
// Int32 get_MaxGeneration()bool w_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef int32_t (*FuncToCall)(const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.TypeCode GetTypeCode(System.Object)bool w_i4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4O");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.Object, System.Object)bool w_i4OO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4OO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReadInt32(System.Object, Int32)bool w_i4Oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(System.Object, System.IFormatProvider)bool w_i4Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 VolatileRead(Int32 ByRef)bool w_i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Exchange(Int32 ByRef, Int32)bool w_i4Pi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OutRefFunc5(Int32 ByRef, Int32, Int32 ByRef)bool w_i4Pi4i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pi4i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareExchange(Int32 ByRef, Int32, Int32)bool w_i4Pi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OutRefFunc15(ITestLuaClass ByRef, ITestLuaClass, ITestLuaClass ByRef)bool w_i4PooPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4PooPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef int32_t (*FuncToCall)(void* p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 NewStaticSafetyId(Byte*, Int32)bool w_i4Pu1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pu1i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExtractStackTraceNoAlloc(Byte*, Int32, System.String)bool w_i4Pu1i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pu1i4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 MemCmp(Void*, Void*, Int64)bool w_i4PvPvi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4PvPvi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!pesapi_is_binary(env, _sv2) && !pesapi_is_null(env, _sv2) && !pesapi_is_undefined(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, int64_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SaveTimeManagerState(Unity.Collections.NativeArray`1[System.Byte])bool w_i4S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(System.ReadOnlySpan`1[System.Byte])bool w_i4S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_i4S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_p_i4_Di4Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.Buffers.OperationStatus DecodeFromUtf8InPlace(System.Span`1[System.Byte], Int32 ByRef)bool w_i4S_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Byte], Int32 ByRef, Int32 ByRef, Boolean)bool w_i4S_S_p_i4_S_S_p_i4_Pi4Pi4Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_p_i4_S_S_p_i4_Pi4Pi4Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.Buffers.OperationStatus EncodeToUtf8InPlace(System.Span`1[System.Byte], Int32, Int32 ByRef)bool w_i4S_S_p_i4_i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_p_i4_i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[])bool w_i4S_S_r4r4r4_S_r4r4r4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[], Single)bool w_i4S_S_r4r4r4_S_r4r4r4__or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[], Single, Int32)bool w_i4S_S_r4r4r4_S_r4r4r4__or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppObject* p2, float p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_S_r4r4r4_S_r4r4r4__or4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__or4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppObject* p2, float p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[])bool w_i4S_S_r4r4r4_S_r4r4r4__r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[], Single)bool w_i4S_S_r4r4r4_S_r4r4r4__r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__r4or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, Il2CppObject* p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[], Single, Int32)bool w_i4S_S_r4r4r4_S_r4r4r4__r4or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__r4or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, Il2CppObject* p3, float p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_S_r4r4r4_S_r4r4r4__r4or4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_r4r4r4_S_r4r4r4__r4or4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, Il2CppObject* p3, float p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInstanceID(UnityEditor.Build.Content.ObjectIdentifier)bool w_i4S_S_u4u4u4u4_i8i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_u4u4u4u4_i8i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(env, _sv1);
    S_S_u4u4u4u4_i8i4s_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_i8i4s_ {};
        
    typedef int32_t (*FuncToCall)(struct S_S_u4u4u4u4_i8i4s_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.DateTimeOffset, System.DateTimeOffset)bool w_i4S_S_u8_i2_S_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_u8_i2_S_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal struct
    S_S_u8_i2_* pp2 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv2);
    S_S_u8_i2_ p2 = pp2 ? *pp2 : S_S_u8_i2_ {};
        
    typedef int32_t (*FuncToCall)(struct S_S_u8_i2_ p1, struct S_S_u8_i2_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GlobalObjectIdentifierToInstanceIDSlow(UnityEditor.GlobalObjectId)bool w_i4S_S_u8u8_S_u4u4u4u4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_S_u8u8_S_u4u4u4u4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_S_u4u4u4u4_i4_* pp1 = DataTransfer::GetPointer<S_S_u8u8_S_u4u4u4u4_i4_>(env, _sv1);
    S_S_u8u8_S_u4u4u4u4_i4_ p1 = pp1 ? *pp1 : S_S_u8u8_S_u4u4u4u4_i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_S_u8u8_S_u4u4u4u4_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetLastPing(UnityEngine.NetworkPlayer)bool w_i4S__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef int32_t (*FuncToCall)(struct S__ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 op_Implicit(UnityEngine.LayerMask)bool w_i4S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetRenderTextureSupportedMSAASampleCount(UnityEngine.RenderTextureDescriptor)bool w_i4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(System.Decimal)bool w_i4S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.Decimal, System.Decimal)bool w_i4S_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 op_Explicit(System.Numerics.BigInteger)bool w_i4S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4o_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.Numerics.BigInteger, System.Numerics.BigInteger)bool w_i4S_i4o_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4o_S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4o_ p1, struct S_i4o_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.TimeSpan, System.TimeSpan)bool w_i4S_i8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i8_S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i8_ p1, struct S_i8_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Unity.Collections.LowLevel.Unsafe.EnforceJobResult EnforceAllBufferJobsHaveCompleted(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle)bool w_i4S_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_pi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_pi4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetReaderArray(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, Int32, IntPtr)bool w_i4S_pi4i4_i4p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_pi4i4_i4p");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(struct S_pi4i4_ p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPoint(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single)bool w_i4S_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4S_r4r4_S_r4r4_i4r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single)bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];
    auto TIp8 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, Il2CppObject* p7, void* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, Il2CppObject* p7, float p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, Il2CppObject* p6, float p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32)bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, Il2CppObject* p6, float p7, int32_t p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single)bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!converter::Converter<float>::accept(env, _sv9)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(env, _sv9);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, Il2CppObject* p6, float p7, int32_t p8, float p9, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single, Single)bool w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4S_r4r4_or4i4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 10) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!converter::Converter<float>::accept(env, _sv9)) return false;                if (!converter::Converter<float>::accept(env, _sv10)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(env, _sv9);        
        
 // LuaValToCSVal P any
    float p10 = converter::Converter<float>::toCpp(env, _sv10);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, Il2CppObject* p6, float p7, int32_t p8, float p9, float p10, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Collider2D[])bool w_i4S_r4r4_S_r4r4_i4r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Collider2D[], Int32)bool w_i4S_r4r4_S_r4r4_i4r4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, Il2CppObject* p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Collider2D[], Int32, Single)bool w_i4S_r4r4_S_r4r4_i4r4oi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4oi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, Il2CppObject* p5, int32_t p6, float p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Collider2D[], Int32, Single, Single)bool w_i4S_r4r4_S_r4r4_i4r4oi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_i4r4oi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, Il2CppObject* p5, int32_t p6, float p7, float p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 LinecastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 LinecastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Int32)bool w_i4S_r4r4_S_r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 LinecastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Int32, Single)bool w_i4S_r4r4_S_r4r4_oi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_oi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, int32_t p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 LinecastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Int32, Single, Single)bool w_i4S_r4r4_S_r4r4_oi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_oi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, int32_t p4, float p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_S_r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32)bool w_i4S_r4r4_S_r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, float p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single)bool w_i4S_r4r4_S_r4r4_or4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_or4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, float p4, int32_t p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single, Single)bool w_i4S_r4r4_S_r4r4_or4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_or4i4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, float p4, int32_t p5, float p6, float p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBox(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4S_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single)bool w_i4S_r4r4_S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, void* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, float p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_S_r4r4_r4S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_S_r4r4_r4S_r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, Il2CppObject* p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32)bool w_i4S_r4r4_S_r4r4_r4S_r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, Il2CppObject* p5, float p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single)bool w_i4S_r4r4_S_r4r4_r4S_r4r4_or4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_or4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, Il2CppObject* p5, float p6, int32_t p7, float p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single, Single)bool w_i4S_r4r4_S_r4r4_r4S_r4r4_or4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4S_r4r4_or4i4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;                if (!converter::Converter<float>::accept(env, _sv9)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(env, _sv9);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, Il2CppObject* p5, float p6, int32_t p7, float p8, float p9, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Collider2D[])bool w_i4S_r4r4_S_r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32)bool w_i4S_r4r4_S_r4r4_r4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32, Single)bool w_i4S_r4r4_S_r4r4_r4oi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4oi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, Il2CppObject* p4, int32_t p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32, Single, Single)bool w_i4S_r4r4_S_r4r4_r4oi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_S_r4r4_r4oi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, Il2CppObject* p4, int32_t p5, float p6, float p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPointNonAlloc(UnityEngine.Vector2, UnityEngine.Collider2D[])bool w_i4S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPointNonAlloc(UnityEngine.Vector2, UnityEngine.Collider2D[], Int32)bool w_i4S_r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPointNonAlloc(UnityEngine.Vector2, UnityEngine.Collider2D[], Int32, Single)bool w_i4S_r4r4_oi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_oi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, int32_t p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPointNonAlloc(UnityEngine.Vector2, UnityEngine.Collider2D[], Int32, Single, Single)bool w_i4S_r4r4_oi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_oi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, int32_t p3, float p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircle(UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single)bool w_i4S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCastNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[])bool w_i4S_r4r4_r4S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCastNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single)bool w_i4S_r4r4_r4S_r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, Il2CppObject* p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCastNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32)bool w_i4S_r4r4_r4S_r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, Il2CppObject* p4, float p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCastNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single)bool w_i4S_r4r4_r4S_r4r4_or4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_or4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, Il2CppObject* p4, float p5, int32_t p6, float p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCastNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single, Single)bool w_i4S_r4r4_r4S_r4r4_or4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4S_r4r4_or4i4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, Il2CppObject* p4, float p5, int32_t p6, float p7, float p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircleNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Collider2D[])bool w_i4S_r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircleNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32)bool w_i4S_r4r4_r4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircleNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32, Single)bool w_i4S_r4r4_r4oi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4oi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircleNonAlloc(UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32, Single, Single)bool w_i4S_r4r4_r4oi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4_r4oi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, float p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[])bool w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion)bool w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, struct S_r4r4r4r4_ p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single)bool w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, struct S_r4r4r4r4_ p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single, Int32)bool w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, struct S_r4r4r4r4_ p5, float p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, struct S_r4r4r4r4_ p5, float p6, int32_t p7, int32_t p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[])bool w_i4S_r4r4r4_S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion)bool w_i4S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion, Int32)bool w_i4S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBoxNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single)bool w_i4S_r4r4r4_S_r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32)bool w_i4S_r4r4r4_S_r4r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, float p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_S_r4r4r4_or4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_or4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, float p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[])bool w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single)bool w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32)bool w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, float p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_or4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4S_r4r4r4_or4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, float p6, int32_t p7, int32_t p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[])bool w_i4S_r4r4r4_S_r4r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32)bool w_i4S_r4r4r4_S_r4r4r4_r4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_S_r4r4r4_r4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_S_r4r4r4_r4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[])bool w_i4S_r4r4r4_r4S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4S_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single)bool w_i4S_r4r4r4_r4S_r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4S_r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32)bool w_i4S_r4r4r4_r4S_r4r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4S_r4r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, float p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_r4S_r4r4r4_or4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4S_r4r4r4_or4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, float p5, int32_t p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapSphereNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Collider[])bool w_i4S_r4r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapSphereNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32)bool w_i4S_r4r4r4_r4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapSphereNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction)bool w_i4S_r4r4r4_r4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.Rect, Int32)bool w_i4S_r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntSlider(UnityEngine.Rect, Int32, Int32, Int32)bool w_i4S_r4r4r4r4_i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(UnityEngine.Rect, Int32, System.String[])bool w_i4S_r4r4r4r4_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SelectionGrid(UnityEngine.Rect, Int32, System.String[], Int32)bool w_i4S_r4r4r4r4_i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SelectionGrid(UnityEngine.Rect, Int32, System.String[], Int32, UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_i4oi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4oi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, int32_t p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(UnityEngine.Rect, Int32, System.String[], UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(UnityEngine.Rect, Int32, UnityEngine.GUIContent[], UnityEngine.GUIStyle, ToolbarButtonSize)bool w_i4S_r4r4r4r4_i4ooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4ooi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntPopup(UnityEngine.Rect, Int32, System.String[], Int32[], UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_i4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_i4ooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.Rect, UnityEngine.GUIContent, Int32)bool w_i4S_r4r4r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntSlider(UnityEngine.Rect, UnityEngine.GUIContent, Int32, Int32, Int32)bool w_i4S_r4r4r4r4_oi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_oi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.Rect, UnityEngine.GUIContent, Int32, UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_oi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_oi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Popup(UnityEngine.Rect, UnityEngine.GUIContent, Int32, UnityEngine.GUIContent[], UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_oi4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_oi4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntPopup(UnityEngine.Rect, UnityEngine.GUIContent, Int32, UnityEngine.GUIContent[], Int32[], UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_oi4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_oi4ooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.Rect, System.String, Int32)bool w_i4S_r4r4r4r4_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_si4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntSlider(UnityEngine.Rect, System.String, Int32, Int32, Int32)bool w_i4S_r4r4r4r4_si4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_si4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.Rect, System.String, Int32, UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Popup(UnityEngine.Rect, System.String, Int32, System.String[], UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_si4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_si4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntPopup(UnityEngine.Rect, System.String, Int32, System.String[], Int32[], UnityEngine.GUIStyle)bool w_i4S_r4r4r4r4_si4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4r4_si4ooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetArchitecture(UnityEditor.Build.NamedBuildTarget)bool w_i4S_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef int32_t (*FuncToCall)(struct S_s_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Mode GetModeFromCurveData(UnityEditor.EditorCurveBinding)bool w_i4S_sosi4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_sosi4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Rendering.ShaderKeywordType GetGlobalKeywordType(UnityEngine.Rendering.ShaderKeyword)bool w_i4S_su4bbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_su4bbb_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_su4bbb_* pp1 = DataTransfer::GetPointer<S_su4bbb_>(env, _sv1);
    S_su4bbb_ p1 = pp1 ? *pp1 : S_su4bbb_ {};
        
    typedef int32_t (*FuncToCall)(struct S_su4bbb_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(System.DateTime)bool w_i4S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.DateTime, System.DateTime)bool w_i4S_u8_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_u8_S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_u8_ p1, struct S_u8_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetHashCode()bool w_i4T(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4T");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Min(Int32[])bool w_i4Vi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Vi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 WaitAny(System.Threading.Tasks.Task[])bool w_i4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetMask(System.String[])bool w_i4Vs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Vs");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(Boolean)bool w_i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.HDRSettingResult RequestHDRModeChangeEx(Boolean, Boolean)bool w_i4bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4bb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(bool p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.Globalization.UnicodeCategory GetUnicodeCategory(Char)bool w_i4c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4c");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ConvertToUtf32(Char, Char)bool w_i4cc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4cc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(Il2CppChar p1, Il2CppChar p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(SByte)bool w_i4i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(int8_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(Int16)bool w_i4i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(int16_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(Int32)bool w_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 DefaultParaFuncSingle(Int32, System.String)bool w_i4i4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4Ds");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 DefaultParaFuncMulti(Int32, System.String, Double, Byte)bool w_i4i4DsDr8Du1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4DsDr8Du1");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, void* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OutRefFunc4(Int32, Int32 ByRef, Int32 ByRef)bool w_i4i4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4Pi4Pi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetControlID(UnityEngine.FocusType, UnityEngine.Rect)bool w_i4i4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4S_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 VariableParamFunc(Int32, Int32[])bool w_i4i4Vi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4Vi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(Int32, UnityEngine.GUILayoutOption[])bool w_i4i4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4Vo");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 VariableParamFunc(Int32, System.String[])bool w_i4i4Vs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4Vs");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.Rendering.GraphicsFormat GetGraphicsFormat(UnityEngine.TextureFormat, Boolean)bool w_i4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 DaysInMonth(Int32, Int32)bool w_i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 DivRem(Int32, Int32, Int32 ByRef)bool w_i4i4i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4Pi4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetControlID(Int32, UnityEngine.FocusType, UnityEngine.Rect)bool w_i4i4i4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4S_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, struct S_r4r4r4r4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.NetworkConnectionError InitializeServer(Int32, Int32, Boolean)bool w_i4i4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Clamp(Int32, Int32, Int32)bool w_i4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntSlider(Int32, Int32, Int32, UnityEngine.GUILayoutOption[])bool w_i4i4i4i4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4i4Vo");
    
    auto TIp4 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEditor.DragAndDropVisualMode HierarchyWindowDragByID(Int32, UnityEditor.HierarchyDropFlags, UnityEngine.Transform, Boolean)bool w_i4i4i4ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4ob");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(Int32, System.String[], UnityEngine.GUILayoutOption[])bool w_i4i4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4oVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SelectionGrid(Int32, System.String[], Int32, UnityEngine.GUILayoutOption[])bool w_i4i4oi4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4oi4Vo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SelectionGrid(Int32, System.String[], Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4i4oi4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4oi4oVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(Int32, System.String[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4i4ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4ooVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(Int32, System.String[], UnityEngine.GUIStyle, ToolbarButtonSize, UnityEngine.GUILayoutOption[])bool w_i4i4ooi4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4ooi4Vo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(Int32, UnityEngine.GUIContent[], Boolean[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4i4oooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4oooVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Toolbar(Int32, UnityEngine.GUIContent[], Boolean[], UnityEngine.GUIStyle, ToolbarButtonSize, UnityEngine.GUILayoutOption[])bool w_i4i4oooi4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4oooi4Vo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverLoad2(Int32, Single)bool w_i4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(int32_t p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEditorInternal.CanAppendBuild BuildCanBeAppended(UnityEditor.BuildTarget, System.String)bool w_i4i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4s");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetPropertyNodeID(Int32, System.String, System.Type, System.String)bool w_i4i4sos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4sos");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(Int64)bool w_i4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(int64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.TypeCode GetTypeCode(System.Type)bool w_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(System.Array, System.Object)bool w_i4oO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(System.Array, System.Object, Int32)bool w_i4oOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oOi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(System.Array, System.Object, Int32, Int32)bool w_i4oOi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oOi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(System.Array, System.Object, System.Collections.IComparer)bool w_i4oOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ClampedDetailPatchesGUI(UnityEngine.Terrain, UnityEngine.Vector2 ByRef, System.Collections.Generic.List`1[UnityEngine.Vector4] ByRef)bool w_i4oPS_r4r4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPS_r4r4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TakeFromAny(System.Collections.Concurrent.BlockingCollection`1[T][], T ByRef)bool w_i4oPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OutRefFunc14(ITestLuaClass, ITestLuaClass ByRef, ITestLuaClass ByRef)bool w_i4oPoPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPoPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TryTakeFromAny(System.Collections.Concurrent.BlockingCollection`1[T][], T ByRef, System.TimeSpan)bool w_i4oPoS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPoS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
     // LuaValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, struct S_i8_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TakeFromAny(System.Collections.Concurrent.BlockingCollection`1[T][], T ByRef, System.Threading.CancellationToken)bool w_i4oPoS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPoS_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
     // LuaValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, struct S_o_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TryTakeFromAny(System.Collections.Concurrent.BlockingCollection`1[T][], T ByRef, Int32)bool w_i4oPoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TryTakeFromAny(System.Collections.Concurrent.BlockingCollection`1[T][], T ByRef, Int32, System.Threading.CancellationToken)bool w_i4oPoi4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPoi4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_o_* pp4 = DataTransfer::GetPointer<S_o_>(env, _sv4);
    S_o_ p4 = pp4 ? *pp4 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, void* p2, int32_t p3, struct S_o_ p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCollider(UnityEngine.Collider2D, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4oS_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 WaitAny(System.Threading.WaitHandle[], System.TimeSpan)bool w_i4oS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 WaitAny(System.Threading.WaitHandle[], System.TimeSpan, Boolean)bool w_i4oS_i8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_i8_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 WaitAny(System.Threading.Tasks.Task[], System.Threading.CancellationToken)bool w_i4oS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_o_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEditor.DragAndDropVisualMode SceneViewDrag(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Vector2, UnityEngine.Transform, Boolean)bool w_i4oS_r4r4r4_S_r4r4_ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_r4r4r4_S_r4r4_ob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4_ p3, Il2CppObject* p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Rendering.ShaderKeywordType GetKeywordType(UnityEngine.Shader, UnityEngine.Rendering.ShaderKeyword)bool w_i4oS_su4bbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_su4bbb_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_su4bbb_* pp2 = DataTransfer::GetPointer<S_su4bbb_>(env, _sv2);
    S_su4bbb_ p2 = pp2 ? *pp2 : S_su4bbb_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_su4bbb_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEditor.DragAndDropVisualMode ProjectWindowDrag(UnityEditor.HierarchyProperty, Boolean)bool w_i4ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ob");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(Byte[], Int32)bool w_i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 WaitAny(System.Threading.Tasks.Task[], Int32, System.Threading.CancellationToken)bool w_i4oi4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, struct S_o_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetControlID(UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.Rect)bool w_i4oi4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, struct S_r4r4r4r4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.GUIContent, Int32, UnityEngine.GUILayoutOption[])bool w_i4oi4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 WaitAny(System.Threading.WaitHandle[], Int32, Boolean)bool w_i4oi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.TextCore.LowLevel.FontEngineError LoadFontFace(Byte[], Int32, Int32)bool w_i4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(System.Array, Int32, Int32, System.Object)bool w_i4oi4i4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4O");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(System.Array, Int32, Int32, System.Object, System.Collections.IComparer)bool w_i4oi4i4Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4Oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntSlider(UnityEngine.GUIContent, Int32, Int32, Int32, UnityEngine.GUILayoutOption[])bool w_i4oi4i4i4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4i4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Render_CharactersToTexture(UInt32[], Int32, Int32, UnityEngine.TextCore.LowLevel.GlyphRenderMode, UnityEngine.Texture2D, Int32, Int32, UnityEngine.TextCore.Glyph[], Int32)bool w_i4oi4i4i4oi4i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4i4oi4i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv9)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
 // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(env, _sv9);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, Il2CppObject* p5, int32_t p6, int32_t p7, Il2CppObject* p8, int32_t p9, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.TextCore.LowLevel.FontEngineError RenderGlyphToTexture(UnityEngine.TextCore.Glyph, Int32, UnityEngine.TextCore.LowLevel.GlyphRenderMode, UnityEngine.Texture2D)bool w_i4oi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToBase64CharArray(Byte[], Int32, Int32, Char[], Int32)bool w_i4oi4i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToBase64CharArray(Byte[], Int32, Int32, Char[], Int32, System.Base64FormattingOptions)bool w_i4oi4i4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(UnityEngine.GUIContent, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4oi4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEditor.DragAndDropVisualMode HierarchyWindowDrag(UnityEditor.HierarchyProperty, UnityEditor.HierarchyDropFlags, UnityEngine.Transform, Boolean)bool w_i4oi4ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4ob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Popup(UnityEngine.GUIContent, Int32, UnityEngine.GUIContent[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4oi4ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4ooVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntPopup(UnityEngine.GUIContent, Int32, UnityEngine.GUIContent[], Int32[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4oi4oooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4oooVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.NetworkConnectionError Connect(System.String[], Int32, System.String)bool w_i4oi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.Globalization.SortKey, System.Globalization.SortKey)bool w_i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCollider(UnityEngine.Collider2D, UnityEngine.Collider2D[], Int32)bool w_i4ooDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.Runtime.Remoting.Channels.ServerProcessing DispatchMessage(System.Runtime.Remoting.Channels.IServerChannelSinkStack, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMessage ByRef)bool w_i4ooPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetContacts(UnityEngine.Collider2D, UnityEngine.Collider2D, UnityEngine.ContactFilter2D, UnityEngine.ContactPoint2D[])bool w_i4ooS_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooS_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TryAddToAny(System.Collections.Concurrent.BlockingCollection`1[T][], T, System.TimeSpan)bool w_i4ooS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_i8_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddToAny(System.Collections.Concurrent.BlockingCollection`1[T][], T, System.Threading.CancellationToken)bool w_i4ooS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooS_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FindDetailPrototype(UnityEngine.Terrain, UnityEngine.Terrain, Int32)bool w_i4ooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TryAddToAny(System.Collections.Concurrent.BlockingCollection`1[T][], T, Int32, System.Threading.CancellationToken)bool w_i4ooi4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooi4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_o_* pp4 = DataTransfer::GetPointer<S_o_>(env, _sv4);
    S_o_ p4 = pp4 ? *pp4 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, struct S_o_ p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.Uri, System.Uri, System.UriComponents, System.UriFormat, System.StringComparison)bool w_i4ooi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetColorBlindSafePalette(UnityEngine.Color[], Single, Single)bool w_i4or4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4or4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, float p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.NetworkConnectionError Connect(UnityEngine.HostData, System.String)bool w_i4os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4os");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 op_Explicit(IntPtr)bool w_i4p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4p");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 QueryInterface(IntPtr, System.Guid ByRef, IntPtr ByRef)bool w_i4pPS_i4i2i2u1u1u1u1u1u1u1u1_Pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pPS_i4i2i2u1u1u1u1u1u1u1u1_Pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReadInt32(IntPtr, Int32)bool w_i4pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 lua_gc(IntPtr, XLua.LuaGCOptions, Int32)bool w_i4pi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 lua_pcall(IntPtr, Int32, Int32, Int32)bool w_i4pi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 xlua_pgettable_bypath(IntPtr, Int32, System.String)bool w_i4pi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pi4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RegisterNatives(IntPtr, UnityEngine.JNINativeMethod[])bool w_i4po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 xluaL_loadbuffer(IntPtr, Byte[], Int32, System.String)bool w_i4poi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4poi4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef int32_t (*FuncToCall)(void* p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetIntField(IntPtr, IntPtr)bool w_i4pp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CallIntMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_i4ppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CallIntMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_i4ppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FileRead(IntPtr, IntPtr, Int32)bool w_i4ppi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ppi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CallIntMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_i4ppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ThrowNew(IntPtr, System.String)bool w_i4ps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ps");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef int32_t (*FuncToCall)(void* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExecWaitWithCapture(IntPtr, System.String, System.CodeDom.Compiler.TempFileCollection, System.String ByRef, System.String ByRef)bool w_i4psoPsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4psoPsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        
     // LuaValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        
    typedef int32_t (*FuncToCall)(void* p1, Il2CppString* p2, Il2CppObject* p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 luaL_loadbuffer(IntPtr, System.String, System.String)bool w_i4pss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(void* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExecWaitWithCapture(IntPtr, System.String, System.String, System.CodeDom.Compiler.TempFileCollection, System.String ByRef, System.String ByRef)bool w_i4pssoPsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pssoPsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        
     // LuaValToCSVal Ps
    Il2CppString* up6 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv6); // string ref
    Il2CppString** p6 = &up6;
        
    typedef int32_t (*FuncToCall)(void* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, void* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SingleToInt32Bits(Single)bool w_i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetAdaptiveHeightSegments(Single, Single)bool w_i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(float p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(Double)bool w_i4r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(double p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(System.String)bool w_i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4s");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult IsEventEnabled(System.String, Int32, System.String)bool w_i4sDi4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sDi4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Start(System.String, System.String, Options, Int32)bool w_i4sDsDi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sDsDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, void* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult SendEventWithLimit(System.String, System.Object)bool w_i4sO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult SendEvent(System.String, System.Object, Int32, System.String)bool w_i4sODi4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sODi4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult SendEventWithLimit(System.String, System.Object, Int32)bool w_i4sOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sOi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult Transaction(System.String, System.Decimal, System.String)bool w_i4sS_i4i4i4i4u8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i4i4i4u8_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, struct S_i4i4i4i4u8_ p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult Transaction(System.String, System.Decimal, System.String, System.String, System.String)bool w_i4sS_i4i4i4i4u8_sss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i4i4i4u8_sss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, struct S_i4i4i4i4u8_ p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult Transaction(System.String, System.Decimal, System.String, System.String, System.String, Boolean)bool w_i4sS_i4i4i4i4u8_sssb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_i4i4i4i4u8_sssb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, struct S_i4i4i4i4u8_ p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult CustomEvent(System.String, UnityEngine.Vector3)bool w_i4sS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 LaunchSlave(System.String, System.String[])bool w_i4sVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sVs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Unity.IO.LowLevel.Unsafe.FileSystemError Delete(System.String, Boolean)bool w_i4sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult EnableEvent(System.String, Boolean, Int32, System.String)bool w_i4sbDi4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sbDi4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, bool p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// System.Globalization.UnicodeCategory GetUnicodeCategory(System.String, Int32)bool w_i4si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult SetEventPriority(System.String, UnityEngine.Analytics.AnalyticsEventPriority, Int32, System.String)bool w_i4si4Di4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4Di4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(System.String, Int32, UnityEngine.GUILayoutOption[])bool w_i4si4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.TextCore.LowLevel.FontEngineError LoadFontFace(System.String, Int32, Int32)bool w_i4si4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult RegisterEvent(System.String, Int32, Int32, System.String, System.String)bool w_i4si4i4DsDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4DsDs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntSlider(System.String, Int32, Int32, Int32, UnityEngine.GUILayoutOption[])bool w_i4si4i4i4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4i4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult RegisterEventWithLimit(System.String, Int32, Int32, System.String)bool w_i4si4i4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult RegisterEventWithLimit(System.String, Int32, Int32, System.String, Int32)bool w_i4si4i4si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4si4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult RegisterEvent(System.String, Int32, Int32, System.String, Int32, System.String)bool w_i4si4i4si4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4i4si4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_i4si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntField(System.String, Int32, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4si4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Popup(System.String, Int32, System.String[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4si4ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4ooVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntPopup(System.String, Int32, System.String[], Int32[], UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_i4si4oooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oooVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.NetworkConnectionError Connect(System.String, Int32, System.String)bool w_i4si4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32)bool w_i4si4si4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, Boolean)bool w_i4si4si4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, Boolean, System.Globalization.CultureInfo)bool w_i4si4si4i4bo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4bo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, bool p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, System.StringComparison)bool w_i4si4si4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, System.Globalization.CultureInfo, System.Globalization.CompareOptions)bool w_i4si4si4i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, Il2CppObject* p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToInt32(System.String, System.IFormatProvider)bool w_i4so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExecWaitWithCapture(System.String, System.CodeDom.Compiler.TempFileCollection, System.String ByRef, System.String ByRef)bool w_i4soPsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soPsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
     // LuaValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, System.String)bool w_i4ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult SetEventEndPoint(System.String, System.String, Int32, System.String)bool w_i4ssDi4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssDi4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, System.String, Boolean)bool w_i4ssb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, System.String, Boolean, System.Globalization.CultureInfo)bool w_i4ssbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssbo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, System.String, System.StringComparison)bool w_i4ssi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExecWaitWithCapture(System.String, System.String, System.CodeDom.Compiler.TempFileCollection, System.String ByRef, System.String ByRef)bool w_i4ssoPsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssoPsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Ps
    Il2CppString* up4 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv4); // string ref
    Il2CppString** p4 = &up4;
        
     // LuaValToCSVal Ps
    Il2CppString* up5 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv5); // string ref
    Il2CppString** p5 = &up5;
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.String, System.String, System.Globalization.CultureInfo, System.Globalization.CompareOptions)bool w_i4ssoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult ConfigureCustomEvent(System.String, System.String, Single, Single, Boolean)bool w_i4ssr4r4Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssr4r4Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Analytics.AnalyticsResult ConfigureEvent(System.String, System.String, Single, Single, Boolean, Int32, System.String)bool w_i4ssr4r4DbDi4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssr4r4DbDi4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, void* p5, void* p6, void* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 DisplayDialogComplex(System.String, System.String, System.String, System.String, System.String)bool w_i4sssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sssss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 get_SubKeyCount()bool w_i4t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4t");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetByteCount(Boolean)bool w_i4tDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tDb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.Object)bool w_i4tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Compare(System.Object, System.Object)bool w_i4tOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 addObject(System.Object, Boolean, Boolean)bool w_i4tObb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tObb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, bool p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(System.Object, Int32)bool w_i4tOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(System.Object, Int32, Int32)bool w_i4tOi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(System.Object, System.Collections.IComparer)bool w_i4tOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.AI.PathQueryStatus Raycast(UnityEngine.AI.NavMeshHit ByRef, Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.PolygonId], Int32 ByRef, UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Vector3, Int32, Unity.Collections.NativeArray`1[System.Single])bool w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_Pu1i4i4i4i4S_pi4i4__Pi4S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_Pu1i4i4i4i4S_pi4i4__Pi4S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp2 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv2);
    S_Pu1i4i4i4i4S_pi4i4__ p2 = pp2 ? *pp2 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
     // LuaValToCSVal struct
    S_S_u8_S_r4r4r4__* pp4 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(env, _sv4);
    S_S_u8_S_r4r4r4__ p4 = pp4 ? *pp4 : S_S_u8_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, struct S_Pu1i4i4i4i4S_pi4i4__ p2, void* p3, struct S_S_u8_S_r4r4r4__ p4, struct S_r4r4r4_ p5, void* p6, void* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.AI.PathQueryStatus Raycast(UnityEngine.AI.NavMeshHit ByRef, UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Vector3, Int32, Unity.Collections.NativeArray`1[System.Single])bool w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_S_r4r4r4_S_r4r4r4_r4i4i4_S_S_u8_S_r4r4r4__S_r4r4r4_Di4DS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_S_u8_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(env, _sv2);
    S_S_u8_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_u8_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, struct S_S_u8_S_r4r4r4__ p2, struct S_r4r4r4_ p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetDenseJacobian(UnityEngine.ArticulationJacobian ByRef)bool w_i4tPS_i4i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_i4i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4o_* p1 = DataTransfer::GetPointer<S_i4i4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef int32_t (*FuncToCall)(void*,void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CopyTo(Unity.Profiling.ProfilerRecorderSample*, Int32, Boolean)bool w_i4tPS_i8i8i8_i4Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_i8i8i8_i4Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i8i8i8_* p1 = DataTransfer::GetPointer<S_i8i8i8_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i8i8i8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTrails(Trails ByRef)bool w_i4tPS_oooooi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_oooooi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_oooooi4i4_* p1 = DataTransfer::GetPointer<S_oooooi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_oooooi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef int32_t (*FuncToCall)(void*,void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetByteCount(Char*, Int32)bool w_i4tPci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPci4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetBytes(Char*, Int32, Byte*, Int32)bool w_i4tPci4Pu1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPci4Pu1i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, void* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetBytes(Char*, Int32, Byte*, Int32, Boolean)bool w_i4tPci4Pu1i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPci4Pu1i4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, void* p3, int32_t p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetByteCount(Char*, Int32, Boolean)bool w_i4tPci4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPci4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.AI.PathQueryStatus EndFindPath(Int32 ByRef)bool w_i4tPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetCharCount(Byte*, Int32)bool w_i4tPu1i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPu1i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetChars(Byte*, Int32, Char*, Int32)bool w_i4tPu1i4Pci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPu1i4Pci4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, void* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetChars(Byte*, Int32, Char*, Int32, Boolean)bool w_i4tPu1i4Pci4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPu1i4Pci4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, void* p3, int32_t p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetCharCount(Byte*, Int32, Boolean)bool w_i4tPu1i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPu1i4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetPathResult(Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.PolygonId])bool w_i4tS_Pu1i4i4i4i4S_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pu1i4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv1);
    S_Pu1i4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pu1i4i4i4i4S_pi4i4__ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetPositions(Unity.Collections.NativeArray`1[UnityEngine.Vector3])bool w_i4tS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetCustomShapes(Unity.Collections.NativeArray`1[UnityEngine.PhysicsShape2D], Unity.Collections.NativeArray`1[UnityEngine.Vector2])bool w_i4tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)bool w_i4tS_Pvi4i4i4S_pi4i4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)bool w_i4tS_Pvi4i4i4S_pi4i4_i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTilesBlockNonAlloc(UnityEngine.BoundsInt, UnityEngine.Tilemaps.TileBase[])bool w_i4tS_S_i4i4i4_S_i4i4i4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_i4i4i4_S_i4i4i4__o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_i4i4i4_S_i4i4i4__ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToLowerInvariant(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char])bool w_i4tS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetChars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char])bool w_i4tS_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetChars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char], Boolean)bool w_i4tS_S_p_i4_S_S_p_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_S_S_p_i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetCharCount(System.ReadOnlySpan`1[System.Byte], Boolean)bool w_i4tS_S_p_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.StringComparison)bool w_i4tS_S_p_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Receive(System.Span`1[System.Byte], System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef)bool w_i4tS_S_p_i4_i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ToLower(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], System.Globalization.CultureInfo)bool w_i4tS_S_p_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_p_i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_p_i4_ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEngine.RaycastHit2D)bool w_i4tS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_>(env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetRayIntersection(UnityEngine.Ray, Single, UnityEngine.RaycastHit2D[], Int32)bool w_i4tS_S_r4r4r4_S_r4r4r4__r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_r4r4r4_S_r4r4r4__r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.AI.PathQueryStatus BeginFindPath(UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Experimental.AI.NavMeshLocation, Int32, Unity.Collections.NativeArray`1[System.Single])bool w_i4tS_S_u8_S_r4r4r4__S_S_u8_S_r4r4r4__Di4DS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_u8_S_r4r4r4__S_S_u8_S_r4r4r4__Di4DS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_u8_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(env, _sv1);
    S_S_u8_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_S_u8_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(env, _sv2);
    S_S_u8_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_u8_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_u8_S_r4r4r4__ p1, struct S_S_u8_S_r4r4r4__ p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.DateTimeOffset)bool w_i4tS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_S_u8_i2_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple)bool w_i4tS__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S__ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCollider(UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4tS_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv1);
    S_bbbbbbS_i4_r4r4r4r4_ p1 = pp1 ? *pp1 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,struct S_bbbbbbS_i4_r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 get_Item(Section)bool w_i4tS_i2i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i2i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i2i2_* pp1 = DataTransfer::GetPointer<S_i2i2_>(env, _sv1);
    S_i2i2_ p1 = pp1 ? *pp1 : S_i2i2_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i2i2_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.Guid)bool w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetFrameMetaDataCount(System.Guid, Int32)bool w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i2i2u1u1u1u1u1u1u1u1_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Tilemaps.TileFlags GetTileFlags(UnityEngine.Vector3Int)bool w_i4tS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTilesRangeCount(UnityEngine.Vector3Int, UnityEngine.Vector3Int)bool w_i4tS_i4i4i4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4_S_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTilesRangeNonAlloc(UnityEngine.Vector3Int, UnityEngine.Vector3Int, UnityEngine.Vector3Int[], UnityEngine.Tilemaps.TileBase[])bool w_i4tS_i4i4i4_S_i4i4i4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4_S_i4i4i4_oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.Decimal)bool w_i4tS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.Numerics.BigInteger)bool w_i4tS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i4o_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.TimeSpan)bool w_i4tS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`1[T1])bool w_i4tS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_o_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`2[T1,T2])bool w_i4tS_oo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_oo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oo_* pp1 = DataTransfer::GetPointer<S_oo_>(env, _sv1);
    S_oo_ p1 = pp1 ? *pp1 : S_oo_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_oo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`3[T1,T2,T3])bool w_i4tS_ooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_ooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooo_* pp1 = DataTransfer::GetPointer<S_ooo_>(env, _sv1);
    S_ooo_ p1 = pp1 ? *pp1 : S_ooo_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_ooo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`4[T1,T2,T3,T4])bool w_i4tS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_oooo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`5[T1,T2,T3,T4,T5])bool w_i4tS_ooooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_ooooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooooo_* pp1 = DataTransfer::GetPointer<S_ooooo_>(env, _sv1);
    S_ooooo_ p1 = pp1 ? *pp1 : S_ooooo_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_ooooo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`6[T1,T2,T3,T4,T5,T6])bool w_i4tS_oooooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_oooooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooooo_* pp1 = DataTransfer::GetPointer<S_oooooo_>(env, _sv1);
    S_oooooo_ p1 = pp1 ? *pp1 : S_oooooo_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_oooooo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`8[T1,T2,T3,T4,T5,T6,T7,TRest])bool w_i4tS_oooooooS___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_oooooooS___");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooooooS___* pp1 = DataTransfer::GetPointer<S_oooooooS___>(env, _sv1);
    S_oooooooS___ p1 = pp1 ? *pp1 : S_oooooooS___ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_oooooooS___ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.ValueTuple`7[T1,T2,T3,T4,T5,T6,T7])bool w_i4tS_ooooooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_ooooooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_ooooooo_* pp1 = DataTransfer::GetPointer<S_ooooooo_>(env, _sv1);
    S_ooooooo_ p1 = pp1 ? *pp1 : S_ooooooo_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_ooooooo_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddSource(UnityEngine.Animations.ConstraintSource)bool w_i4tS_or4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_or4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_or4_* pp1 = DataTransfer::GetPointer<S_or4_>(env, _sv1);
    S_or4_ p1 = pp1 ? *pp1 : S_or4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_or4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTokenFor(System.RuntimeFieldHandle)bool w_i4tS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTokenFor(System.RuntimeMethodHandle, System.RuntimeTypeHandle)bool w_i4tS_p_S_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_p_S_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
     // LuaValToCSVal struct
    S_p_* pp2 = DataTransfer::GetPointer<S_p_>(env, _sv2);
    S_p_ p2 = pp2 ? *pp2 : S_p_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_p_ p1, struct S_p_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Rendering.RendererListStatus QueryRendererListStatus(UnityEngine.Rendering.RendererList)bool w_i4tS_pu4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_pu4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pu4u4u4_* pp1 = DataTransfer::GetPointer<S_pu4u4u4_>(env, _sv1);
    S_pu4u4u4_ p1 = pp1 ? *pp1 : S_pu4u4u4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_pu4u4u4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetKeyframeIndex(UnityEditorInternal.AnimationKeyTime)bool w_i4tS_r4i4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4i4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4i4r4_* pp1 = DataTransfer::GetPointer<S_r4i4r4_>(env, _sv1);
    S_r4i4r4_ p1 = pp1 ? *pp1 : S_r4i4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4i4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetInsertionIndex(UnityEngine.Vector2)bool w_i4tS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPoint(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single)bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single, Boolean)bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_oDr4Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single)bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[], Single, Boolean)bool w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_bbbbbbS_i4_r4r4r4r4_or4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, Il2CppObject* p3, float p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddBox(UnityEngine.Vector2, UnityEngine.Vector2, Single, Single)bool w_i4tS_r4r4_S_r4r4_Dr4Dr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_Dr4Dr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4tS_r4r4_S_r4r4_i4r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv7);
    S_bbbbbbS_i4_r4r4r4r4_ p7 = pp7 ? *pp7 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, struct S_bbbbbbS_i4_r4r4r4r4_ p7, Il2CppObject* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32)bool w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4S_r4r4_r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, Il2CppObject* p7, void* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsule(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Collider2D[], Int32)bool w_i4tS_r4r4_S_r4r4_i4r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_i4r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, Il2CppObject* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Int32)bool w_i4tS_r4r4_S_r4r4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddCapsule(UnityEngine.Vector2, UnityEngine.Vector2, Single)bool w_i4tS_r4r4_S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32)bool w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4S_r4r4_r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, Il2CppObject* p6, void* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32)bool w_i4tS_r4r4_S_r4r4_r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_S_r4r4_r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, Il2CppObject* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[])bool w_i4tS_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapPoint(UnityEngine.Vector2, UnityEngine.Collider2D[], Int32)bool w_i4tS_r4r4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, System.Collections.Generic.List`1[UnityEngine.RaycastHit2D], Single)bool w_i4tS_r4r4_oDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_oDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single)bool w_i4tS_r4r4_or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Cast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Boolean)bool w_i4tS_r4r4_or4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, float p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32)bool w_i4tS_r4r4_or4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, float p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single)bool w_i4tS_r4r4_or4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4i4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, float p3, int32_t p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector2, UnityEngine.RaycastHit2D[], Single, Int32, Single, Single)bool w_i4tS_r4r4_or4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_or4i4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, float p3, int32_t p4, float p5, float p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddCircle(UnityEngine.Vector2, Single)bool w_i4tS_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircle(UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.Collider2D[])bool w_i4tS_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D, UnityEngine.RaycastHit2D[])bool w_i4tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.RaycastHit2D[], Int32)bool w_i4tS_r4r4_r4S_r4r4_r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4S_r4r4_r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, Il2CppObject* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCircle(UnityEngine.Vector2, Single, UnityEngine.Collider2D[], Int32)bool w_i4tS_r4r4_r4oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_r4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, Il2CppObject* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.CollisionFlags Move(UnityEngine.Vector3)bool w_i4tS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[])bool w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Dr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Dr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, Il2CppObject* p4, struct S_r4r4r4r4_ p5, void* p6, void* p7, void* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[])bool w_i4tS_r4r4r4_S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_S_r4r4r4_oDr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_oDr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, void* p4, void* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_oS_r4r4r4r4_Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, void* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_S_r4r4r4_r4S_r4r4r4_oDr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_r4S_r4r4r4_oDr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, void* p6, void* p7, void* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapCapsule(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_S_r4r4r4_r4oDi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_S_r4r4r4_r4oDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, void* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_r4S_r4r4r4_oDr4Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_r4S_r4r4r4_oDr4Di4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, void* p5, void* p6, void* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 OverlapSphere(UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction)bool w_i4tS_r4r4r4_r4oi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4_r4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// TimeRulerDragMode BrowseRuler(UnityEngine.Rect, Single ByRef, Single, Boolean, UnityEngine.GUIStyle)bool w_i4tS_r4r4r4r4_Pr4r4bo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_Pr4r4bo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, void* p2, float p3, bool p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// TimeRulerDragMode BrowseRuler(UnityEngine.Rect, Int32, Single ByRef, Single, Boolean, UnityEngine.GUIStyle)bool w_i4tS_r4r4r4r4_i4Pr4r4bo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_i4Pr4r4bo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, int32_t p2, void* p3, float p4, bool p5, Il2CppObject* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetCursorStringIndex(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector2)bool w_i4tS_r4r4r4r4_oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_oS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IntegerProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String)bool w_i4tS_r4r4r4r4_os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4_os");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddKey(UnityEngine.Keyframe)bool w_i4tS_r4r4r4r4i4i4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4r4r4i4i4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4i4i4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4i4r4r4_>(env, _sv1);
    S_r4r4r4r4i4i4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4i4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4r4r4i4i4r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.Build.NamedBuildTarget)bool w_i4tS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_s_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.Search.SearchResult)bool w_i4tS_si4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_si4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(UnityEditor.Search.StringView, System.StringComparison)bool w_i4tS_si4i4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4i4_Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_si4i4_ p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Add(EmployeestructReflect, EmployeestructReflect)bool w_i4tS_si4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4i4i4_* pp1 = DataTransfer::GetPointer<S_si4i4i4_>(env, _sv1);
    S_si4i4i4_ p1 = pp1 ? *pp1 : S_si4i4i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_si4i4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.Search.SearchDocument)bool w_i4tS_si4ssi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_si4ssi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4ssi4_* pp1 = DataTransfer::GetPointer<S_si4ssi4_>(env, _sv1);
    S_si4ssi4_ p1 = pp1 ? *pp1 : S_si4ssi4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_si4ssi4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.Search.SearchProposition)bool w_i4tS_sssi4i4osS_r4r4r4r4_oO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_sssi4i4osS_r4r4r4r4_oO_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sssi4i4osS_r4r4r4r4_oO_* pp1 = DataTransfer::GetPointer<S_sssi4i4osS_r4r4r4r4_oO_>(env, _sv1);
    S_sssi4i4osS_r4r4r4r4_oO_ p1 = pp1 ? *pp1 : S_sssi4i4osS_r4r4r4r4_oO_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_sssi4i4osS_r4r4r4r4_oO_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.ManagedReferenceMissingType)bool w_i4tS_sssi8s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_sssi8s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sssi8s_* pp1 = DataTransfer::GetPointer<S_sssi8s_>(env, _sv1);
    S_sssi8s_ p1 = pp1 ? *pp1 : S_sssi8s_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_sssi8s_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEngine.GraphicsBufferHandle)bool w_i4tS_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetInt(UnityEngine.Animations.AnimationStream)bool w_i4tS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4pppppp_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u4pppppp_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEngine.RefreshRate)bool w_i4tS_u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u4u4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.GUID)bool w_i4tS_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4u4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u4u4u4u4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEditor.Search.PropertyDatabaseRecordKey)bool w_i4tS_u8S_u8u8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8S_u8u8__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8S_u8u8__* pp1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, _sv1);
    S_u8S_u8u8__ p1 = pp1 ? *pp1 : S_u8S_u8u8__ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u8S_u8u8__ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(System.DateTime)bool w_i4tS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.AI.PathQueryStatus GetEdgesAndNeighbors(UnityEngine.Experimental.AI.PolygonId, Unity.Collections.NativeSlice`1[UnityEngine.Vector3], Unity.Collections.NativeSlice`1[UnityEngine.Experimental.AI.PolygonId], Unity.Collections.NativeSlice`1[System.Byte], Int32 ByRef, Int32 ByRef)bool w_i4tS_u8_S_Pu1i4i4i4i4S_pi4i4__S_Pu1i4i4i4i4S_pi4i4__S_Pu1i4i4i4i4S_pi4i4__Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_S_Pu1i4i4i4i4S_pi4i4__S_Pu1i4i4i4i4S_pi4i4__S_Pu1i4i4i4i4S_pi4i4__Pi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp2 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv2);
    S_Pu1i4i4i4i4S_pi4i4__ p2 = pp2 ? *pp2 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp3 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv3);
    S_Pu1i4i4i4i4S_pi4i4__ p3 = pp3 ? *pp3 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp4 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv4);
    S_Pu1i4i4i4i4S_pi4i4__ p4 = pp4 ? *pp4 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p1, struct S_Pu1i4i4i4i4S_pi4i4__ p2, struct S_Pu1i4i4i4i4S_pi4i4__ p3, struct S_Pu1i4i4i4i4S_pi4i4__ p4, void* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetWeekOfYear(System.DateTime, System.Globalization.CalendarWeekRule, System.DayOfWeek)bool w_i4tS_u8_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(UnityEngine.Hash128)bool w_i4tS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u8u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 VariableParamFunc(HasConstructStruct[])bool w_i4tVS_i4i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tVS_i4i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(Boolean)bool w_i4tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FilterCount(Boolean, States[])bool w_i4tbVi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tbVi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,bool p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 QueryIndices(Boolean, Int32, Int32[], Int32)bool w_i4tbi4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tbi4oi4");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,bool p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 QueryIndices(Boolean, Int32[], Int32)bool w_i4tboi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tboi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,bool p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(Char)bool w_i4tc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(Char, System.StringComparison)bool w_i4tcDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tcDi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(Char, Int32)bool w_i4tci4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tci4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOf(Char, Int32, Int32)bool w_i4tci4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tci4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(SByte)bool w_i4ti1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,int8_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(Int16)bool w_i4ti2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,int16_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetHashCode(System.StringComparison)bool w_i4ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 VariableParamFuncDefault(Int32, Int32, System.String[])bool w_i4ti4Di4Vs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Di4Vs");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 MoveKey(Int32, UnityEngine.Keyframe ByRef)bool w_i4ti4PS_r4r4r4r4i4i4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4PS_r4r4r4r4i4i4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4i4i4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4i4i4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4i4i4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// UnityEngine.Experimental.AI.PathQueryStatus UpdateFindPath(Int32, Int32 ByRef)bool w_i4ti4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Pi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TestOut(Int32, Double ByRef, System.String ByRef)bool w_i4ti4Pr8Ps(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Pr8Ps");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TestOut(Int32, Double ByRef, System.String ByRef, UnityEngine.GameObject)bool w_i4ti4Pr8Pso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Pr8Pso");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, void* p2, void* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 MoveKey(Int32, UnityEngine.Keyframe)bool w_i4ti4S_r4r4r4r4i4i4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4S_r4r4r4r4i4i4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4i4i4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4i4i4r4r4_>(env, _sv2);
    S_r4r4r4r4i4i4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4i4i4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4i4i4r4r4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FindAssignedEditPositionFrom(Int32, Boolean)bool w_i4ti4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Next(Int32, Int32)bool w_i4ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(Int32, Int32, System.Object, System.Collections.IComparer)bool w_i4ti4i4Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4Oo");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FindAssignedEditPositionInRange(Int32, Int32, Boolean)bool w_i4ti4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetDaysInMonth(Int32, Int32, Int32)bool w_i4ti4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FindIndex(Int32, Int32, System.Predicate`1[T])bool w_i4ti4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4o");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(Int32, Int32, T, System.Collections.Generic.IComparer`1[T])bool w_i4ti4i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4oo");
    
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 FindIndex(Int32, System.Predicate`1[T])bool w_i4ti4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTriggerParticles(UnityEngine.ParticleSystem, UnityEngine.ParticleSystemTriggerEventType, System.Collections.Generic.List`1[UnityEngine.ParticleSystem+Particle], ColliderData ByRef)bool w_i4ti4oPS_ooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oPS_ooo_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_ooo_* p3 = DataTransfer::GetPointer<S_ooo_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_ooo_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 QueryIndices(Int32, Int32[], Int32)bool w_i4ti4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oi4");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IOControl(Int32, Byte[], Byte[])bool w_i4ti4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(Int64)bool w_i4ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,int64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IOControl(System.Net.Sockets.IOControlCode, Byte[], Byte[])bool w_i4ti8oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti8oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void*,int64_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOfAny(Char[])bool w_i4to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4to");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddEdges(System.Collections.Generic.List`1[UnityEngine.Vector2], Single)bool w_i4toDr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toDr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 EndReceive(System.IAsyncResult, System.Net.Sockets.SocketError ByRef)bool w_i4toPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 EndReceiveMessageFrom(System.IAsyncResult, System.Net.Sockets.SocketFlags ByRef, System.Net.EndPoint ByRef, System.Net.Sockets.IPPacketInformation ByRef)bool w_i4toPi4PoPS_oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPi4PoPS_oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
     // LuaValToCSVal Pstruct
    S_oi4_* p4 = DataTransfer::GetPointer<S_oi4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_oi4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, void* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReceiveFrom(Byte[], System.Net.EndPoint ByRef)bool w_i4toPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_i4toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toS_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExecuteAssemblyByName(System.Reflection.AssemblyName, System.String[])bool w_i4toVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toVs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddEdges(System.Collections.Generic.List`1[UnityEngine.Vector2], Boolean, Boolean, UnityEngine.Vector2, UnityEngine.Vector2, Single)bool w_i4tobbS_r4r4_S_r4r4_Dr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tobbS_r4r4_S_r4r4_Dr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, bool p2, bool p3, struct S_r4r4_ p4, struct S_r4r4_ p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Wait(IntPtr[], Boolean, Int32)bool w_i4tobi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tobi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, bool p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetNumRowsOnPageUpDown(UnityEditor.IMGUI.Controls.TreeViewItem, Boolean, Single)bool w_i4tobr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tobr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, bool p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOfAny(Char[], Int32)bool w_i4toi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetShapes(UnityEngine.PhysicsShapeGroup2D, Int32, Int32)bool w_i4toi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Receive(System.Collections.Generic.IList`1[System.ArraySegment`1[System.Byte]], System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef)bool w_i4toi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReceiveFrom(Byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint ByRef)bool w_i4toi4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 IndexOfAny(Char[], Int32, Int32)bool w_i4toi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReceiveMessageFrom(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags ByRef, System.Net.EndPoint ByRef, System.Net.Sockets.IPPacketInformation ByRef)bool w_i4toi4i4Pi4PoPS_oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4Pi4PoPS_oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv5)); // object ret
    Il2CppObject** p5 = &up5;
        
     // LuaValToCSVal Pstruct
    S_oi4_* p6 = DataTransfer::GetPointer<S_oi4_>(env, pesapi_unboxing(env, _sv6)); // valuetype ref
    S_oi4_ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(p6));
    }
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, void* p4, void* p5, void* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReceiveFrom(Byte[], Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint ByRef)bool w_i4toi4i4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetCharCount(Byte[], Int32, Int32, Boolean)bool w_i4toi4i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Send(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags)bool w_i4toi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Receive(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.Sockets.SocketError ByRef)bool w_i4toi4i4i4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReceiveFrom(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint ByRef)bool w_i4toi4i4i4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv5)); // object ret
    Il2CppObject** p5 = &up5;
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SendTo(Byte[], Int32, Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)bool w_i4toi4i4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SendTo(Byte[], Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)bool w_i4toi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetBytes(Char[], Int32, Int32, Byte[], Int32)bool w_i4toi4i4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetChars(Byte[], Int32, Int32, Char[], Int32, Boolean)bool w_i4toi4i4oi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4oi4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 SendTo(Byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint)bool w_i4toi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Send(Byte[], Int32, System.String, Int32)bool w_i4toi4si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4si4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, Il2CppString* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 BinarySearch(T, System.Collections.Generic.IComparer`1[T])bool w_i4too(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4too");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ExecuteAssemblyByName(System.Reflection.AssemblyName, System.Security.Policy.Evidence, System.String[])bool w_i4tooVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tooVs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 ReadArray(System.Xml.XmlDictionaryString, System.Xml.XmlDictionaryString, Boolean[], Int32, Int32)bool w_i4toooi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toooi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetJointExternalForces(System.Collections.Generic.List`1[System.Single], Single)bool w_i4tor4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tor4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetSprites(UnityEngine.Sprite[], System.String)bool w_i4tos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tos");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 RegisterDecimalFormat(System.Xml.XmlQualifiedName, System.String, System.String, System.String)bool w_i4tosss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tosss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddInstance(UnityEngine.GraphicsBuffer, UInt32, Boolean, UnityEngine.Matrix4x4, UnityEngine.Material, Boolean, UnityEngine.MaterialPropertyBlock, UInt32, UInt32)bool w_i4tou4bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oboDu4Du4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tou4bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oboDu4Du4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];
    auto TIp9 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
 // LuaValToCSVal P any
    void* p9 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, bool p3, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4, Il2CppObject* p5, bool p6, Il2CppObject* p7, void* p8, void* p9, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 Call(IntPtr)bool w_i4tp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tp");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 GetTypeId(IntPtr, System.Type)bool w_i4tpo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tpo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef int32_t (*FuncToCall)(void*,void* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 getTypeId(IntPtr, System.Type, Boolean ByRef, LOGLEVEL)bool w_i4tpoPbDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tpoPbDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, Il2CppObject* p2, void* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 TranslateToEnumToTop(IntPtr, System.Type, Int32)bool w_i4tpoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tpoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef int32_t (*FuncToCall)(void*,void* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(Single)bool w_i4tr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 AddKey(Single, Single)bool w_i4tr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef int32_t (*FuncToCall)(void*,float p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Int32 CompareTo(Double)bool w_i4tr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tr8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef int32_t (*FuncToCall)(void*,double p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
// Microsoft.Win32.RegistryValueKind GetValueKind(System.String)bool w_i4ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ts");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<int32_t>::toScript(env, ret));        return true;
}
}

