// Auto Gen
    
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// UnityEngine.Quaternion Disc(Int32, UnityEngine.Quaternion, UnityEngine.Vector3, UnityEngine.Vector3, Single, Boolean, Single)bool w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, bool p6, float p7, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion FreeRotateHandle(Int32, UnityEngine.Quaternion, UnityEngine.Vector3, Single)bool w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture)bool w_S_r4r4r4r4_i4S_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_i4S_r4r4r4r4_ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_ooVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, void* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_i4S_r4r4r4r4_ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, UnityEngine.Texture, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_i4S_r4r4r4r4_oooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_oooVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, void* p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String)bool w_S_r4r4r4r4_i4S_r4r4r4r4_os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_os");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_i4S_r4r4r4r4_osVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_osVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppString* p4, void* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_i4S_r4r4r4r4_oso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_oso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppString* p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Window(Int32, UnityEngine.Rect, WindowFunction, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_i4S_r4r4r4r4_osoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4S_r4r4r4r4_osoVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppString* p4, Il2CppObject* p5, void* p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 GetInnerUV(UnityEngine.Sprite)bool w_S_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect FindCullAndClipWorldRect(System.Collections.Generic.List`1[UnityEngine.UI.RectMask2D], Boolean ByRef)bool w_S_r4r4r4r4_oPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oPb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect CameraTransformWorldToPanelRect(UnityEngine.UIElements.IPanel, UnityEngine.Vector3, UnityEngine.Vector2, UnityEngine.Camera)bool w_S_r4r4r4r4_oS_r4r4r4_S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4_ p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 Vector4Field(UnityEngine.GUIContent, UnityEngine.Vector4, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_oS_r4r4r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorField(UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_oS_r4r4r4r4_bbbVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4r4_bbbVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, bool p5, void* p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorField(UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean, UnityEditor.ColorPickerHDRConfig, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_oS_r4r4r4r4_bbboVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oS_r4r4r4r4_bbboVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, bool p3, bool p4, bool p5, Il2CppObject* p6, void* p7, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect BeginHorizontal(UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 GetSpriteOuterUV(UnityEngine.Sprite, Boolean)bool w_S_r4r4r4r4_ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(UnityEngine.GUIContent, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ooVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color CorrelatedColorTemperatureToRGB(Single)bool w_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion AngleAxis(Single, UnityEngine.Vector3)bool w_S_r4r4r4r4_r4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color op_Multiply(Single, UnityEngine.Color)bool w_S_r4r4r4r4_r4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion GetQuatSquad(Single, UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion)bool w_S_r4r4r4r4_r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, struct S_r4r4r4r4_ p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetAspectRect(Single, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, void* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetAspectRect(Single, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetAspectRect(Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_r4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, Il2CppObject* p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorHSV(Single, Single)bool w_S_r4r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(Single, Single, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(Single, Single, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_r4r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(Single, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_r4r4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color HSVToRGB(Single, Single, Single)bool w_S_r4r4r4r4_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color HSVToRGB(Single, Single, Single, Boolean)bool w_S_r4r4r4r4_r4r4r4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, bool p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect MinMaxRect(Single, Single, Single, Single)bool w_S_r4r4r4r4_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(Single, Single, Single, Single, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_r4r4r4r4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, void* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(Single, Single, Single, Single, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_r4r4r4r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRect(Single, Single, Single, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_r4r4r4r4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, Il2CppObject* p5, void* p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorHSV(Single, Single, Single, Single, Single, Single)bool w_S_r4r4r4r4_r4r4r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, float p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorHSV(Single, Single, Single, Single, Single, Single, Single, Single)bool w_S_r4r4r4r4_r4r4r4r4r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion GetTrackerRotation(System.String)bool w_S_r4r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 Vector4Field(System.String, UnityEngine.Vector4, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_sS_r4r4r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_sS_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion get_rotation()bool w_S_r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetColor(UnityEngine.Vector3Int)bool w_S_r4r4r4r4_tS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Add(UnityEngine.Rect)bool w_S_r4r4r4r4_tS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect ComputeAxisAlignedBound(UnityEngine.Rect, UnityEngine.Matrix4x4)bool w_S_r4r4r4r4_tS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect FitWindowRectToScreen(UnityEngine.Rect, Boolean, Boolean)bool w_S_r4r4r4r4_tS_r4r4r4r4_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_bb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, bool p2, bool p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRenameRect(UnityEngine.Rect, Int32, UnityEditor.IMGUI.Controls.TreeViewItem)bool w_S_r4r4r4r4_tS_r4r4r4r4_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_i4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 VectorProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, UnityEngine.GUIContent)bool w_S_r4r4r4r4_tS_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorProperty(UnityEngine.Rect, UnityEditor.MaterialProperty, System.String)bool w_S_r4r4r4r4_tS_r4r4r4r4_os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_os");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion GetRotation(UnityEngine.Animations.AnimationStream)bool w_S_r4r4r4r4_tS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_u4pppppp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_u4pppppp_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion GetIKRotation(UnityEngine.AvatarIKGoal)bool w_S_r4r4r4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetCellRect(Int32, UnityEngine.Rect)bool w_S_r4r4r4r4_ti4S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixel(Int32, Int32)bool w_S_r4r4r4r4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixel(Int32, Int32, Int32)bool w_S_r4r4r4r4_ti4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixel(UnityEngine.CubemapFace, Int32, Int32, Int32)bool w_S_r4r4r4r4_ti4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetRowRect(Int32, Single)bool w_S_r4r4r4r4_ti4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetScreenRect(UnityEngine.Camera)bool w_S_r4r4r4r4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_S_r4r4r4r4_toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toS_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect ChangeCoordinatesTo(UnityEngine.UIElements.VisualElement, UnityEngine.UIElements.VisualElement, UnityEngine.Rect)bool w_S_r4r4r4r4_toS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 VectorProperty(UnityEditor.MaterialProperty, UnityEngine.GUIContent)bool w_S_r4r4r4r4_too(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_too");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect TexturePropertySingleLine(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty)bool w_S_r4r4r4r4_tooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect TexturePropertyWithHDRColor(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, Boolean)bool w_S_r4r4r4r4_tooob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tooob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect TexturePropertySingleLine(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty)bool w_S_r4r4r4r4_toooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect TexturePropertyWithHDRColor(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, UnityEditor.ColorPickerHDRConfig, Boolean)bool w_S_r4r4r4r4_toooob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_toooob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect TexturePropertyTwoLines(UnityEngine.GUIContent, UnityEditor.MaterialProperty, UnityEditor.MaterialProperty, UnityEngine.GUIContent, UnityEditor.MaterialProperty)bool w_S_r4r4r4r4_tooooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tooooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorProperty(UnityEditor.MaterialProperty, System.String)bool w_S_r4r4r4r4_tos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color Evaluate(Single)bool w_S_r4r4r4r4_tr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixelBilinear(Single, Single)bool w_S_r4r4r4r4_tr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixelBilinear(Single, Single, Int32)bool w_S_r4r4r4r4_tr4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p1, float p2, int32_t p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixelBilinear(Single, Single, Single)bool w_S_r4r4r4r4_tr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p1, float p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetPixelBilinear(Single, Single, Single, Int32)bool w_S_r4r4r4r4_tr4r4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tr4r4r4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,float p1, float p2, float p3, int32_t p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion GetQuaternion(System.String)bool w_S_r4r4r4r4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color GetColor(System.String, Boolean ByRef)bool w_S_r4r4r4r4_tsPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tsPb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorProperty(System.String, System.String)bool w_S_r4r4r4r4_tss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Keyframe ToKeyframe()bool w_S_r4r4r4r4i4i4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4i4i4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4i4i4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4i4i4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Keyframe get_Item(Int32)bool w_S_r4r4r4r4i4i4r4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4i4i4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4i4i4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4r4i4i4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextCore.GlyphMetrics get_metrics()bool w_S_r4r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 get_Identity()bool w_S_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 CreateTranslation(System.Numerics.Vector2)bool w_S_r4r4r4r4r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 CreateScale(System.Numerics.Vector2, System.Numerics.Vector2)bool w_S_r4r4r4r4r4r4_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 Negate(System.Numerics.Matrix3x2)bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 Add(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2)bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 Lerp(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2, Single)bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 Multiply(System.Numerics.Matrix3x2, Single)bool w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_S_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 CreateScale(Single)bool w_S_r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p1, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 CreateScale(Single, System.Numerics.Vector2)bool w_S_r4r4r4r4r4r4_r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 CreateTranslation(Single, Single)bool w_S_r4r4r4r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix3x2 CreateScale(Single, Single, System.Numerics.Vector2)bool w_S_r4r4r4r4r4r4_r4r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_r4r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(float p1, float p2, struct S_r4r4_ p3, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.FrustumPlanes get_decomposeProjection()bool w_S_r4r4r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.JointLimits get_limits()bool w_S_r4r4r4r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ArticulationDrive get_xDrive()bool w_S_r4r4r4r4r4r4r4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 get_matrix()bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateReflection(System.Numerics.Plane)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 Scale(UnityEngine.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateShadow(System.Numerics.Vector3, System.Numerics.Plane)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv2);
    S_S_r4r4r4_r4_ p2 = pp2 ? *pp2 : S_S_r4r4r4_r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_S_r4r4r4_r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateScale(System.Numerics.Vector3, System.Numerics.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 LookAt(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateBillboard(System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateConstrainedBillboard(System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 TRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateFromAxisAngle(System.Numerics.Vector3, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 Rotate(UnityEngine.Quaternion)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 Frustum(UnityEngine.FrustumPlanes)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 Inverse(UnityEngine.Matrix4x4)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 Transform(System.Numerics.Matrix4x4, System.Numerics.Quaternion)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 Lerp(System.Numerics.Matrix4x4, System.Numerics.Matrix4x4, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetGPUProjectionMatrix(UnityEngine.Matrix4x4, Boolean)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, bool p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 Multiply(System.Numerics.Matrix4x4, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetGlobalMatrix(Int32)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateScale(Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateScale(Single, System.Numerics.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateTranslation(Single, Single, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Matrix4x4 CreateScale(Single, Single, Single, System.Numerics.Vector3)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, struct S_r4r4r4_ p4, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 Perspective(Single, Single, Single, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 Ortho(Single, Single, Single, Single, Single, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, float p6, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetGlobalMatrix(System.String)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 get_transform()bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetTransformMatrix(UnityEngine.Vector3Int)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 CalculateObliqueMatrix(UnityEngine.Vector4)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetLocalToParentMatrix(UnityEngine.Animations.AnimationStream)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u4pppppp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_u4pppppp_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 PolygonLocalToWorldMatrix(UnityEngine.Experimental.AI.PolygonId)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetLocalMatrixAtTime(Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,float p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Matrix4x4 GetMatrix(System.String)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SphericalHarmonicsL2 get_ambientProbe()bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SphericalHarmonicsL2 op_Addition(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Rendering.SphericalHarmonicsL2)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SphericalHarmonicsL2 op_Multiply(UnityEngine.Rendering.SphericalHarmonicsL2, Single)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SphericalHarmonicsL2 op_Multiply(Single, UnityEngine.Rendering.SphericalHarmonicsL2)bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.LocationInfo get_lastData()bool w_S_r8r4r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r8r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r8r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Explicit(System.Decimal)bool w_S_r8r8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef struct S_r8r8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Explicit(System.Numerics.BigInteger)bool w_S_r8r8_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef struct S_r8r8_ (*FuncToCall)(struct S_i4o_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex Negate(System.Numerics.Complex)bool w_S_r8r8_S_r8r8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
        
    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex Add(System.Numerics.Complex, System.Numerics.Complex)bool w_S_r8r8_S_r8r8_S_r8r8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_S_r8r8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
        
     // LuaValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};
        
    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p1, struct S_r8r8_ p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex Log(System.Numerics.Complex, Double)bool w_S_r8r8_S_r8r8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef struct S_r8r8_ (*FuncToCall)(struct S_r8r8_ p1, double p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(SByte)bool w_S_r8r8_i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(int8_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(Int16)bool w_S_r8r8_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(Int32)bool w_S_r8r8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(Int64)bool w_S_r8r8_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(Single)bool w_S_r8r8_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(float p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(Double)bool w_S_r8r8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(double p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex FromPolarCoordinates(Double, Double)bool w_S_r8r8_r8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_r8r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef struct S_r8r8_ (*FuncToCall)(double p1, double p2, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(Byte)bool w_S_r8r8_u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(uint8_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(UInt16)bool w_S_r8r8_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(UInt32)bool w_S_r8r8_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Complex op_Implicit(UInt64)bool w_S_r8r8_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r8r8_u8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef struct S_r8r8_ (*FuncToCall)(uint64_t p1, const void* method);
    struct S_r8r8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Bee.BeeDriver.ActiveBuildStatus get_Status()bool w_S_sN_bS_i4i4___t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sN_bS_i4i4___t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_sN_bS_i4i4___ (*FuncToCall)(void*,const void* method);
    struct S_sN_bS_i4i4___ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.Serialization.SerializationEntry get_Current()bool w_S_sOo_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sOo_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_sOo_ (*FuncToCall)(void*,const void* method);
    struct S_sOo_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.HashAlgorithmName get_MD5()bool w_S_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_s_ (*FuncToCall)(const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.NamedBuildTarget FromBuildTargetGroup(UnityEditor.BuildTargetGroup)bool w_S_s_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_s_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.InteropServices.OSPlatform Create(System.String)bool w_S_s_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_s_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm()bool w_S_s_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_s_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_s_ (*FuncToCall)(void*,const void* method);
    struct S_s_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.ShaderInfo GetShaderInfo(UnityEngine.Shader)bool w_S_sbbb_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sbbb_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_sbbb_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_sbbb_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.MPE.ChannelClientInfo GetChannelClientInfo(Int32)bool w_S_si4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_si4i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.MPE.ChannelClientInfo GetChannelClientInfo(System.String)bool w_S_si4i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_si4i4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.MPE.ChannelClientInfo GetChannelClientInfo()bool w_S_si4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_si4i4_ (*FuncToCall)(void*,const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.StringView Trim(Char[])bool w_S_si4i4_tVc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_tVc");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_si4i4_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.StringView Substring(Int32)bool w_S_si4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_si4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.StringView Substring(Int32, Int32)bool w_S_si4i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_si4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_si4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextCore.Text.FontAssetCreationEditorSettings get_fontAssetCreationEditorSettings()bool w_S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_si4i4i4i4i4i4i4i4i4sssi4r4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.CngProperty GetProperty(System.String, System.Security.Cryptography.CngPropertyOptions)bool w_S_si4oN_bi4__tsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4oN_bi4__tsi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_si4oN_bi4__ (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    struct S_si4oN_bi4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.SearchDocument GetDocument(Int32)bool w_S_si4ssi4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_si4ssi4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_si4ssi4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_si4ssi4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.SceneDependencyInfo CalculatePlayerDependenciesForScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet)bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oi4i4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv2);
    S_oi4i4i4_ p2 = pp2 ? *pp2 : S_oi4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p1, struct S_oi4i4i4_ p2, Il2CppObject* p3, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.SceneDependencyInfo CalculatePlayerDependenciesForScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache)bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oi4i4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv2);
    S_oi4i4i4_ p2 = pp2 ? *pp2 : S_oi4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p1, struct S_oi4i4i4_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.SceneDependencyInfo CalculatePlayerDependenciesForScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache, UnityEditor.Build.Content.DependencyType)bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_ooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_ooi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oi4i4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv2);
    S_oi4i4i4_ p2 = pp2 ? *pp2 : S_oi4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p1, struct S_oi4i4i4_ p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.SceneDependencyInfo PrepareScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache, System.String)bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_oos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_oos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oi4i4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv2);
    S_oi4i4i4_ p2 = pp2 ? *pp2 : S_oi4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p1, struct S_oi4i4i4_ p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppString* p5, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.SceneDependencyInfo PrepareScene(System.String, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagSet, System.String)bool w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooS_u4u4u4u4u4bbbbbbb__sS_oi4i4i4_os");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oi4i4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv2);
    S_oi4i4i4_ p2 = pp2 ? *pp2 : S_oi4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef struct S_sooS_u4u4u4u4u4bbbbbbb__ (*FuncToCall)(Il2CppString* p1, struct S_oi4i4i4_ p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    struct S_sooS_u4u4u4u4u4bbbbbbb__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.PlayableBinding Create(System.String, UnityEngine.Object)bool w_S_sooo_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooo_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_sooo_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_sooo_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.PlayableBinding Create(System.String, UnityEngine.Object, System.Type)bool w_S_sooo_soo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sooo_soo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_sooo_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_sooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.EditorCurveBinding RemapAnimationBindingForRotationCurves(UnityEditor.EditorCurveBinding, UnityEngine.AnimationClip)bool w_S_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, Il2CppObject* p2, const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.EditorCurveBinding GetRenamedBinding(UnityEditor.EditorCurveBinding, System.String)bool w_S_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, Il2CppString* p2, const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.EditorCurveBinding SerializeReferenceCurve(System.String, System.Type, Int64, System.String, Boolean, Boolean)bool w_S_sosi4i4i4i4i4i4i4_soi8sbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_soi8sbb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int64_t p3, Il2CppString* p4, bool p5, bool p6, const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.EditorCurveBinding FloatCurve(System.String, System.Type, System.String)bool w_S_sosi4i4i4i4i4i4i4_sos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_sos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.EditorCurveBinding get_binding()bool w_S_sosi4i4i4i4i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_sosi4i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_sosi4i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_sosi4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Installation get_CurrentInstallation()bool w_S_ss_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ss_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ss_ (*FuncToCall)(void*,const void* method);
    struct S_ss_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Installation GetInstallationForPath(System.String)bool w_S_ss_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ss_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_ss_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_ss_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Hardware.DevDevice get_none()bool w_S_ssssi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ssssi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ssssi4i4_ (*FuncToCall)(const void* method);
    struct S_ssssi4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// MethodInfo ResolveMethodInfo(UInt64)bool w_S_ssu4_tu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ssu4_tu8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef struct S_ssu4_ (*FuncToCall)(void*,uint64_t p1, const void* method);
    struct S_ssu4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.XR.InputFeatureUsage op_Explicit(UnityEngine.XR.InputFeatureUsage`1[T])bool w_S_su4_S_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_su4_S_s_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef struct S_su4_ (*FuncToCall)(struct S_s_ p1, const void* method);
    struct S_su4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GlobalKeyword Create(System.String)bool w_S_su4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_su4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_su4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_su4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.SerializedLocation get_header()bool w_S_su8u8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_su8u8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_su8u8_ (*FuncToCall)(void*,const void* method);
    struct S_su8u8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshBuildDebugSettings get_debug()bool w_S_u1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1_ (*FuncToCall)(void*,const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TableAutoTransSimpleStruct SimpleStructMethod(TableAutoTransSimpleStruct)bool w_S_u1_tS_u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1_tS_u1_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u1_* pp1 = DataTransfer::GetPointer<S_u1_>(env, _sv1);
    S_u1_ p1 = pp1 ? *pp1 : S_u1_ {};
        
    typedef struct S_u1_ (*FuncToCall)(void*,struct S_u1_ p1, const void* method);
    struct S_u1_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.DepthState get_defaultValue()bool w_S_u1i1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i1_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1i1_ (*FuncToCall)(const void* method);
    struct S_u1i1_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.DepthState get_depthState()bool w_S_u1i1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1i1_ (*FuncToCall)(void*,const void* method);
    struct S_u1i1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// NoGenCodeStruct GetStaticVar()bool w_S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__ (*FuncToCall)(const void* method);
    struct S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// NoGenCodeStruct GetStruct()bool w_S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__ (*FuncToCall)(void*,const void* method);
    struct S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// NoGenCodeStruct InitStruct(Int32 ByRef)bool w_S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__tPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__tPi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_u1i2u2i4i4u4i8u8r8r4cS_i4i4i4i4u8_sS_i4i4s__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.SearchValue ConvertPropertyValue(UnityEditor.SerializedProperty ByRef)bool w_S_u1r8sS_r4r4r4r4_S_u1u1u1u1__Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1r8sS_r4r4r4r4_S_u1u1u1u1__Po");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef struct S_u1r8sS_r4r4r4r4_S_u1u1u1u1__ (*FuncToCall)(void* p1, const void* method);
    struct S_u1r8sS_r4r4r4r4_S_u1u1u1u1__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.StandardFormat Parse(System.ReadOnlySpan`1[System.Char])bool w_S_u1u1_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef struct S_u1u1_ (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    struct S_u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.StandardFormat op_Implicit(Char)bool w_S_u1u1_c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1_c");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef struct S_u1u1_ (*FuncToCall)(Il2CppChar p1, const void* method);
    struct S_u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.StandardFormat Parse(System.String)bool w_S_u1u1_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u1u1_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetBlendState get_defaultValue()bool w_S_u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct S_u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetBlendState get_blendState0()bool w_S_u1u1u1u1u1u1u1u1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.StencilState get_defaultValue()bool w_S_u1u1u1u1u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.StencilState get_stencilState()bool w_S_u1u1u1u1u1u1u1u1u1u1u1u1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u1u1u1u1u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Profiling.ProfilerCategoryInfo GetCategoryInfo(UInt16)bool w_S_u2S_i4u1u1u1u1_su2_tu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2S_i4u1u1u1u1_su2_tu2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef struct S_u2S_i4u1u1u1u1_su2_ (*FuncToCall)(void*,uint16_t p1, const void* method);
    struct S_u2S_i4u1u1u1u1_su2_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.ProfilerCategory get_Render()bool w_S_u2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u2_ (*FuncToCall)(const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.ProfilerCategory get_Category()bool w_S_u2_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u2_ (*FuncToCall)(void*,const void* method);
    struct S_u2_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.LowLevel.Unsafe.ProfilerCategoryDescription GetCategoryDescription(UInt16)bool w_S_u2u2S_i4u1u1u1u1_i4i4Pu1_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u2u2S_i4u1u1u1u1_i4i4Pu1_u2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef struct S_u2u2S_i4u1u1u1u1_i4i4Pu1_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_u2u2S_i4u1u1u1u1_i4i4Pu1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord get_firstAdjustmentRecord()bool w_S_u4S_r4r4r4r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_u4S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.Stats.FrameStats GetLastFrameStats()bool w_S_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4_ (*FuncToCall)(const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.GraphicsBufferHandle get_bufferHandle()bool w_S_u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.BatchID AddBatch(Unity.Collections.NativeArray`1[UnityEngine.Rendering.MetadataValue], UnityEngine.GraphicsBufferHandle)bool w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_u4_* pp2 = DataTransfer::GetPointer<S_u4_>(env, _sv2);
    S_u4_ p2 = pp2 ? *pp2 : S_u4_ {};
        
    typedef struct S_u4_ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_u4_ p2, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.BatchID AddBatch(Unity.Collections.NativeArray`1[UnityEngine.Rendering.MetadataValue], UnityEngine.GraphicsBufferHandle, UInt32, UInt32)bool w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_u4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_tS_Pvi4i4i4S_pi4i4_i4_S_u4_u4u4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_u4_* pp2 = DataTransfer::GetPointer<S_u4_>(env, _sv2);
    S_u4_ p2 = pp2 ? *pp2 : S_u4_ {};
        
 // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(env, _sv4);        
        
    typedef struct S_u4_ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_u4_ p2, uint32_t p3, uint32_t p4, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.BatchMaterialID RegisterMaterial(UnityEngine.Material)bool w_S_u4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.GraphicsBufferHandle GetBuffer(System.String)bool w_S_u4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.TransformSceneHandle BindSceneTransform(UnityEngine.Animator, UnityEngine.Transform)bool w_S_u4i4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.PropertySceneHandle BindSceneProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String)bool w_S_u4i4_toos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_toos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.PropertySceneHandle BindSceneProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String, Boolean)bool w_S_u4i4_toosb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_toosb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, bool p4, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.TransformStreamHandle BindStreamTransform(UnityEngine.Animator, UnityEngine.Transform)bool w_S_u4i4i4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u4i4i4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.PropertyStreamHandle BindStreamProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String)bool w_S_u4i4i4i4_toos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_toos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.PropertyStreamHandle BindStreamProperty(UnityEngine.Animator, UnityEngine.Transform, System.Type, System.String, Boolean)bool w_S_u4i4i4i4_toosb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_toosb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, bool p4, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.PropertyStreamHandle BindCustomStreamProperty(UnityEngine.Animator, System.String, UnityEngine.Animations.CustomStreamPropertyType)bool w_S_u4i4i4i4_tsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_tsi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationStream GetInputStream(Int32)bool w_S_u4pppppp_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4pppppp_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u4pppppp_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u4pppppp_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RefreshRate get_refreshRateRatio()bool w_S_u4u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BlendShapeBufferRange GetBlendShapeBufferRange(Int32)bool w_S_u4u4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u4u4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u4u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.VFX.VFXParticleSystemInfo GetParticleSystemInfo(Int32)bool w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.VFX.VFXParticleSystemInfo GetParticleSystemInfo(System.String)bool w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4bS_S_r4r4r4_S_r4r4r4___ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_u4u4bS_S_r4r4r4_S_r4r4r4___ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.GUID Generate()bool w_S_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4u4u4u4_ (*FuncToCall)(const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.GUID GUIDFromAssetPath(System.String)bool w_S_u4u4u4u4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u4u4u4u4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.GUID get_guid()bool w_S_u4u4u4u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4u4u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.NVIDIA.DLSSCommandInitializationData get_initData()bool w_S_u4u4u4u4i4i4u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4i4i4u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4u4u4u4i4i4u4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4i4i4u4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.BuildUsageTagGlobal GetGlobalUsageFromGraphicsSettings()bool w_S_u4u4u4u4u4bbbbbbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.BuildUsageTagGlobal op_BitwiseOr(UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagGlobal)bool w_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_S_u4u4u4u4u4bbbbbbb_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv1);
    S_u4u4u4u4u4bbbbbbb_ p1 = pp1 ? *pp1 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv2);
    S_u4u4u4u4u4bbbbbbb_ p2 = pp2 ? *pp2 : S_u4u4u4u4u4bbbbbbb_ {};
        
    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(struct S_u4u4u4u4u4bbbbbbb_ p1, struct S_u4u4u4u4u4bbbbbbb_ p2, const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.BuildUsageTagGlobal GetGlobalUsageFromActiveScene(UnityEditor.BuildTarget)bool w_S_u4u4u4u4u4bbbbbbb_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.BuildUsageTagGlobal get_globalUsage()bool w_S_u4u4u4u4u4bbbbbbb_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4bbbbbbb_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u4u4u4u4u4bbbbbbb_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u4u4u4bbbbbbb_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(UnityEngine.Hash128)bool w_S_u8S_u8u8__S_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
    typedef struct S_u8S_u8u8__ (*FuncToCall)(struct S_u8u8_ p1, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(System.String)bool w_S_u8S_u8u8__s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u8S_u8u8__ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(System.String, UnityEngine.Hash128)bool w_S_u8S_u8u8__sS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__sS_u8u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_u8u8_* pp2 = DataTransfer::GetPointer<S_u8u8_>(env, _sv2);
    S_u8u8_ p2 = pp2 ? *pp2 : S_u8u8_ {};
        
    typedef struct S_u8S_u8u8__ (*FuncToCall)(Il2CppString* p1, struct S_u8u8_ p2, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(System.String, System.String)bool w_S_u8S_u8u8__ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_u8S_u8u8__ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.PropertyDatabaseRecordKey CreateRecordKey(UInt64, UnityEngine.Hash128)bool w_S_u8S_u8u8__u8S_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8S_u8u8__u8S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_u8u8_* pp2 = DataTransfer::GetPointer<S_u8u8_>(env, _sv2);
    S_u8u8_ p2 = pp2 ? *pp2 : S_u8u8_ {};
        
    typedef struct S_u8S_u8u8__ (*FuncToCall)(uint64_t p1, struct S_u8u8_ p2, const void* method);
    struct S_u8S_u8u8__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime get_Now()bool w_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u8_ (*FuncToCall)(const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.Object)bool w_S_u8_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.Object, System.IFormatProvider)bool w_S_u8_Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_Oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_u8_S_S_p_i4_DoDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_DoDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_u8_S_S_p_i4_S_S_p_i4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_S_S_p_i4_oDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_u8_S_S_p_i4_ooDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_ooDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.Decimal)bool w_S_u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.ProfilerRecorder StartNew(Unity.Profiling.ProfilerMarker, Int32, Unity.Profiling.ProfilerRecorderOptions)bool w_S_u8_S_p_Di4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_p_Di4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_p_ p1, void* p2, void* p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.ProfilerRecorder StartNew(Unity.Profiling.ProfilerCategory, System.String, Int32, Unity.Profiling.ProfilerRecorderOptions)bool w_S_u8_S_u2_sDi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u2_sDi4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u2_ p1, Il2CppString* p2, void* p3, void* p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ConvertTimeToUtc(System.DateTime)bool w_S_u8_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime op_Addition(System.DateTime, System.TimeSpan)bool w_S_u8_S_u8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, struct S_i8_ p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime SpecifyKind(System.DateTime, System.DateTimeKind)bool w_S_u8_S_u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ConvertTime(System.DateTime, System.TimeZoneInfo)bool w_S_u8_S_u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ConvertTime(System.DateTime, System.TimeZoneInfo, System.TimeZoneInfo)bool w_S_u8_S_u8_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime, System.String)bool w_S_u8_S_u8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, Il2CppString* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Loading.ContentFile LoadContentFileAsync(Unity.Content.ContentNamespace, System.String, Unity.Collections.NativeArray`1[Unity.Loading.ContentFile], Unity.Jobs.JobHandle)bool w_S_u8_S_u8_sS_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_sS_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, Il2CppString* p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, void* p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime, System.String, System.String)bool w_S_u8_S_u8_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Loading.ContentSceneFile LoadSceneAsync(Unity.Content.ContentNamespace, System.String, System.String, Unity.Loading.ContentSceneParameters, Unity.Collections.NativeArray`1[Unity.Loading.ContentFile], Unity.Jobs.JobHandle)bool w_S_u8_S_u8_ssS_i4i4b_S_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_ssS_i4i4b_S_Pvi4i4i4S_pi4i4_i4_DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal struct
    S_i4i4b_* pp4 = DataTransfer::GetPointer<S_i4i4b_>(env, _sv4);
    S_i4i4b_ p4 = pp4 ? *pp4 : S_i4i4b_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp5 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv5);
    S_Pvi4i4i4S_pi4i4_i4_ p5 = pp5 ? *pp5 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, Il2CppString* p2, Il2CppString* p3, struct S_i4i4b_ p4, struct S_Pvi4i4i4S_pi4i4_i4_ p5, void* p6, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Boolean)bool w_S_u8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(bool p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Char)bool w_S_u8_c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_c");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppChar p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(SByte)bool w_S_u8_i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(int8_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Int16)bool w_S_u8_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Int32)bool w_S_u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Int32, Int32, System.DayOfWeek)bool w_S_u8_i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_u8_ (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Int64)bool w_S_u8_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Mono.Security.ASN1)bool w_S_u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Single)bool w_S_u8_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(float p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Double)bool w_S_u8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(double p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.String)bool w_S_u8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.String, System.Xml.XmlDateTimeSerializationMode)bool w_S_u8_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_si4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.String, System.IFormatProvider)bool w_S_u8_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime Parse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_u8_soi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_soi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_u8_sooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sooi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.String, System.String)bool w_S_u8_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider)bool w_S_u8_sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_u8_ssoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ssoi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime get_Date()bool w_S_u8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u8_ (*FuncToCall)(void*,const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(System.Object)bool w_S_u8_tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime Add(System.TimeSpan)bool w_S_u8_tS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToUniversalTime(System.DateTime)bool w_S_u8_tS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime AddMonths(System.DateTime, Int32)bool w_S_u8_tS_u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,struct S_u8_ p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime AddMilliseconds(System.DateTime, Double)bool w_S_u8_tS_u8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_u8_r8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,struct S_u8_ p1, double p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime AddMonths(Int32)bool w_S_u8_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32)bool w_S_u8_ti4i4i4i4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32)bool w_S_u8_ti4i4i4i4i4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime AddTicks(Int64)bool w_S_u8_ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,int64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken AddEventHandler(T)bool w_S_u8_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime AddDays(Double)bool w_S_u8_tr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tr8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(void*,double p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime GetDateTime(System.String)bool w_S_u8_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ReadElementContentAsDateTime(System.String, System.String)bool w_S_u8_tss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_u8_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(Byte)bool w_S_u8_u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(uint8_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(UInt16)bool w_S_u8_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(UInt32)bool w_S_u8_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTime ToDateTime(UInt64)bool w_S_u8_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8_ (*FuncToCall)(uint64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.XR.InputDevice GetDeviceAtXRNode(UnityEngine.XR.XRNode)bool w_S_u8b_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8b_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8b_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_u8b_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.DisplayInfo get_mainWindowDisplayInfo()bool w_S_u8i4i4S_u4u4_S_i4i4i4i4_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4S_u4u4_S_i4i4i4i4_s_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ (*FuncToCall)(const void* method);
    struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle Schedule(JobScheduleParameters ByRef)bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p1 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle ScheduleParallelForDeferArraySize(JobScheduleParameters ByRef, Int32, Void*, Void*)bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4PvPv(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4PvPv");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!pesapi_is_binary(env, _sv3) && !pesapi_is_null(env, _sv3) && !pesapi_is_undefined(env, _sv3)) return false;                if (!pesapi_is_binary(env, _sv4) && !pesapi_is_null(env, _sv4) && !pesapi_is_undefined(env, _sv4)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p1 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = DataTransfer::GetPointer<void>(env, _sv4);        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle ScheduleParallelFor(JobScheduleParameters ByRef, Int32, Int32)bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p1 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p1, int32_t p2, int32_t p3, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle ScheduleParallelForTransform(JobScheduleParameters ByRef, IntPtr)bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_p");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p1 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p1, void* p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle ScheduleParallelForTransformReadOnly(JobScheduleParameters ByRef, IntPtr, Int32)bool w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_S_u8i4i4p_i4pp_pi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_u8i4i4p_i4pp_* p1 = DataTransfer::GetPointer<S_S_u8i4i4p_i4pp_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_u8i4i4p_i4pp_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p1, void* p2, int32_t p3, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle CombineDependencies(Unity.Jobs.JobHandle*, Int32)bool w_S_u8i4i4p_PS_u8i4i4p_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_PS_u8i4i4p_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S_u8i4i4p_* p1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void* p1, int32_t p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle CombineDependencies(Unity.Collections.NativeSlice`1[Unity.Jobs.JobHandle])bool w_S_u8i4i4p_S_Pu1i4i4i4i4S_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pu1i4i4i4i4S_pi4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv1);
    S_Pu1i4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pu1i4i4i4i4S_pi4i4__ p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle CombineDependencies(Unity.Collections.NativeArray`1[Unity.Jobs.JobHandle])bool w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle ScheduleBatch(Unity.Collections.NativeArray`1[UnityEngine.RaycastCommand], Unity.Collections.NativeArray`1[UnityEngine.RaycastHit], Int32, Unity.Jobs.JobHandle)bool w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4DS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, int32_t p3, void* p4, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle ScheduleBatch(Unity.Collections.NativeArray`1[UnityEngine.RaycastCommand], Unity.Collections.NativeArray`1[UnityEngine.RaycastHit], Int32, Int32, Unity.Jobs.JobHandle)bool w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4i4DS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_i4i4DS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, int32_t p3, int32_t p4, void* p5, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle GetWriter(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle)bool w_S_u8i4i4p_S_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_pi4i4_ p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle CombineDependencies(Unity.Jobs.JobHandle, Unity.Jobs.JobHandle)bool w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};
        
     // LuaValToCSVal struct
    S_u8i4i4p_* pp2 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv2);
    S_u8i4i4p_ p2 = pp2 ? *pp2 : S_u8i4i4p_ {};
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_u8i4i4p_ p1, struct S_u8i4i4p_ p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle CombineDependencies(Unity.Jobs.JobHandle, Unity.Jobs.JobHandle, Unity.Jobs.JobHandle)bool w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_S_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};
        
     // LuaValToCSVal struct
    S_u8i4i4p_* pp2 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv2);
    S_u8i4i4p_ p2 = pp2 ? *pp2 : S_u8i4i4p_ {};
        
     // LuaValToCSVal struct
    S_u8i4i4p_* pp3 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv3);
    S_u8i4i4p_ p3 = pp3 ? *pp3 : S_u8i4i4p_ {};
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(struct S_u8i4i4p_ p1, struct S_u8i4i4p_ p2, struct S_u8i4i4p_ p3, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle CloseCachedFileAsync(System.String, Unity.Jobs.JobHandle)bool w_S_u8i4i4p_sDS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_sDS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle get_JobHandle()bool w_S_u8i4i4p_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u8i4i4p_ (*FuncToCall)(void*,const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle Close(Unity.Jobs.JobHandle)bool w_S_u8i4i4p_tDS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_tDS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Jobs.JobHandle Dispose(Unity.Jobs.JobHandle)bool w_S_u8i4i4p_tS_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4p_tS_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};
        
    typedef struct S_u8i4i4p_ (*FuncToCall)(void*,struct S_u8i4i4p_ p1, const void* method);
    struct S_u8i4i4p_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.XR.MeshId get_InvalidId()bool w_S_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u8u8_ (*FuncToCall)(const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 Compute(Void*, UInt64)bool w_S_u8u8_Pvu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_Pvu8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef struct S_u8u8_ (*FuncToCall)(void* p1, uint64_t p2, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 GetAssetDependencyHash(UnityEditor.GUID)bool w_S_u8u8_S_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_S_u4u4u4u4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
    typedef struct S_u8u8_ (*FuncToCall)(struct S_u4u4u4u4_ p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 Compute(Int32)bool w_S_u8u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_u8u8_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 CalculatePlayerSerializationHashForType(System.Type, UnityEditor.Build.Player.TypeDB)bool w_S_u8u8_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_u8u8_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 Compute(Single)bool w_S_u8u8_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_u8u8_ (*FuncToCall)(float p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 Parse(System.String)bool w_S_u8u8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u8u8_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 GetArtifactHash(System.String, ImportSyncMode)bool w_S_u8u8_sDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_sDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_u8u8_ (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 GetArtifactHash(System.String, System.Type, ImportSyncMode)bool w_S_u8u8_soDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_soDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_u8u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 get_hash()bool w_S_u8u8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_u8u8_ (*FuncToCall)(void*,const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_S_u8u8_toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_toS_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef struct S_u8u8_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Hash128 GetAssetBundleHash(System.String)bool w_S_u8u8_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8u8_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_u8u8_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_u8u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Boolean get_MonitoringIsEnabled()bool w_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_b");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsAssetDatabaseAvailable(Boolean)bool w_bDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bDb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CollectIncremental(UInt64)bool w_bDu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bDu8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDBNull(System.Object)bool w_bO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Object, System.Object)bool w_bOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetComObjectData(System.Object, System.Object, System.Object)bool w_bOOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOOO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AreEqual(System.Object, System.Object, NUnit.Framework.Constraints.Tolerance ByRef)bool w_bOOPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOOPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryEnter(System.Object, System.TimeSpan)bool w_bOS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Wait(System.Object, System.TimeSpan, Boolean)bool w_bOS_i8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_i8_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Object, System.RuntimeTypeHandle)bool w_bOS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOS_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_p_* pp2 = DataTransfer::GetPointer<S_p_>(env, _sv2);
    S_p_ p2 = pp2 ? *pp2 : S_p_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_p_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryEnter(System.Object, Int32)bool w_bOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Wait(System.Object, Int32, Boolean)bool w_bOi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOi4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(System.Object, System.IFormatProvider)bool w_bOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetEntryTimingInfo(UnityEditorInternal.NativeProfilerTimeline_GetEntryTimingInfoArgs ByRef)bool w_bPS_i4i4i4br4r4r4i4r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4br4r4r4i4r4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4i4br4r4r4i4r4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4br4r4r4i4r4i4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4br4r4r4i4r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetEntryInstanceInfo(UnityEditorInternal.NativeProfilerTimeline_GetEntryInstanceInfoArgs ByRef)bool w_bPS_i4i4i4i4soss_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4i4soss_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4i4i4soss_* p1 = DataTransfer::GetPointer<S_i4i4i4i4soss_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4i4soss_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetWorkStealingRange(Unity.Jobs.LowLevel.Unsafe.JobRanges ByRef, Int32, Int32 ByRef, Int32 ByRef)bool w_bPS_i4i4i4p_i4Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4p_i4Pi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4i4p_* p1 = DataTransfer::GetPointer<S_i4i4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetEntryPositionInfo(UnityEditorInternal.NativeProfilerTimeline_GetEntryPositionInfoArgs ByRef)bool w_bPS_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_* p1 = DataTransfer::GetPointer<S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetEntryAtPosition(UnityEditorInternal.NativeProfilerTimeline_GetEntryAtPositionArgs ByRef)bool w_bPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_* p1 = DataTransfer::GetPointer<S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4r4S_r4r4r4r4_S_r4r4r4r4_S_r4r4_i4r4s_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDefaultValue(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle ByRef)bool w_bPS_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_pi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4i4_* p1 = DataTransfer::GetPointer<S_pi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)bool w_bPS_ppi4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_ppi4i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_ppi4i4p_* p1 = DataTransfer::GetPointer<S_ppi4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_ppi4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ComputeElementBounds(UnityEngine.Rect ByRef, System.Collections.Generic.List`1[UnityEditor.Experimental.GraphView.GraphElement], MinSizePolicy)bool w_bPS_r4r4r4r4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_r4r4r4r4_oDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsKeywordEnabled(UnityEngine.Rendering.GlobalKeyword ByRef)bool w_bPS_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_su4_* p1 = DataTransfer::GetPointer<S_su4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_su4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Read(Boolean ByRef)bool w_bPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetDroppedFrameCount(Int32 ByRef)bool w_bPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetLightingSettings(UnityEngine.LightingSettings ByRef)bool w_bPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ReformatTexture(UnityEngine.Texture2D ByRef, Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean)bool w_bPoi4i4i4bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPoi4i4i4bb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, int32_t p3, int32_t p4, bool p5, bool p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGPUTimeLastFrame(Single ByRef)bool w_bPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Threading.Tasks.ValueTask, System.Threading.Tasks.ValueTask)bool w_bS_Oi2b_S_Oi2b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi2b_S_Oi2b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi2b_* pp1 = DataTransfer::GetPointer<S_Oi2b_>(env, _sv1);
    S_Oi2b_ p1 = pp1 ? *pp1 : S_Oi2b_ {};
        
     // LuaValToCSVal struct
    S_Oi2b_* pp2 = DataTransfer::GetPointer<S_Oi2b_>(env, _sv2);
    S_Oi2b_ p2 = pp2 ? *pp2 : S_Oi2b_ {};
        
    typedef bool (*FuncToCall)(struct S_Oi2b_ p1, struct S_Oi2b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryDecode(System.ReadOnlyMemory`1[System.Byte], System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest ByRef, Int32 ByRef)bool w_bS_Oi4i4_PoPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi4i4_PoPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_Oi4i4_ p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetString(System.ReadOnlyMemory`1[System.Char], System.String ByRef, Int32 ByRef, Int32 ByRef)bool w_bS_Oi4i4_PsPi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi4i4_PsPi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_Oi4i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Runtime.InteropServices.ArrayWithOffset, System.Runtime.InteropServices.ArrayWithOffset)bool w_bS_Oi4i4_S_Oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Oi4i4_S_Oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
     // LuaValToCSVal struct
    S_Oi4i4_* pp2 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv2);
    S_Oi4i4_ p2 = pp2 ? *pp2 : S_Oi4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_Oi4i4_ p1, struct S_Oi4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Threading.Tasks.ValueTask`1[TResult], System.Threading.Tasks.ValueTask`1[TResult])bool w_bS_Ooi2b_S_Ooi2b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Ooi2b_S_Ooi2b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Ooi2b_* pp1 = DataTransfer::GetPointer<S_Ooi2b_>(env, _sv1);
    S_Ooi2b_ p1 = pp1 ? *pp1 : S_Ooi2b_ {};
        
     // LuaValToCSVal struct
    S_Ooi2b_* pp2 = DataTransfer::GetPointer<S_Ooi2b_>(env, _sv2);
    S_Ooi2b_ p2 = pp2 ? *pp2 : S_Ooi2b_ {};
        
    typedef bool (*FuncToCall)(struct S_Ooi2b_ p1, struct S_Ooi2b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(Unity.Collections.NativeSlice`1[T], Unity.Collections.NativeSlice`1[T])bool w_bS_Pu1i4i4i4i4S_pi4i4__S_Pu1i4i4i4i4S_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Pu1i4i4i4i4S_pi4i4__S_Pu1i4i4i4i4S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp1 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv1);
    S_Pu1i4i4i4i4S_pi4i4__ p1 = pp1 ? *pp1 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp2 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(env, _sv2);
    S_Pu1i4i4i4i4S_pi4i4__ p2 = pp2 ? *pp2 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_Pu1i4i4i4i4S_pi4i4__ p1, struct S_Pu1i4i4i4i4S_pi4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Render(Unity.Collections.NativeArray`1[System.Single])bool w_bS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(Unity.Collections.NativeArray`1[T], Unity.Collections.NativeArray`1[T])bool w_bS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Net.Security.SslApplicationProtocol, System.Net.Security.SslApplicationProtocol)bool w_bS_S_Oi4i4__S_S_Oi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_Oi4i4__S_S_Oi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_Oi4i4__* pp1 = DataTransfer::GetPointer<S_S_Oi4i4__>(env, _sv1);
    S_S_Oi4i4__ p1 = pp1 ? *pp1 : S_S_Oi4i4__ {};
        
     // LuaValToCSVal struct
    S_S_Oi4i4__* pp2 = DataTransfer::GetPointer<S_S_Oi4i4__>(env, _sv2);
    S_S_Oi4i4__ p2 = pp2 ? *pp2 : S_S_Oi4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_Oi4i4__ p1, struct S_S_Oi4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleTransformOrigin, UnityEngine.UIElements.StyleTransformOrigin)bool w_bS_S_S_r4i4_S_r4i4_r4_i4_S_S_S_r4i4_S_r4i4_r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4i4_S_r4i4_r4_i4_S_S_S_r4i4_S_r4i4_r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4_i4_>(env, _sv1);
    S_S_S_r4i4_S_r4i4_r4_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4i4_r4_i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4_i4_* pp2 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4_i4_>(env, _sv2);
    S_S_S_r4i4_S_r4i4_r4_i4_ p2 = pp2 ? *pp2 : S_S_S_r4i4_S_r4i4_r4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_r4i4_S_r4i4_r4_i4_ p1, struct S_S_S_r4i4_S_r4i4_r4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleTranslate, UnityEngine.UIElements.StyleTranslate)bool w_bS_S_S_r4i4_S_r4i4_r4b_i4_S_S_S_r4i4_S_r4i4_r4b_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4i4_S_r4i4_r4b_i4_S_S_S_r4i4_S_r4i4_r4b_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4b_i4_>(env, _sv1);
    S_S_S_r4i4_S_r4i4_r4b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4i4_r4b_i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4i4_r4b_i4_* pp2 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4i4_r4b_i4_>(env, _sv2);
    S_S_S_r4i4_S_r4i4_r4b_i4_ p2 = pp2 ? *pp2 : S_S_S_r4i4_S_r4i4_r4b_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_r4i4_S_r4i4_r4b_i4_ p1, struct S_S_S_r4i4_S_r4i4_r4b_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleRotate, UnityEngine.UIElements.StyleRotate)bool w_bS_S_S_r4i4_S_r4r4r4_b_i4_S_S_S_r4i4_S_r4r4r4_b_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4i4_S_r4r4r4_b_i4_S_S_S_r4i4_S_r4r4r4_b_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4r4r4_b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4r4r4_b_i4_>(env, _sv1);
    S_S_S_r4i4_S_r4r4r4_b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4i4_S_r4r4r4_b_i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_r4i4_S_r4r4r4_b_i4_* pp2 = DataTransfer::GetPointer<S_S_S_r4i4_S_r4r4r4_b_i4_>(env, _sv2);
    S_S_S_r4i4_S_r4r4r4_b_i4_ p2 = pp2 ? *pp2 : S_S_S_r4i4_S_r4r4r4_b_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_r4i4_S_r4r4r4_b_i4_ p1, struct S_S_S_r4i4_S_r4r4r4_b_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.VisibleReflectionProbe, UnityEngine.Rendering.VisibleReflectionProbe)bool w_bS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_>(env, _sv1);
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_>(env, _sv2);
    S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p2 = pp2 ? *pp2 : S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p1, struct S_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleScale, UnityEngine.UIElements.StyleScale)bool w_bS_S_S_r4r4r4_b_i4_S_S_S_r4r4r4_b_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4r4r4_b_i4_S_S_S_r4r4r4_b_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4r4r4_b_i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4_b_i4_>(env, _sv1);
    S_S_S_r4r4r4_b_i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4_b_i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_r4r4r4_b_i4_* pp2 = DataTransfer::GetPointer<S_S_S_r4r4r4_b_i4_>(env, _sv2);
    S_S_S_r4r4r4_b_i4_ p2 = pp2 ? *pp2 : S_S_S_r4r4r4_b_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_r4r4r4_b_i4_ p1, struct S_S_S_r4r4r4_b_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.DrawingSettings, UnityEngine.Rendering.DrawingSettings)bool w_bS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_>(env, _sv1);
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_>(env, _sv2);
    S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ p1, struct S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.RenderStateBlock, UnityEngine.Rendering.RenderStateBlock)bool w_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* pp1 = DataTransfer::GetPointer<S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_>(env, _sv1);
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p1 = pp1 ? *pp1 : S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_* pp2 = DataTransfer::GetPointer<S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_>(env, _sv2);
    S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p2 = pp2 ? *pp2 : S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p1, struct S_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleEnum`1[T], UnityEngine.UIElements.StyleEnum`1[T])bool w_bS_S__i4_S_S__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S__i4_S_S__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S__i4_* pp1 = DataTransfer::GetPointer<S_S__i4_>(env, _sv1);
    S_S__i4_ p1 = pp1 ? *pp1 : S_S__i4_ {};
        
     // LuaValToCSVal struct
    S_S__i4_* pp2 = DataTransfer::GetPointer<S_S__i4_>(env, _sv2);
    S_S__i4_ p2 = pp2 ? *pp2 : S_S__i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S__i4_ p1, struct S_S__i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleBackgroundSize, UnityEngine.UIElements.StyleBackgroundSize)bool w_bS_S_i4S_r4i4_S_r4i4__i4_S_S_i4S_r4i4_S_r4i4__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4S_r4i4_S_r4i4__i4_S_S_i4S_r4i4_S_r4i4__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4S_r4i4_S_r4i4__i4_* pp1 = DataTransfer::GetPointer<S_S_i4S_r4i4_S_r4i4__i4_>(env, _sv1);
    S_S_i4S_r4i4_S_r4i4__i4_ p1 = pp1 ? *pp1 : S_S_i4S_r4i4_S_r4i4__i4_ {};
        
     // LuaValToCSVal struct
    S_S_i4S_r4i4_S_r4i4__i4_* pp2 = DataTransfer::GetPointer<S_S_i4S_r4i4_S_r4i4__i4_>(env, _sv2);
    S_S_i4S_r4i4_S_r4i4__i4_ p2 = pp2 ? *pp2 : S_S_i4S_r4i4_S_r4i4__i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_i4S_r4i4_S_r4i4__i4_ p1, struct S_S_i4S_r4i4_S_r4i4__i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleBackgroundPosition, UnityEngine.UIElements.StyleBackgroundPosition)bool w_bS_S_i4S_r4i4__i4_S_S_i4S_r4i4__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4S_r4i4__i4_S_S_i4S_r4i4__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4S_r4i4__i4_* pp1 = DataTransfer::GetPointer<S_S_i4S_r4i4__i4_>(env, _sv1);
    S_S_i4S_r4i4__i4_ p1 = pp1 ? *pp1 : S_S_i4S_r4i4__i4_ {};
        
     // LuaValToCSVal struct
    S_S_i4S_r4i4__i4_* pp2 = DataTransfer::GetPointer<S_S_i4S_r4i4__i4_>(env, _sv2);
    S_S_i4S_r4i4__i4_ p2 = pp2 ? *pp2 : S_S_i4S_r4i4__i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_i4S_r4i4__i4_ p1, struct S_S_i4S_r4i4__i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleBackgroundRepeat, UnityEngine.UIElements.StyleBackgroundRepeat)bool w_bS_S_i4i4_i4_S_S_i4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4i4_i4_S_S_i4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4_i4_* pp1 = DataTransfer::GetPointer<S_S_i4i4_i4_>(env, _sv1);
    S_S_i4i4_i4_ p1 = pp1 ? *pp1 : S_S_i4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_S_i4i4_i4_* pp2 = DataTransfer::GetPointer<S_S_i4i4_i4_>(env, _sv2);
    S_S_i4i4_i4_ p2 = pp2 ? *pp2 : S_S_i4i4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_i4i4_i4_ p1, struct S_S_i4i4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.FilteringSettings, UnityEngine.Rendering.FilteringSettings)bool w_bS_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_S_i4i4_i4u4i4S_i2i2_S_i2i2__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_S_i4i4_i4u4i4S_i2i2_S_i2i2__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4_i4u4i4S_i2i2_S_i2i2__* pp1 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2_S_i2i2__>(env, _sv1);
    S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ p1 = pp1 ? *pp1 : S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ {};
        
     // LuaValToCSVal struct
    S_S_i4i4_i4u4i4S_i2i2_S_i2i2__* pp2 = DataTransfer::GetPointer<S_S_i4i4_i4u4i4S_i2i2_S_i2i2__>(env, _sv2);
    S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ p2 = pp2 ? *pp2 : S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ {};
        
    typedef bool (*FuncToCall)(struct S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ p1, struct S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.BoundsInt, UnityEngine.BoundsInt)bool w_bS_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};
        
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp2 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv2);
    S_S_i4i4i4_S_i4i4i4__ p2 = pp2 ? *pp2 : S_S_i4i4i4_S_i4i4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p1, struct S_S_i4i4i4_S_i4i4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Reflection.CustomAttributeNamedArgument, System.Reflection.CustomAttributeNamedArgument)bool w_bS_S_oO_bsoo_S_S_oO_bsoo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_oO_bsoo_S_S_oO_bsoo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_oO_bsoo_* pp1 = DataTransfer::GetPointer<S_S_oO_bsoo_>(env, _sv1);
    S_S_oO_bsoo_ p1 = pp1 ? *pp1 : S_S_oO_bsoo_ {};
        
     // LuaValToCSVal struct
    S_S_oO_bsoo_* pp2 = DataTransfer::GetPointer<S_S_oO_bsoo_>(env, _sv2);
    S_S_oO_bsoo_ p2 = pp2 ? *pp2 : S_S_oO_bsoo_ {};
        
    typedef bool (*FuncToCall)(struct S_S_oO_bsoo_ p1, struct S_S_oO_bsoo_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleCursor, UnityEngine.UIElements.StyleCursor)bool w_bS_S_oS_r4r4_i4_i4_S_S_oS_r4r4_i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_oS_r4r4_i4_i4_S_S_oS_r4r4_i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_oS_r4r4_i4_i4_* pp1 = DataTransfer::GetPointer<S_S_oS_r4r4_i4_i4_>(env, _sv1);
    S_S_oS_r4r4_i4_i4_ p1 = pp1 ? *pp1 : S_S_oS_r4r4_i4_i4_ {};
        
     // LuaValToCSVal struct
    S_S_oS_r4r4_i4_i4_* pp2 = DataTransfer::GetPointer<S_S_oS_r4r4_i4_i4_>(env, _sv2);
    S_S_oS_r4r4_i4_i4_ p2 = pp2 ? *pp2 : S_S_oS_r4r4_i4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_oS_r4r4_i4_i4_ p1, struct S_S_oS_r4r4_i4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleBackground, UnityEngine.UIElements.StyleBackground)bool w_bS_S_oooo_i4_S_S_oooo_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_oooo_i4_S_S_oooo_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_oooo_i4_* pp1 = DataTransfer::GetPointer<S_S_oooo_i4_>(env, _sv1);
    S_S_oooo_i4_ p1 = pp1 ? *pp1 : S_S_oooo_i4_ {};
        
     // LuaValToCSVal struct
    S_S_oooo_i4_* pp2 = DataTransfer::GetPointer<S_S_oooo_i4_>(env, _sv2);
    S_S_oooo_i4_ p2 = pp2 ? *pp2 : S_S_oooo_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_oooo_i4_ p1, struct S_S_oooo_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.RendererListParams, UnityEngine.Rendering.RendererListParams)bool w_bS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* pp1 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(env, _sv1);
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p1 = pp1 ? *pp1 : S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ {};
        
     // LuaValToCSVal struct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* pp2 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(env, _sv2);
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p2 = pp2 ? *pp2 : S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ {};
        
    typedef bool (*FuncToCall)(struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p1, struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.ShadowDrawingSettings, UnityEngine.Rendering.ShadowDrawingSettings)bool w_bS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* pp1 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(env, _sv1);
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p1 = pp1 ? *pp1 : S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* pp2 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(env, _sv2);
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p2 = pp2 ? *pp2 : S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p1, struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(System.ReadOnlySpan`1[System.Byte])bool w_bS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.DateTimeOffset ByRef)bool w_bS_S_p_i4_PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p2 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u8_i2_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.DateTimeOffset ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_PS_S_u8_i2_Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_S_u8_i2_Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p2 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u8_i2_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Guid ByRef)bool w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.Guid ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Decimal ByRef)bool w_bS_S_p_i4_PS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i4i4i4i4u8_* p2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.Decimal ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_PS_i4i4i4i4u8_Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4i4i4i4u8_Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i4i4i4i4u8_* p2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Numerics.BigInteger ByRef)bool w_bS_S_p_i4_PS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i4o_* p2 = DataTransfer::GetPointer<S_i4o_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4o_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.TimeSpan ByRef)bool w_bS_S_p_i4_PS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i8_* p2 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.TimeSpan ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_PS_i8_Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_i8_Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i8_* p2 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Buffers.StandardFormat ByRef)bool w_bS_S_p_i4_PS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_u1u1_* p2 = DataTransfer::GetPointer<S_u1u1_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.DateTime ByRef)bool w_bS_S_p_i4_PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_u8_* p2 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], System.DateTime ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_PS_u8_Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u8_Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_u8_* p2 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Boolean ByRef)bool w_bS_S_p_i4_Pb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Boolean ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_PbPi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PbPi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], SByte ByRef)bool w_bS_S_p_i4_Pi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], SByte ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pi1Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi1Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Int16 ByRef)bool w_bS_S_p_i4_Pi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Int16 ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pi2Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi2Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Int32 ByRef)bool w_bS_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Int32 ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pi4Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi4Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Int64 ByRef)bool w_bS_S_p_i4_Pi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Int64 ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pi8Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pi8Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Version ByRef)bool w_bS_S_p_i4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Single ByRef)bool w_bS_S_p_i4_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Single ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pr4Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr4Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Double ByRef)bool w_bS_S_p_i4_Pr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Double ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pr8Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pr8Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], Byte ByRef)bool w_bS_S_p_i4_Pu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], Byte ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pu1Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu1Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], UInt16 ByRef)bool w_bS_S_p_i4_Pu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], UInt16 ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pu2Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu2Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], UInt32 ByRef)bool w_bS_S_p_i4_Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], UInt32 ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pu4Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu4Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], UInt64 ByRef)bool w_bS_S_p_i4_Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Byte], UInt64 ByRef, Int32 ByRef, Char)bool w_bS_S_p_i4_Pu8Pi4Dc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_Pu8Pi4Dc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.ReadOnlySpan`1[T], System.ReadOnlySpan`1[T])bool w_bS_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean MatchesWin32Expression(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], Boolean)bool w_bS_S_p_i4_S_S_p_i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Guid ByRef)bool w_bS_S_p_i4_S_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_PS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p3 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFromBase64Chars(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Byte], Int32 ByRef)bool w_bS_S_p_i4_S_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryToBase64Chars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char], Int32 ByRef, System.Base64FormattingOptions)bool w_bS_S_p_i4_S_S_p_i4_Pi4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryJoin(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], Int32 ByRef)bool w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryJoin(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], Int32 ByRef)bool w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp4 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv4);
    S_S_p_i4_ p4 = pp4 ? *pp4 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, struct S_S_p_i4_ p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.TimeSpan ByRef)bool w_bS_S_p_i4_S_S_p_i4_oPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef)bool w_bS_S_p_i4_S_S_p_i4_oi4PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p5 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_u8_i2_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef)bool w_bS_S_p_i4_S_S_p_i4_oi4PS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_i8_* p5 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_i8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)bool w_bS_S_p_i4_S_S_p_i4_oi4PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_u8_* p5 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_u8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Boolean)bool w_bS_S_p_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Char)bool w_bS_S_p_i4_c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_c");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppChar p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Int16)bool w_bS_S_p_i4_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int16_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Int32)bool w_bS_S_p_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, System.Decimal ByRef)bool w_bS_S_p_i4_i4oPS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i4i4i4i4u8_* p4 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i4i4i4i4u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, System.Numerics.BigInteger ByRef)bool w_bS_S_p_i4_i4oPS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPS_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i4o_* p4 = DataTransfer::GetPointer<S_i4o_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i4o_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, SByte ByRef)bool w_bS_S_p_i4_i4oPi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Int16 ByRef)bool w_bS_S_p_i4_i4oPi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Int32 ByRef)bool w_bS_S_p_i4_i4oPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Int64 ByRef)bool w_bS_S_p_i4_i4oPi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Single ByRef)bool w_bS_S_p_i4_i4oPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Double ByRef)bool w_bS_S_p_i4_i4oPr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, Byte ByRef)bool w_bS_S_p_i4_i4oPu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, UInt16 ByRef)bool w_bS_S_p_i4_i4oPu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, UInt32 ByRef)bool w_bS_S_p_i4_i4oPu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider, UInt64 ByRef)bool w_bS_S_p_i4_i4oPu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i4oPu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Int64)bool w_bS_S_p_i4_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.TimeSpan ByRef)bool w_bS_S_p_i4_oPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_i8_* p3 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_i8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef)bool w_bS_S_p_i4_oi4PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oi4PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p4 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_u8_i2_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)bool w_bS_S_p_i4_oi4PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oi4PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.TimeSpan ByRef)bool w_bS_S_p_i4_ooPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef)bool w_bS_S_p_i4_ooi4PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p5 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_u8_i2_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef)bool w_bS_S_p_i4_ooi4PS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_i8_* p5 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_i8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)bool w_bS_S_p_i4_ooi4PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_u8_* p5 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_u8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Single)bool w_bS_S_p_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], Double)bool w_bS_S_p_i4_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, double p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], UInt16)bool w_bS_S_p_i4_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_u2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, uint16_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], UInt32)bool w_bS_S_p_i4_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_u4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryWriteBytes(System.Span`1[System.Byte], UInt64)bool w_bS_S_p_i4_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_u8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, uint64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.LocalKeyword, UnityEngine.Rendering.LocalKeyword)bool w_bS_S_p_su4_S_S_p_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_su4_S_S_p_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_su4_* pp1 = DataTransfer::GetPointer<S_S_p_su4_>(env, _sv1);
    S_S_p_su4_ p1 = pp1 ? *pp1 : S_S_p_su4_ {};
        
     // LuaValToCSVal struct
    S_S_p_su4_* pp2 = DataTransfer::GetPointer<S_S_p_su4_>(env, _sv2);
    S_S_p_su4_ p2 = pp2 ? *pp2 : S_S_p_su4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_p_su4_ p1, struct S_S_p_su4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.TransformOrigin, UnityEngine.UIElements.TransformOrigin)bool w_bS_S_r4i4_S_r4i4_r4_S_S_r4i4_S_r4i4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_S_r4i4_r4_S_S_r4i4_S_r4i4_r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(env, _sv1);
    S_S_r4i4_S_r4i4_r4_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4_ {};
        
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp2 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(env, _sv2);
    S_S_r4i4_S_r4i4_r4_ p2 = pp2 ? *pp2 : S_S_r4i4_S_r4i4_r4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4_ p1, struct S_S_r4i4_S_r4i4_r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.Translate, UnityEngine.UIElements.Translate)bool w_bS_S_r4i4_S_r4i4_r4b_S_S_r4i4_S_r4i4_r4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_S_r4i4_r4b_S_S_r4i4_S_r4i4_r4b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(env, _sv1);
    S_S_r4i4_S_r4i4_r4b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4b_ {};
        
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp2 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(env, _sv2);
    S_S_r4i4_S_r4i4_r4b_ p2 = pp2 ? *pp2 : S_S_r4i4_S_r4i4_r4b_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4b_ p1, struct S_S_r4i4_S_r4i4_r4b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.Rotate, UnityEngine.UIElements.Rotate)bool w_bS_S_r4i4_S_r4r4r4_b_S_S_r4i4_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_S_r4r4r4_b_S_S_r4i4_S_r4r4r4_b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(env, _sv1);
    S_S_r4i4_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4r4r4_b_ {};
        
     // LuaValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp2 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(env, _sv2);
    S_S_r4i4_S_r4r4r4_b_ p2 = pp2 ? *pp2 : S_S_r4i4_S_r4r4r4_b_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4i4_S_r4r4r4_b_ p1, struct S_S_r4i4_S_r4r4r4_b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleLength, UnityEngine.UIElements.StyleLength)bool w_bS_S_r4i4_i4_S_S_r4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4i4_i4_S_S_r4i4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_i4_>(env, _sv1);
    S_S_r4i4_i4_ p1 = pp1 ? *pp1 : S_S_r4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_S_r4i4_i4_* pp2 = DataTransfer::GetPointer<S_S_r4i4_i4_>(env, _sv2);
    S_S_r4i4_i4_ p2 = pp2 ? *pp2 : S_S_r4i4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4i4_i4_ p1, struct S_S_r4i4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Implicit(UnityEngine.RaycastHit2D)bool w_bS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4_S_r4r4_S_r4r4_r4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_>(env, _sv1);
    S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p1 = pp1 ? *pp1 : S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.TextShadow, UnityEngine.UIElements.TextShadow)bool w_bS_S_r4r4_r4S_r4r4r4r4__S_S_r4r4_r4S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4_r4S_r4r4r4r4__S_S_r4r4_r4S_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(env, _sv1);
    S_S_r4r4_r4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_r4S_r4r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(env, _sv2);
    S_S_r4r4_r4S_r4r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4_r4S_r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4_r4S_r4r4r4r4__ p1, struct S_S_r4r4_r4S_r4r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray)bool w_bS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef)bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single)bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single, Int32)bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Bounds, UnityEngine.Bounds)bool w_bS_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, struct S_S_r4r4r4_S_r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IntersectRaySphere(UnityEngine.Ray, UnityEngine.Vector3, Single, Single ByRef, UnityEngine.Vector3 ByRef)bool w_bS_S_r4r4r4_S_r4r4r4__S_r4r4r4_r4Pr4PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__S_r4r4r4_r4Pr4PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p5 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_r4r4r4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, struct S_r4r4r4_ p2, float p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, Single)bool w_bS_S_r4r4r4_S_r4r4r4__r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef)bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single)bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, void* p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single, Int32)bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, void* p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, void* p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, Single, Int32)bool w_bS_S_r4r4r4_S_r4r4r4__r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Ray, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_S_r4r4r4_S_r4r4r4__r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, Single)bool w_bS_S_r4r4r4_S_r4r4r4__r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, Single, Int32)bool w_bS_S_r4r4r4_S_r4r4r4__r4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Ray, Single, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_S_r4r4r4_S_r4r4r4__r4r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__r4r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Pose, UnityEngine.Pose)bool w_bS_S_r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4r4__S_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4r4__ p1, struct S_S_r4r4r4_S_r4r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.Scale, UnityEngine.UIElements.Scale)bool w_bS_S_r4r4r4_b_S_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_b_S_S_r4r4r4_b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(env, _sv1);
    S_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4r4r4_b_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_b_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(env, _sv2);
    S_S_r4r4r4_b_ p2 = pp2 ? *pp2 : S_S_r4r4r4_b_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_b_ p1, struct S_S_r4r4r4_b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Numerics.Plane, System.Numerics.Plane)bool w_bS_S_r4r4r4_r4_S_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_r4_S_S_r4r4r4_r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv2);
    S_S_r4r4r4_r4_ p2 = pp2 ? *pp2 : S_S_r4r4r4_r4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, struct S_S_r4r4r4_r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.CameraProperties, UnityEngine.Rendering.CameraProperties)bool w_bS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_>(env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_>(env, _sv2);
    S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p2 = pp2 ? *pp2 : S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p1, struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UI.ColorBlock, UnityEngine.UI.ColorBlock)bool w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_>(env, _sv1);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_>(env, _sv2);
    S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p2 = pp2 ? *pp2 : S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p1, struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleColor, UnityEngine.UIElements.StyleColor)bool w_bS_S_r4r4r4r4_i4_S_S_r4r4r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_i4_S_S_r4r4r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(env, _sv1);
    S_S_r4r4r4r4_i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_i4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4r4_i4_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(env, _sv2);
    S_S_r4r4r4r4_i4_ p2 = pp2 ? *pp2 : S_S_r4r4r4r4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_i4_ p1, struct S_S_r4r4r4r4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleColor, UnityEngine.Color)bool w_bS_S_r4r4r4r4_i4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4_i4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4_i4_>(env, _sv1);
    S_S_r4r4r4r4_i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4_i4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4_i4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.SortingSettings, UnityEngine.Rendering.SortingSettings)bool w_bS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(env, _sv1);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_>(env, _sv2);
    S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p2 = pp2 ? *pp2 : S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p1, struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.BlendState, UnityEngine.Rendering.BlendState)bool w_bS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ {};
        
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_* pp2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_>(env, _sv2);
    S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p2 = pp2 ? *pp2 : S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ {};
        
    typedef bool (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p1, struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Numerics.Vector`1[T], System.Numerics.Vector`1[T])bool w_bS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv2);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2 = pp2 ? *pp2 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
    typedef bool (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord, UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord)bool w_bS_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_* pp1 = DataTransfer::GetPointer<S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_>(env, _sv1);
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p1 = pp1 ? *pp1 : S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ {};
        
     // LuaValToCSVal struct
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_* pp2 = DataTransfer::GetPointer<S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_>(env, _sv2);
    S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p2 = pp2 ? *pp2 : S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p1, struct S_S_u4S_r4r4r4r4__S_u4S_r4r4r4r4__i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.Build.Content.ObjectIdentifier, UnityEditor.Build.Content.ObjectIdentifier)bool w_bS_S_u4u4u4u4_i8i4s_S_S_u4u4u4u4_i8i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u4u4u4u4_i8i4s_S_S_u4u4u4u4_i8i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(env, _sv1);
    S_S_u4u4u4u4_i8i4s_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_i8i4s_ {};
        
     // LuaValToCSVal struct
    S_S_u4u4u4u4_i8i4s_* pp2 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(env, _sv2);
    S_S_u4u4u4u4_i8i4s_ p2 = pp2 ? *pp2 : S_S_u4u4u4u4_i8i4s_ {};
        
    typedef bool (*FuncToCall)(struct S_S_u4u4u4u4_i8i4s_ p1, struct S_S_u4u4u4u4_i8i4s_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.DateTimeOffset, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bS_S_u8_i2_S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8_i2_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_S_u8_i2_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.DateTimeOffset, System.DateTimeOffset)bool w_bS_S_u8_i2_S_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8_i2_S_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal struct
    S_S_u8_i2_* pp2 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv2);
    S_S_u8_i2_ p2 = pp2 ? *pp2 : S_S_u8_i2_ {};
        
    typedef bool (*FuncToCall)(struct S_S_u8_i2_ p1, struct S_S_u8_i2_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetArtifactPaths(UnityEditor.Experimental.ArtifactID, System.String[] ByRef)bool w_bS_S_u8u8__Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8__Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8__* pp1 = DataTransfer::GetPointer<S_S_u8u8__>(env, _sv1);
    S_S_u8u8__ p1 = pp1 ? *pp1 : S_S_u8u8__ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(struct S_S_u8u8__ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.MeshInfo, UnityEngine.XR.MeshInfo)bool w_bS_S_u8u8_i4i4_S_S_u8u8_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8_i4i4_S_S_u8u8_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_i4i4_* pp1 = DataTransfer::GetPointer<S_S_u8u8_i4i4_>(env, _sv1);
    S_S_u8u8_i4i4_ p1 = pp1 ? *pp1 : S_S_u8u8_i4i4_ {};
        
     // LuaValToCSVal struct
    S_S_u8u8_i4i4_* pp2 = DataTransfer::GetPointer<S_S_u8u8_i4i4_>(env, _sv2);
    S_S_u8u8_i4i4_ p2 = pp2 ? *pp2 : S_S_u8u8_i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_u8u8_i4i4_ p1, struct S_S_u8u8_i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.MeshGenerationResult, UnityEngine.XR.MeshGenerationResult)bool w_bS_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1, struct S_S_u8u8_ooi4i4u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.MeshTransform, UnityEngine.XR.MeshTransform)bool w_bS_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p1, struct S_S_u8u8_u8S_r4r4r4_S_r4r4r4r4_S_r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.SceneManagement.StageHandle, UnityEditor.SceneManagement.StageHandle)bool w_bS_bS_i4__S_bS_i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_bS_i4__S_bS_i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_bS_i4__* pp1 = DataTransfer::GetPointer<S_bS_i4__>(env, _sv1);
    S_bS_i4__ p1 = pp1 ? *pp1 : S_bS_i4__ {};
        
     // LuaValToCSVal struct
    S_bS_i4__* pp2 = DataTransfer::GetPointer<S_bS_i4__>(env, _sv2);
    S_bS_i4__ p2 = pp2 ? *pp2 : S_bS_i4__ {};
        
    typedef bool (*FuncToCall)(struct S_bS_i4__ p1, struct S_bS_i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Threading.AsyncFlowControl, System.Threading.AsyncFlowControl)bool w_bS_boo_S_boo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_boo_S_boo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_boo_* pp1 = DataTransfer::GetPointer<S_boo_>(env, _sv1);
    S_boo_ p1 = pp1 ? *pp1 : S_boo_ {};
        
     // LuaValToCSVal struct
    S_boo_* pp2 = DataTransfer::GetPointer<S_boo_>(env, _sv2);
    S_boo_ p2 = pp2 ? *pp2 : S_boo_ {};
        
    typedef bool (*FuncToCall)(struct S_boo_ p1, struct S_boo_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.ConsoleKeyInfo, System.ConsoleKeyInfo)bool w_bS_ci4i4_S_ci4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_ci4i4_S_ci4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_ci4i4_* pp1 = DataTransfer::GetPointer<S_ci4i4_>(env, _sv1);
    S_ci4i4_ p1 = pp1 ? *pp1 : S_ci4i4_ {};
        
     // LuaValToCSVal struct
    S_ci4i4_* pp2 = DataTransfer::GetPointer<S_ci4i4_>(env, _sv2);
    S_ci4i4_ p2 = pp2 ? *pp2 : S_ci4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_ci4i4_ p1, struct S_ci4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Inequality(UnityEngine.Rendering.SortingLayerRange, UnityEngine.Rendering.SortingLayerRange)bool w_bS_i2i2_S_i2i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i2i2_S_i2i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i2i2_* pp1 = DataTransfer::GetPointer<S_i2i2_>(env, _sv1);
    S_i2i2_ p1 = pp1 ? *pp1 : S_i2i2_ {};
        
     // LuaValToCSVal struct
    S_i2i2_* pp2 = DataTransfer::GetPointer<S_i2i2_>(env, _sv2);
    S_i2i2_ p2 = pp2 ? *pp2 : S_i2i2_ {};
        
    typedef bool (*FuncToCall)(struct S_i2i2_ p1, struct S_i2i2_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleTextShadow, UnityEngine.UIElements.StyleTextShadow)bool w_bS_i4S_S_r4r4_r4S_r4r4r4r4___S_i4S_S_r4r4_r4S_r4r4r4r4___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_S_r4r4_r4S_r4r4r4r4___S_i4S_S_r4r4_r4S_r4r4r4r4___");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_S_r4r4_r4S_r4r4r4r4___* pp1 = DataTransfer::GetPointer<S_i4S_S_r4r4_r4S_r4r4r4r4___>(env, _sv1);
    S_i4S_S_r4r4_r4S_r4r4r4r4___ p1 = pp1 ? *pp1 : S_i4S_S_r4r4_r4S_r4r4r4r4___ {};
        
     // LuaValToCSVal struct
    S_i4S_S_r4r4_r4S_r4r4r4r4___* pp2 = DataTransfer::GetPointer<S_i4S_S_r4r4_r4S_r4r4r4r4___>(env, _sv2);
    S_i4S_S_r4r4_r4S_r4r4r4r4___ p2 = pp2 ? *pp2 : S_i4S_S_r4r4_r4S_r4r4r4r4___ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_S_r4r4_r4S_r4r4r4r4___ p1, struct S_i4S_S_r4r4_r4S_r4r4r4r4___ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.ScriptableCullingParameters, UnityEngine.Rendering.ScriptableCullingParameters)bool w_bS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* pp1 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(env, _sv1);
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p1 = pp1 ? *pp1 : S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ {};
        
     // LuaValToCSVal struct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* pp2 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(env, _sv2);
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p2 = pp2 ? *pp2 : S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p1, struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleFontDefinition, UnityEngine.UIElements.StyleFontDefinition)bool w_bS_i4S_oo__S_i4S_oo__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_oo__S_i4S_oo__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_oo__* pp1 = DataTransfer::GetPointer<S_i4S_oo__>(env, _sv1);
    S_i4S_oo__ p1 = pp1 ? *pp1 : S_i4S_oo__ {};
        
     // LuaValToCSVal struct
    S_i4S_oo__* pp2 = DataTransfer::GetPointer<S_i4S_oo__>(env, _sv2);
    S_i4S_oo__ p2 = pp2 ? *pp2 : S_i4S_oo__ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_oo__ p1, struct S_i4S_oo__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.BackgroundSize, UnityEngine.UIElements.BackgroundSize)bool w_bS_i4S_r4i4_S_r4i4__S_i4S_r4i4_S_r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4i4_S_r4i4__S_i4S_r4i4_S_r4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(env, _sv1);
    S_i4S_r4i4_S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4_S_r4i4__ {};
        
     // LuaValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp2 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(env, _sv2);
    S_i4S_r4i4_S_r4i4__ p2 = pp2 ? *pp2 : S_i4S_r4i4_S_r4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_r4i4_S_r4i4__ p1, struct S_i4S_r4i4_S_r4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.BackgroundPosition, UnityEngine.UIElements.BackgroundPosition)bool w_bS_i4S_r4i4__S_i4S_r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4i4__S_i4S_r4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4__>(env, _sv1);
    S_i4S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4__ {};
        
     // LuaValToCSVal struct
    S_i4S_r4i4__* pp2 = DataTransfer::GetPointer<S_i4S_r4i4__>(env, _sv2);
    S_i4S_r4i4__ p2 = pp2 ? *pp2 : S_i4S_r4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_r4i4__ p1, struct S_i4S_r4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.LODParameters, UnityEngine.Rendering.LODParameters)bool w_bS_i4S_r4r4r4_r4r4i4_S_i4S_r4r4r4_r4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4r4r4_r4r4i4_S_i4S_r4r4r4_r4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4r4r4_r4r4i4_* pp1 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4r4i4_>(env, _sv1);
    S_i4S_r4r4r4_r4r4i4_ p1 = pp1 ? *pp1 : S_i4S_r4r4r4_r4r4i4_ {};
        
     // LuaValToCSVal struct
    S_i4S_r4r4r4_r4r4i4_* pp2 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4r4i4_>(env, _sv2);
    S_i4S_r4r4r4_r4r4i4_ p2 = pp2 ? *pp2 : S_i4S_r4r4r4_r4r4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_r4r4r4_r4r4i4_ p1, struct S_i4S_r4r4r4_r4r4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.VisibleLight, UnityEngine.Rendering.VisibleLight)bool w_bS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* pp1 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_>(env, _sv1);
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p1 = pp1 ? *pp1 : S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_* pp2 = DataTransfer::GetPointer<S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_>(env, _sv2);
    S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p2 = pp2 ? *pp2 : S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p1, struct S_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.ShadowSplitData, UnityEngine.Rendering.ShadowSplitData)bool w_bS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(env, _sv1);
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p1 = pp1 ? *pp1 : S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__* pp2 = DataTransfer::GetPointer<S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__>(env, _sv2);
    S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p2 = pp2 ? *pp2 : S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p1, struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RemoveCache(UnityEngine.Cache)bool w_bS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Reflection.Emit.EventToken, System.Reflection.Emit.EventToken)bool w_bS_i4_S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_S_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
     // LuaValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4_ p1, struct S_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CloseScene(UnityEngine.SceneManagement.Scene, Boolean)bool w_bS_i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_i4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SaveScene(UnityEngine.SceneManagement.Scene, System.String)bool w_bS_i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(struct S_i4_ p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SaveScene(UnityEngine.SceneManagement.Scene, System.String, Boolean)bool w_bS_i4_sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4_sb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_i4_ p1, Il2CppString* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.Guid, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Guid, System.Guid)bool w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsNullOrEmpty(UnityEngine.PropertyName)bool w_bS_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Vector2Int, UnityEngine.Vector2Int)bool w_bS_i4i4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4_S_i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.AttachmentDescriptor, UnityEngine.Rendering.AttachmentDescriptor)bool w_bS_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_* pp1 = DataTransfer::GetPointer<S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_>(env, _sv1);
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p1 = pp1 ? *pp1 : S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_* pp2 = DataTransfer::GetPointer<S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_>(env, _sv2);
    S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p2 = pp2 ? *pp2 : S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p1, struct S_i4i4i4S_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4r4r4_r4u4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Threading.LockCookie, System.Threading.LockCookie)bool w_bS_i4i4i4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4_S_i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.VertexAttributeDescriptor, UnityEngine.Rendering.VertexAttributeDescriptor)bool w_bS_i4i4i4i4_S_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4_S_i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4_ p1, struct S_i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Reset(UnityEngine.AudioConfiguration)bool w_bS_i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Reflection.Emit.ExceptionHandler, System.Reflection.Emit.ExceptionHandler)bool w_bS_i4i4i4i4i4i4i4_S_i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4i4i4i4_S_i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(env, _sv2);
    S_i4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4i4i4i4_ p1, struct S_i4i4i4i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(System.Decimal)bool w_bS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.Decimal, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bS_i4i4i4i4u8_S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Decimal, System.Decimal)bool w_bS_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier)bool w_bS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(env, _sv2);
    S_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4pi4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.RasterState, UnityEngine.Rendering.RasterState)bool w_bS_i4i4r4u1u1u1u1_S_i4i4r4u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4r4u1u1u1u1_S_i4i4r4u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4r4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i4r4u1u1u1u1_>(env, _sv1);
    S_i4i4r4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i4r4u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_i4i4r4u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i4r4u1u1u1u1_>(env, _sv2);
    S_i4i4r4u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i4r4u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4r4u1u1u1u1_ p1, struct S_i4i4r4u1u1u1u1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleList`1[T], UnityEngine.UIElements.StyleList`1[T])bool w_bS_i4o_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4o_S_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
    typedef bool (*FuncToCall)(struct S_i4o_ p1, struct S_i4o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_LessThan(System.Numerics.BigInteger, Int64)bool w_bS_i4o_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4o_i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_i4o_ p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_LessThan(System.Numerics.BigInteger, UInt64)bool w_bS_i4o_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4o_u8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_i4o_ p1, uint64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.Presets.PresetType, UnityEditor.Presets.PresetType)bool w_bS_i4os_S_i4os_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4os_S_i4os_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4os_* pp1 = DataTransfer::GetPointer<S_i4os_>(env, _sv1);
    S_i4os_ p1 = pp1 ? *pp1 : S_i4os_ {};
        
     // LuaValToCSVal struct
    S_i4os_* pp2 = DataTransfer::GetPointer<S_i4os_>(env, _sv2);
    S_i4os_ p2 = pp2 ? *pp2 : S_i4os_ {};
        
    typedef bool (*FuncToCall)(struct S_i4os_ p1, struct S_i4os_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetDefaultPresetsForType(UnityEditor.Presets.PresetType, UnityEditor.Presets.DefaultPreset[])bool w_bS_i4os_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4os_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_i4os_* pp1 = DataTransfer::GetPointer<S_i4os_>(env, _sv1);
    S_i4os_ p1 = pp1 ? *pp1 : S_i4os_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(struct S_i4os_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsNullOrEmpty(UnityEngine.UIElements.StylePropertyName)bool w_bS_i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
        
    typedef bool (*FuncToCall)(struct S_i4s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StylePropertyName, UnityEngine.UIElements.StylePropertyName)bool w_bS_i4s_S_i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4s_S_i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4s_* pp1 = DataTransfer::GetPointer<S_i4s_>(env, _sv1);
    S_i4s_ p1 = pp1 ? *pp1 : S_i4s_ {};
        
     // LuaValToCSVal struct
    S_i4s_* pp2 = DataTransfer::GetPointer<S_i4s_>(env, _sv2);
    S_i4s_ p2 = pp2 ? *pp2 : S_i4s_ {};
        
    typedef bool (*FuncToCall)(struct S_i4s_ p1, struct S_i4s_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.TimeSpan, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bS_i8_S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_i8_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.TimeSpan, System.TimeSpan)bool w_bS_i8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8_S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef bool (*FuncToCall)(struct S_i8_ p1, struct S_i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.TimerState, UnityEngine.UIElements.TimerState)bool w_bS_i8i8_S_i8i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8i8_S_i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8i8_* pp1 = DataTransfer::GetPointer<S_i8i8_>(env, _sv1);
    S_i8i8_ p1 = pp1 ? *pp1 : S_i8i8_ {};
        
     // LuaValToCSVal struct
    S_i8i8_* pp2 = DataTransfer::GetPointer<S_i8i8_>(env, _sv2);
    S_i8i8_ p2 = pp2 ? *pp2 : S_i8i8_ {};
        
    typedef bool (*FuncToCall)(struct S_i8i8_ p1, struct S_i8i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Diagnostics.CounterSample, System.Diagnostics.CounterSample)bool w_bS_i8i8i8i8i8i8i8i4_S_i8i8i8i8i8i8i8i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i8i8i8i8i8i8i8i4_S_i8i8i8i8i8i8i8i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp1 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(env, _sv1);
    S_i8i8i8i8i8i8i8i4_ p1 = pp1 ? *pp1 : S_i8i8i8i8i8i8i8i4_ {};
        
     // LuaValToCSVal struct
    S_i8i8i8i8i8i8i8i4_* pp2 = DataTransfer::GetPointer<S_i8i8i8i8i8i8i8i4_>(env, _sv2);
    S_i8i8i8i8i8i8i8i4_ p2 = pp2 ? *pp2 : S_i8i8i8i8i8i8i8i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i8i8i8i8i8i8i8i4_ p1, struct S_i8i8i8i8i8i8i8i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Reflection.CustomAttributeTypedArgument, System.Reflection.CustomAttributeTypedArgument)bool w_bS_oO_S_oO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oO_S_oO_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oO_* pp1 = DataTransfer::GetPointer<S_oO_>(env, _sv1);
    S_oO_ p1 = pp1 ? *pp1 : S_oO_ {};
        
     // LuaValToCSVal struct
    S_oO_* pp2 = DataTransfer::GetPointer<S_oO_>(env, _sv2);
    S_oO_ p2 = pp2 ? *pp2 : S_oO_ {};
        
    typedef bool (*FuncToCall)(struct S_oO_ p1, struct S_oO_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Threading.CancellationTokenRegistration, System.Threading.CancellationTokenRegistration)bool w_bS_oS_oi4__S_oS_oi4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oS_oi4__S_oS_oi4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oS_oi4__* pp1 = DataTransfer::GetPointer<S_oS_oi4__>(env, _sv1);
    S_oS_oi4__ p1 = pp1 ? *pp1 : S_oS_oi4__ {};
        
     // LuaValToCSVal struct
    S_oS_oi4__* pp2 = DataTransfer::GetPointer<S_oS_oi4__>(env, _sv2);
    S_oS_oi4__ p2 = pp2 ? *pp2 : S_oS_oi4__ {};
        
    typedef bool (*FuncToCall)(struct S_oS_oi4__ p1, struct S_oS_oi4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.Cursor, UnityEngine.UIElements.Cursor)bool w_bS_oS_r4r4_i4_S_oS_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oS_r4r4_i4_S_oS_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oS_r4r4_i4_* pp1 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(env, _sv1);
    S_oS_r4r4_i4_ p1 = pp1 ? *pp1 : S_oS_r4r4_i4_ {};
        
     // LuaValToCSVal struct
    S_oS_r4r4_i4_* pp2 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(env, _sv2);
    S_oS_r4r4_i4_ p2 = pp2 ? *pp2 : S_oS_r4r4_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_oS_r4r4_i4_ p1, struct S_oS_r4r4_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Threading.CancellationToken, System.Threading.CancellationToken)bool w_bS_o_S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_o_S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef bool (*FuncToCall)(struct S_o_ p1, struct S_o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.StyleFont, UnityEngine.UIElements.StyleFont)bool w_bS_oi4_S_oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oi4_S_oi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4_* pp1 = DataTransfer::GetPointer<S_oi4_>(env, _sv1);
    S_oi4_ p1 = pp1 ? *pp1 : S_oi4_ {};
        
     // LuaValToCSVal struct
    S_oi4_* pp2 = DataTransfer::GetPointer<S_oi4_>(env, _sv2);
    S_oi4_ p2 = pp2 ? *pp2 : S_oi4_ {};
        
    typedef bool (*FuncToCall)(struct S_oi4_ p1, struct S_oi4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.ArraySegment`1[T], System.ArraySegment`1[T])bool w_bS_oi4i4_S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oi4i4_S_oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv1);
    S_oi4i4_ p1 = pp1 ? *pp1 : S_oi4i4_ {};
        
     // LuaValToCSVal struct
    S_oi4i4_* pp2 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv2);
    S_oi4i4_ p2 = pp2 ? *pp2 : S_oi4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_oi4i4_ p1, struct S_oi4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.FontDefinition, UnityEngine.UIElements.FontDefinition)bool w_bS_oo_S_oo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oo_S_oo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oo_* pp1 = DataTransfer::GetPointer<S_oo_>(env, _sv1);
    S_oo_ p1 = pp1 ? *pp1 : S_oo_ {};
        
     // LuaValToCSVal struct
    S_oo_* pp2 = DataTransfer::GetPointer<S_oo_>(env, _sv2);
    S_oo_ p2 = pp2 ? *pp2 : S_oo_ {};
        
    typedef bool (*FuncToCall)(struct S_oo_ p1, struct S_oo_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.Background, UnityEngine.UIElements.Background)bool w_bS_oooo_S_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_oooo_S_oooo_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef bool (*FuncToCall)(struct S_oooo_ p1, struct S_oooo_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.UIElements.UQueryBuilder`1[T], UnityEngine.UIElements.UQueryBuilder`1[T])bool w_bS_ooooi4i4i4_S_ooooi4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_ooooi4i4i4_S_ooooi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_ooooi4i4i4_* pp1 = DataTransfer::GetPointer<S_ooooi4i4i4_>(env, _sv1);
    S_ooooi4i4i4_ p1 = pp1 ? *pp1 : S_ooooi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_ooooi4i4i4_* pp2 = DataTransfer::GetPointer<S_ooooi4i4i4_>(env, _sv2);
    S_ooooi4i4i4_ p2 = pp2 ? *pp2 : S_ooooi4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_ooooi4i4i4_ p1, struct S_ooooi4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.CullingResults)bool w_bS_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__* pp1 = DataTransfer::GetPointer<S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__>(env, _sv1);
    S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ p1 = pp1 ? *pp1 : S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__* pp2 = DataTransfer::GetPointer<S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__>(env, _sv2);
    S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ p2 = pp2 ? *pp2 : S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ p1, struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Rendering.ScriptableRenderContext)bool w_bS_pS_pi4i4__S_pS_pi4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pS_pi4i4__S_pS_pi4i4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_pS_pi4i4__* pp1 = DataTransfer::GetPointer<S_pS_pi4i4__>(env, _sv1);
    S_pS_pi4i4__ p1 = pp1 ? *pp1 : S_pS_pi4i4__ {};
        
     // LuaValToCSVal struct
    S_pS_pi4i4__* pp2 = DataTransfer::GetPointer<S_pS_pi4i4__>(env, _sv2);
    S_pS_pi4i4__ p2 = pp2 ? *pp2 : S_pS_pi4i4__ {};
        
    typedef bool (*FuncToCall)(struct S_pS_pi4i4__ p1, struct S_pS_pi4i4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.RuntimeTypeHandle, System.Object)bool w_bS_p_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_p_O");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(struct S_p_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.ModuleHandle, System.ModuleHandle)bool w_bS_p_S_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_p_S_p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
     // LuaValToCSVal struct
    S_p_* pp2 = DataTransfer::GetPointer<S_p_>(env, _sv2);
    S_p_ p2 = pp2 ? *pp2 : S_p_ {};
        
    typedef bool (*FuncToCall)(struct S_p_ p1, struct S_p_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsTempMemoryHandle(Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle)bool w_bS_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pi4i4_* pp1 = DataTransfer::GetPointer<S_pi4i4_>(env, _sv1);
    S_pi4i4_ p1 = pp1 ? *pp1 : S_pi4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_pi4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Playables.PlayableHandle, UnityEngine.Playables.PlayableHandle)bool w_bS_pu4_S_pu4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_pu4_S_pu4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
     // LuaValToCSVal struct
    S_pu4_* pp2 = DataTransfer::GetPointer<S_pu4_>(env, _sv2);
    S_pu4_ p2 = pp2 ? *pp2 : S_pu4_ {};
        
    typedef bool (*FuncToCall)(struct S_pu4_ p1, struct S_pu4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.BoneWeight1, UnityEngine.BoneWeight1)bool w_bS_r4i4_S_r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4i4_S_r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};
        
     // LuaValToCSVal struct
    S_r4i4_* pp2 = DataTransfer::GetPointer<S_r4i4_>(env, _sv2);
    S_r4i4_ p2 = pp2 ? *pp2 : S_r4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4i4_ p1, struct S_r4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Vector3 ByRef)bool w_bS_r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PlaceObject(UnityEngine.Vector2, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)bool w_bS_r4r4_PS_r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_PS_r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Vector3 ByRef, UnityEngine.GameObject ByRef)bool w_bS_r4r4_PS_r4r4r4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_PS_r4r4r4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Vector2, UnityEngine.Vector2)bool w_bS_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Vector3 ByRef)bool w_bS_r4r4_oPS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_oPS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Vector3 ByRef, UnityEngine.GameObject ByRef)bool w_bS_r4r4_oPS_r4r4r4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_oPS_r4r4r4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Transform[], UnityEngine.Vector3 ByRef)bool w_bS_r4r4_ooPS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_ooPS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindNearestVertex(UnityEngine.Vector2, UnityEngine.Transform[], UnityEngine.Transform[], UnityEngine.Vector3 ByRef, UnityEngine.GameObject ByRef)bool w_bS_r4r4_ooPS_r4r4r4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_ooPS_r4r4r4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up5 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv5)); // object ret
    Il2CppObject** p5 = &up5;
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindClosestEdge(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, UnityEngine.AI.NavMeshQueryFilter)bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal struct
    S_oi4i4_* pp3 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv3);
    S_oi4i4_ p3 = pp3 ? *pp3 : S_oi4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, void* p2, struct S_oi4i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindClosestEdge(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Int32)bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SamplePosition(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Single, UnityEngine.AI.NavMeshQueryFilter)bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4S_oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_oi4i4_* pp4 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv4);
    S_oi4i4_ p4 = pp4 ? *pp4 : S_oi4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, void* p2, float p3, struct S_oi4i4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SamplePosition(UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Single, Int32)bool w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, void* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3)bool w_bS_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, UnityEngine.AI.NavMeshQueryFilter)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_S_oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
     // LuaValToCSVal struct
    S_oi4i4_* pp4 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv4);
    S_oi4i4_ p4 = pp4 ? *pp4 : S_oi4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, struct S_oi4i4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.AI.NavMeshHit ByRef, Int32)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_r4i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Int32)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CalculatePath(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.AI.NavMeshQueryFilter, UnityEngine.AI.NavMeshPath)bool w_bS_r4r4r4_S_r4r4r4_S_oi4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_oi4i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_oi4i4_* pp3 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv3);
    S_oi4i4_ p3 = pp3 ? *pp3 : S_oi4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_oi4i4_ p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, struct S_r4r4r4r4_ p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, struct S_r4r4r4r4_ p5, float p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, struct S_r4r4r4r4_ p5, float p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_S_r4r4r4r4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, void* p4, struct S_r4r4r4r4_ p5, float p6, int32_t p7, int32_t p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_S_r4r4r4r4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, Int32)bool w_bS_r4r4r4_S_r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CalculatePath(UnityEngine.Vector3, UnityEngine.Vector3, Int32, UnityEngine.AI.NavMeshPath)bool w_bS_r4r4r4_S_r4r4r4_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, int32_t p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single)bool w_bS_r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p5 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p5 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, void* p5, float p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p5 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, void* p5, float p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p5 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, void* p5, float p6, int32_t p7, int32_t p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4S_r4r4r4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32)bool w_bS_r4r4r4_S_r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_S_r4r4r4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Vector3, UnityEngine.Quaternion, Single, Single, CapFunction)bool w_bS_r4r4r4_S_r4r4r4r4_r4r4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4r4_r4r4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, float p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckSphere(UnityEngine.Vector3, Single)bool w_bS_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, void* p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32)bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, void* p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4S_r4r4r4_PS_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_* p4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, void* p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckSphere(UnityEngine.Vector3, Single, Int32)bool w_bS_r4r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckSphere(UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)bool w_bS_r4r4r4_r4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_r4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsViewportRectValidToRender(UnityEngine.Rect)bool w_bS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IntersectsSegment(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Vector2)bool w_bS_r4r4r4r4_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_S_r4r4_S_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Inequality(UnityEngine.Rect, UnityEngine.Rect)bool w_bS_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, Boolean)bool w_bS_r4r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, Boolean, UnityEngine.Texture)bool w_bS_r4r4r4r4_bo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginFoldoutHeaderGroup(UnityEngine.Rect, Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_boDoDoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_boDoDoDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppObject* p3, void* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean InspectorTitlebar(UnityEngine.Rect, Boolean, UnityEngine.Object, Boolean)bool w_bS_r4r4r4r4_bob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppObject* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(UnityEngine.Rect, Boolean, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_bobo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bobo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, Boolean, UnityEngine.Texture, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_boo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_boo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, Boolean, System.String)bool w_bS_r4r4r4r4_bs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginFoldoutHeaderGroup(UnityEngine.Rect, Boolean, System.String, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_bsDoDoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bsDoDoDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppString* p3, void* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(UnityEngine.Rect, Boolean, System.String, Boolean)bool w_bS_r4r4r4r4_bsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bsb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppString* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(UnityEngine.Rect, Boolean, System.String, Boolean, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_bsbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bsbo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppString* p3, bool p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, Boolean, System.String, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_bso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_bso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, bool p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, Int32, Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_i4boo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_i4boo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, bool p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Rect, UnityEngine.Texture)bool w_bS_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, UnityEngine.GUIContent, Boolean)bool w_bS_r4r4r4r4_ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_ob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_obo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_obo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DropdownButton(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.FocusType)bool w_bS_r4r4r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DropdownButton(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_oi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PropertyField(UnityEngine.Rect, UnityEditor.SerializedProperty, UnityEngine.GUIContent, Boolean)bool w_bS_r4r4r4r4_oob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_oob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ScrollTowards(UnityEngine.Rect, Single)bool w_bS_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Rect, System.String)bool w_bS_r4r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, System.String, Boolean)bool w_bS_r4r4r4r4_sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_sb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.Rect, System.String, Boolean, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_sbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_sbo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Rect, System.String, UnityEngine.GUIStyle)bool w_bS_r4r4r4r4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_so");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.BoneWeight, UnityEngine.BoneWeight)bool w_bS_r4r4r4r4i4i4i4i4_S_r4r4r4r4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4i4i4i4i4_S_r4r4r4r4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4i4i4i4i4_>(env, _sv1);
    S_r4r4r4r4i4i4i4i4_ p1 = pp1 ? *pp1 : S_r4r4r4r4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4i4i4i4i4_>(env, _sv2);
    S_r4r4r4r4i4i4i4i4_ p2 = pp2 ? *pp2 : S_r4r4r4r4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4i4i4i4i4_ p1, struct S_r4r4r4r4i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.TextCore.GlyphMetrics, UnityEngine.TextCore.GlyphMetrics)bool w_bS_r4r4r4r4r4_S_r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4_S_r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4_ p1, struct S_r4r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Invert(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2 ByRef)bool w_bS_r4r4r4r4r4r4_PS_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4_PS_r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Numerics.Matrix3x2, System.Numerics.Matrix3x2)bool w_bS_r4r4r4r4r4r4_S_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4_S_r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Decompose(System.Numerics.Matrix4x4, System.Numerics.Vector3 ByRef, System.Numerics.Quaternion ByRef, System.Numerics.Vector3 ByRef)bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Inverse3DAffine(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4 ByRef)bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_PS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Rendering.SphericalHarmonicsL2)bool w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Numerics.Complex, System.Numerics.Complex)bool w_bS_r8r8_S_r8r8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r8r8_S_r8r8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r8r8_* pp1 = DataTransfer::GetPointer<S_r8r8_>(env, _sv1);
    S_r8r8_ p1 = pp1 ? *pp1 : S_r8r8_ {};
        
     // LuaValToCSVal struct
    S_r8r8_* pp2 = DataTransfer::GetPointer<S_r8r8_>(env, _sv2);
    S_r8r8_ p2 = pp2 ? *pp2 : S_r8r8_ {};
        
    typedef bool (*FuncToCall)(struct S_r8r8_ p1, struct S_r8r8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsVersionCached(UnityEngine.CachedAssetBundle)bool w_bS_sS_u8u8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sS_u8u8__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sS_u8u8__* pp1 = DataTransfer::GetPointer<S_sS_u8u8__>(env, _sv1);
    S_sS_u8u8__ p1 = pp1 ? *pp1 : S_sS_u8u8__ {};
        
    typedef bool (*FuncToCall)(struct S_sS_u8u8__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsOSPlatform(System.Runtime.InteropServices.OSPlatform)bool w_bS_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
    typedef bool (*FuncToCall)(struct S_s_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.HashAlgorithmName)bool w_bS_s_S_s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_s_S_s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
     // LuaValToCSVal struct
    S_s_* pp2 = DataTransfer::GetPointer<S_s_>(env, _sv2);
    S_s_ p2 = pp2 ? *pp2 : S_s_ {};
        
    typedef bool (*FuncToCall)(struct S_s_ p1, struct S_s_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SwitchActiveBuildTarget(UnityEditor.Build.NamedBuildTarget, UnityEditor.BuildTarget)bool w_bS_s_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_s_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(struct S_s_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.MPE.ChannelInfo, UnityEditor.MPE.ChannelInfo)bool w_bS_si4_S_si4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4_S_si4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_si4_* pp1 = DataTransfer::GetPointer<S_si4_>(env, _sv1);
    S_si4_ p1 = pp1 ? *pp1 : S_si4_ {};
        
     // LuaValToCSVal struct
    S_si4_* pp2 = DataTransfer::GetPointer<S_si4_>(env, _sv2);
    S_si4_ p2 = pp2 ? *pp2 : S_si4_ {};
        
    typedef bool (*FuncToCall)(struct S_si4_ p1, struct S_si4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Implicit(UnityEditor.Search.StringView)bool w_bS_si4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_si4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.MPE.ChannelClientInfo, UnityEditor.MPE.ChannelClientInfo)bool w_bS_si4i4_S_si4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_S_si4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
     // LuaValToCSVal struct
    S_si4i4_* pp2 = DataTransfer::GetPointer<S_si4i4_>(env, _sv2);
    S_si4i4_ p2 = pp2 ? *pp2 : S_si4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_si4i4_ p1, struct S_si4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.Search.StringView, System.String)bool w_bS_si4i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4i4_s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_si4i4_* pp1 = DataTransfer::GetPointer<S_si4i4_>(env, _sv1);
    S_si4i4_ p1 = pp1 ? *pp1 : S_si4i4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(struct S_si4i4_ p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Security.Cryptography.CngProperty, System.Security.Cryptography.CngProperty)bool w_bS_si4oN_bi4__S_si4oN_bi4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_si4oN_bi4__S_si4oN_bi4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_si4oN_bi4__* pp1 = DataTransfer::GetPointer<S_si4oN_bi4__>(env, _sv1);
    S_si4oN_bi4__ p1 = pp1 ? *pp1 : S_si4oN_bi4__ {};
        
     // LuaValToCSVal struct
    S_si4oN_bi4__* pp2 = DataTransfer::GetPointer<S_si4oN_bi4__>(env, _sv2);
    S_si4oN_bi4__ p2 = pp2 ? *pp2 : S_si4oN_bi4__ {};
        
    typedef bool (*FuncToCall)(struct S_si4oN_bi4__ p1, struct S_si4oN_bi4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ShouldShowAnimationWindowCurve(UnityEditor.EditorCurveBinding)bool w_bS_sosi4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sosi4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.EditorCurveBinding, UnityEditor.EditorCurveBinding)bool w_bS_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sosi4i4i4i4i4i4i4_S_sosi4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv2);
    S_sosi4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_sosi4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, struct S_sosi4i4i4i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CurveExists(UnityEditor.EditorCurveBinding, UnityEditorInternal.AnimationWindowCurve[])bool w_bS_sosi4i4i4i4i4i4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sosi4i4i4i4i4i4i4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv1);
    S_sosi4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(struct S_sosi4i4i4i4i4i4i4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.Experimental.AssetMoveInfo, UnityEditor.Experimental.AssetMoveInfo)bool w_bS_ss_S_ss_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_ss_S_ss_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_ss_* pp1 = DataTransfer::GetPointer<S_ss_>(env, _sv1);
    S_ss_ p1 = pp1 ? *pp1 : S_ss_ {};
        
     // LuaValToCSVal struct
    S_ss_* pp2 = DataTransfer::GetPointer<S_ss_>(env, _sv2);
    S_ss_ p2 = pp2 ? *pp2 : S_ss_ {};
        
    typedef bool (*FuncToCall)(struct S_ss_ p1, struct S_ss_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.ShaderMessage, UnityEditor.ShaderMessage)bool w_bS_sssi4i4i4_S_sssi4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_sssi4i4i4_S_sssi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_sssi4i4i4_* pp1 = DataTransfer::GetPointer<S_sssi4i4i4_>(env, _sv1);
    S_sssi4i4i4_ p1 = pp1 ? *pp1 : S_sssi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_sssi4i4i4_* pp2 = DataTransfer::GetPointer<S_sssi4i4i4_>(env, _sv2);
    S_sssi4i4i4_ p2 = pp2 ? *pp2 : S_sssi4i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_sssi4i4i4_ p1, struct S_sssi4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.InputFeatureUsage, UnityEngine.XR.InputFeatureUsage)bool w_bS_su4_S_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_su4_S_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_su4_* pp1 = DataTransfer::GetPointer<S_su4_>(env, _sv1);
    S_su4_ p1 = pp1 ? *pp1 : S_su4_ {};
        
     // LuaValToCSVal struct
    S_su4_* pp2 = DataTransfer::GetPointer<S_su4_>(env, _sv2);
    S_su4_ p2 = pp2 ? *pp2 : S_su4_ {};
        
    typedef bool (*FuncToCall)(struct S_su4_ p1, struct S_su4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsKeywordLocal(UnityEngine.Rendering.ShaderKeyword)bool w_bS_su4bbb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_su4bbb_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_su4bbb_* pp1 = DataTransfer::GetPointer<S_su4bbb_>(env, _sv1);
    S_su4bbb_ p1 = pp1 ? *pp1 : S_su4bbb_ {};
        
    typedef bool (*FuncToCall)(struct S_su4bbb_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.DepthState, UnityEngine.Rendering.DepthState)bool w_bS_u1i1_S_u1i1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1i1_S_u1i1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u1i1_* pp1 = DataTransfer::GetPointer<S_u1i1_>(env, _sv1);
    S_u1i1_ p1 = pp1 ? *pp1 : S_u1i1_ {};
        
     // LuaValToCSVal struct
    S_u1i1_* pp2 = DataTransfer::GetPointer<S_u1i1_>(env, _sv2);
    S_u1i1_ p2 = pp2 ? *pp2 : S_u1i1_ {};
        
    typedef bool (*FuncToCall)(struct S_u1i1_ p1, struct S_u1i1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Buffers.StandardFormat, System.Buffers.StandardFormat)bool w_bS_u1u1_S_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1_S_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1_>(env, _sv1);
    S_u1u1_ p1 = pp1 ? *pp1 : S_u1u1_ {};
        
     // LuaValToCSVal struct
    S_u1u1_* pp2 = DataTransfer::GetPointer<S_u1u1_>(env, _sv2);
    S_u1u1_ p2 = pp2 ? *pp2 : S_u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_u1u1_ p1, struct S_u1u1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TakesSingleByteArgument(System.Reflection.Emit.OpCode)bool w_bS_u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Reflection.Emit.OpCode, System.Reflection.Emit.OpCode)bool w_bS_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1_>(env, _sv2);
    S_u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1_ p1, struct S_u1u1u1u1u1u1u1u1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.StencilState, UnityEngine.Rendering.StencilState)bool w_bS_u1u1u1u1u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_u1u1u1u1u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_u1u1u1u1u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_u1u1u1u1u1u1u1u1u1u1u1u1_>(env, _sv2);
    S_u1u1u1u1u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_u1u1u1u1u1u1u1u1u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ p1, struct S_u1u1u1u1u1u1u1u1u1u1u1u1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsCategoryEnabled(Unity.Profiling.ProfilerCategory)bool w_bS_u2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u2_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u2_* pp1 = DataTransfer::GetPointer<S_u2_>(env, _sv1);
    S_u2_ p1 = pp1 ? *pp1 : S_u2_ {};
        
    typedef bool (*FuncToCall)(struct S_u2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord, UnityEngine.TextCore.LowLevel.GlyphAdjustmentRecord)bool w_bS_u4S_r4r4r4r4__S_u4S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4S_r4r4r4r4__S_u4S_r4r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(env, _sv1);
    S_u4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_u4S_r4r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_u4S_r4r4r4r4__* pp2 = DataTransfer::GetPointer<S_u4S_r4r4r4r4__>(env, _sv2);
    S_u4S_r4r4r4r4__ p2 = pp2 ? *pp2 : S_u4S_r4r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_u4S_r4r4r4r4__ p1, struct S_u4S_r4r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.GraphicsBufferHandle, UnityEngine.GraphicsBufferHandle)bool w_bS_u4_S_u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4_S_u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u4_* pp1 = DataTransfer::GetPointer<S_u4_>(env, _sv1);
    S_u4_ p1 = pp1 ? *pp1 : S_u4_ {};
        
     // LuaValToCSVal struct
    S_u4_* pp2 = DataTransfer::GetPointer<S_u4_>(env, _sv2);
    S_u4_ p2 = pp2 ? *pp2 : S_u4_ {};
        
    typedef bool (*FuncToCall)(struct S_u4_ p1, struct S_u4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.HapticCapabilities, UnityEngine.XR.HapticCapabilities)bool w_bS_u4bbu4u4u4_S_u4bbu4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4bbu4u4u4_S_u4bbu4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u4bbu4u4u4_* pp1 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(env, _sv1);
    S_u4bbu4u4u4_ p1 = pp1 ? *pp1 : S_u4bbu4u4u4_ {};
        
     // LuaValToCSVal struct
    S_u4bbu4u4u4_* pp2 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(env, _sv2);
    S_u4bbu4u4u4_ p2 = pp2 ? *pp2 : S_u4bbu4u4u4_ {};
        
    typedef bool (*FuncToCall)(struct S_u4bbu4u4u4_ p1, struct S_u4bbu4u4u4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Rendering.PassIdentifier, UnityEngine.Rendering.PassIdentifier)bool w_bS_u4u4_S_u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4_S_u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4_>(env, _sv1);
    S_u4u4_ p1 = pp1 ? *pp1 : S_u4u4_ {};
        
     // LuaValToCSVal struct
    S_u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4_>(env, _sv2);
    S_u4u4_ p2 = pp2 ? *pp2 : S_u4u4_ {};
        
    typedef bool (*FuncToCall)(struct S_u4u4_ p1, struct S_u4u4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEditor.GUID, UnityEditor.GUID)bool w_bS_u4u4u4u4_S_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4u4u4u4_S_u4u4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp1 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv1);
    S_u4u4u4u4_ p1 = pp1 ? *pp1 : S_u4u4u4u4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, _sv2);
    S_u4u4u4u4_ p2 = pp2 ? *pp2 : S_u4u4u4u4_ {};
        
    typedef bool (*FuncToCall)(struct S_u4u4u4u4_ p1, struct S_u4u4u4u4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_LessThan(UnityEditor.Search.PropertyDatabaseRecordKey, UnityEditor.Search.PropertyDatabaseRecordKey)bool w_bS_u8S_u8u8__S_u8S_u8u8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8S_u8u8__S_u8S_u8u8__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8S_u8u8__* pp1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, _sv1);
    S_u8S_u8u8__ p1 = pp1 ? *pp1 : S_u8S_u8u8__ {};
        
     // LuaValToCSVal struct
    S_u8S_u8u8__* pp2 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, _sv2);
    S_u8S_u8u8__ p2 = pp2 ? *pp2 : S_u8S_u8u8__ {};
        
    typedef bool (*FuncToCall)(struct S_u8S_u8u8__ p1, struct S_u8S_u8u8__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(System.DateTime)bool w_bS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef bool (*FuncToCall)(struct S_u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(System.DateTime, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bS_u8_S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(struct S_u8_ p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.DateTime, System.DateTime)bool w_bS_u8_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_S_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
    typedef bool (*FuncToCall)(struct S_u8_ p1, struct S_u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDaylightSavingTime(System.DateTime, System.Globalization.DaylightTime)bool w_bS_u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(struct S_u8_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.InputDevice, UnityEngine.XR.InputDevice)bool w_bS_u8b_S_u8b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8b_S_u8b_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8b_* pp1 = DataTransfer::GetPointer<S_u8b_>(env, _sv1);
    S_u8b_ p1 = pp1 ? *pp1 : S_u8b_ {};
        
     // LuaValToCSVal struct
    S_u8b_* pp2 = DataTransfer::GetPointer<S_u8b_>(env, _sv2);
    S_u8b_ p2 = pp2 ? *pp2 : S_u8b_ {};
        
    typedef bool (*FuncToCall)(struct S_u8b_ p1, struct S_u8b_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CheckFenceIsDependencyOrDidSyncFence(Unity.Jobs.JobHandle, Unity.Jobs.JobHandle)bool w_bS_u8i4i4p_S_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8i4i4p_S_u8i4i4p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8i4i4p_* pp1 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv1);
    S_u8i4i4p_ p1 = pp1 ? *pp1 : S_u8i4i4p_ {};
        
     // LuaValToCSVal struct
    S_u8i4i4p_* pp2 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv2);
    S_u8i4i4p_ p2 = pp2 ? *pp2 : S_u8i4i4p_ {};
        
    typedef bool (*FuncToCall)(struct S_u8i4i4p_ p1, struct S_u8i4i4p_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.XR.Hand, UnityEngine.XR.Hand)bool w_bS_u8u4_S_u8u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u4_S_u8u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8u4_* pp1 = DataTransfer::GetPointer<S_u8u4_>(env, _sv1);
    S_u8u4_ p1 = pp1 ? *pp1 : S_u8u4_ {};
        
     // LuaValToCSVal struct
    S_u8u4_* pp2 = DataTransfer::GetPointer<S_u8u4_>(env, _sv2);
    S_u8u4_ p2 = pp2 ? *pp2 : S_u8u4_ {};
        
    typedef bool (*FuncToCall)(struct S_u8u4_ p1, struct S_u8u4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetArtifactPaths(UnityEngine.Hash128, System.String[] ByRef)bool w_bS_u8u8_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(struct S_u8u8_ p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(UnityEngine.Hash128, UnityEngine.Hash128)bool w_bS_u8u8_S_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8u8_S_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
     // LuaValToCSVal struct
    S_u8u8_* pp2 = DataTransfer::GetPointer<S_u8u8_>(env, _sv2);
    S_u8u8_ p2 = pp2 ? *pp2 : S_u8u8_ {};
        
    typedef bool (*FuncToCall)(struct S_u8u8_ p1, struct S_u8u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Object)bool w_bTO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bTO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Boolean)bool w_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Boolean, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bbS_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbS_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(Boolean, UnityEngine.GUILayoutOption[])bool w_bbVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbVo");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean StartRecording(Boolean, Boolean)bool w_bbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbb");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(bool p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, UnityEngine.GUIContent)bool w_bbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbo");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginFoldoutHeaderGroup(Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle)bool w_bboDoDoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bboDoDoDo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(Boolean, UnityEngine.Texture, UnityEngine.GUILayoutOption[])bool w_bboVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bboVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, UnityEngine.GUIContent, Boolean)bool w_bbob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbob");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle)bool w_bbobo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbobo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_bboo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bboo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(Boolean, UnityEngine.Texture, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_bbooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbooVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, System.String)bool w_bbs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbs");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginFoldoutHeaderGroup(Boolean, System.String, UnityEngine.GUIStyle, System.Action`1[UnityEngine.Rect], UnityEngine.GUIStyle)bool w_bbsDoDoDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbsDoDoDo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(Boolean, System.String, UnityEngine.GUILayoutOption[])bool w_bbsVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbsVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, System.String, Boolean)bool w_bbsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbsb");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, System.String, Boolean, UnityEngine.GUIStyle)bool w_bbsbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbsbo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Foldout(Boolean, System.String, UnityEngine.GUIStyle)bool w_bbso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbso");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(Boolean, System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_bbsoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbsoVo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDigit(Char)bool w_bc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsSurrogatePair(Char, Char)bool w_bcc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bcc");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppChar>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppChar p1, Il2CppChar p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(SByte)bool w_bi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi1");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(int8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(SByte, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bi1S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi1S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(int8_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Int16)bool w_bi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi2");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(int16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Int16, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bi2S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi2S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(int16_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Int32)bool w_bi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetObjectIdentifier(Int32, UnityEditor.Build.Content.ObjectIdentifier ByRef)bool w_bi4PS_S_u4u4u4u4_i8i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PS_S_u4u4u4u4_i8i4s_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Pstruct
    S_S_u4u4u4u4_i8i4s_* p2 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u4u4u4u4_i8i4s_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGUIDAndLocalFileIdentifier(Int32, System.String ByRef, Int32 ByRef)bool w_bi4PsPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PsPi4");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(int32_t p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGUIDAndLocalFileIdentifier(Int32, System.String ByRef, Int64 ByRef)bool w_bi4PsPi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PsPi8");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(int32_t p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetAdditionalBakedProbes(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.SphericalHarmonicsL2], Unity.Collections.NativeArray`1[System.Single])bool w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(int32_t p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetAdditionalBakedProbes(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.SphericalHarmonicsL2], Unity.Collections.NativeArray`1[System.Single], Unity.Collections.NativeArray`1[System.Single])bool w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp3 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv3);
    S_Pvi4i4i4S_pi4i4_i4_ p3 = pp3 ? *pp3 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp4 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv4);
    S_Pvi4i4i4S_pi4i4_i4_ p4 = pp4 ? *pp4 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef bool (*FuncToCall)(int32_t p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, struct S_Pvi4i4i4S_pi4i4_i4_ p3, struct S_Pvi4i4i4S_pi4i4_i4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Int32, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bi4S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(int32_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetAdditionalBakedProbes(Int32, System.Span`1[UnityEngine.Rendering.SphericalHarmonicsL2], System.Span`1[System.Single], System.Span`1[System.Single])bool w_bi4S_S_p_i4_S_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_S_p_i4_S_S_p_i4_S_S_p_i4_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp4 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv4);
    S_S_p_i4_ p4 = pp4 ? *pp4 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(int32_t p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, struct S_S_p_i4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DoTreeViewButton(Int32, UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_bi4S_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4S_r4r4r4r4_oo");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetMaxThreads(Int32, Int32)bool w_bi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean OpenAsset(Int32, Int32, Int32)bool w_bi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ForAll(Int32, Int32, System.Predicate`1[System.Int32])bool w_bi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4o");
    
    auto TIp3 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean HasHandler(Int32, System.Delegate)bool w_bi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4o");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean StartRecordScreen(UnityEngine.RecordScreenTextureFormat, IntPtr)bool w_bi4p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4p");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef bool (*FuncToCall)(int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetDialogOptOutDecision(UnityEditor.DialogOptOutDecisionType, System.String)bool w_bi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4s");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Int64)bool w_bi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Int64, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_bi8S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(int64_t p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_LessThan(Int64, System.Numerics.BigInteger)bool w_bi8S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8S_i4o_");
    
    auto TIp2 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
    typedef bool (*FuncToCall)(int64_t p1, struct S_i4o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryStartNoGCRegion(Int64, Boolean)bool w_bi8b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(int64_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryStartNoGCRegion(Int64, Int64)bool w_bi8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(int64_t p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryStartNoGCRegion(Int64, Int64, Boolean)bool w_bi8i8b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8i8b");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(int64_t p1, int64_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsFirstRun(System.ActivationContext)bool w_bo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsNotGenericOrValidGeneric(System.Reflection.MethodInfo, System.Reflection.ParameterInfo[])bool w_boDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean MakeEditable(System.String[], System.String, System.Collections.Generic.List`1[System.String])bool w_boDsDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boDsDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDefined(System.Type, System.Object)bool w_boO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsValid(System.Type, System.Object, System.ComponentModel.License ByRef)bool w_boOPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boOPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ExpandoTryDeleteValue(System.Dynamic.ExpandoObject, System.Object, Int32, System.String, Boolean)bool w_boOi4sb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boOi4sb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, bool p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ExpandoTryGetValue(System.Dynamic.ExpandoObject, System.Object, Int32, System.String, Boolean, System.Object ByRef)bool w_boOi4sbPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boOi4sbPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up6 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv6)); // object ret
    Il2CppObject** p6 = &up6;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, bool p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SetManagedReferenceIdForObject(UnityEngine.Object, System.Object, Int64)bool w_boOi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boOi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int64_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryCreatePlaneFromPolygon(UnityEngine.Vector3[], UnityEngine.Plane ByRef)bool w_boPS_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_S_r4r4r4_r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_r4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetObjectIdentifier(UnityEngine.Object, UnityEditor.Build.Content.ObjectIdentifier ByRef)bool w_boPS_S_u4u4u4u4_i8i4s_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_S_u4u4u4u4_i8i4s_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_S_u4u4u4u4_i8i4s_* p2 = DataTransfer::GetPointer<S_S_u4u4u4u4_i8i4s_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u4u4u4u4_i8i4s_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PassHasKeyword(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEngine.Rendering.LocalKeyword ByRef)bool w_boPS_u4u4_PS_S_p_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_u4u4_PS_S_p_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_u4u4_* p2 = DataTransfer::GetPointer<S_u4u4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u4u4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_S_p_su4_* p3 = DataTransfer::GetPointer<S_S_p_su4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_p_su4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PassHasKeyword(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEngine.Rendering.LocalKeyword ByRef, UnityEditor.Rendering.ShaderType)bool w_boPS_u4u4_PS_S_p_su4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_u4u4_PS_S_p_su4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_u4u4_* p2 = DataTransfer::GetPointer<S_u4u4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u4u4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_S_p_su4_* p3 = DataTransfer::GetPointer<S_S_p_su4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_p_su4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PassHasKeyword(UnityEngine.Shader, UnityEngine.Rendering.PassIdentifier ByRef, UnityEngine.Rendering.LocalKeyword ByRef, UnityEditor.Rendering.ShaderType, UnityEditor.Rendering.ShaderCompilerPlatform)bool w_boPS_u4u4_PS_S_p_su4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPS_u4u4_PS_S_p_su4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Pstruct
    S_u4u4_* p2 = DataTransfer::GetPointer<S_u4u4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u4u4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal Pstruct
    S_S_p_su4_* p3 = DataTransfer::GetPointer<S_S_p_su4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_S_p_su4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGizmoInfo(System.Type, UnityEditor.GizmoInfo ByRef)bool w_boPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryConvertToDouble(UnityEditor.Search.SearchItem, Double ByRef, System.String)bool w_boPr8Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPr8Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ValidateTextureStack(UnityEngine.Texture[], System.String ByRef)bool w_boPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGUIDAndLocalFileIdentifier(UnityEngine.Object, System.String ByRef, Int32 ByRef)bool w_boPsPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPsPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGUIDAndLocalFileIdentifier(UnityEngine.Object, System.String ByRef, Int64 ByRef)bool w_boPsPi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPsPi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetXmlElementForInteropType(System.Type, System.String ByRef, System.String ByRef)bool w_boPsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CanOpenForEdit(UnityEngine.Object, System.String ByRef, UnityEditor.StatusQueryOptions)bool w_boPsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boPsi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Check(UnityEditor.Search.SearchExpression, UnityEditor.Search.SearchExpressionContext)bool w_boS_S_oooo_ooi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_S_oooo_ooi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_S_oooo_ooi4_* pp2 = DataTransfer::GetPointer<S_S_oooo_ooi4_>(env, _sv2);
    S_S_oooo_ooi4_ p2 = pp2 ? *pp2 : S_S_oooo_ooi4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_S_oooo_ooi4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TestPlanesAABB(UnityEngine.Plane[], UnityEngine.Bounds)bool w_boS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsTouching(UnityEngine.Collider2D, UnityEngine.ContactFilter2D)bool w_boS_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv2);
    S_bbbbbbS_i4_r4r4r4r4_ p2 = pp2 ? *pp2 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_bbbbbbS_i4_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CanMoveTransformToScene(UnityEngine.Transform, UnityEngine.SceneManagement.Scene)bool w_boS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UpdateNavMeshData(UnityEngine.AI.NavMeshData, UnityEngine.AI.NavMeshBuildSettings, System.Collections.Generic.List`1[UnityEngine.AI.NavMeshBuildSource], UnityEngine.Bounds)bool w_boS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__oS_S_r4r4r4_S_r4r4r4__");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__* pp2 = DataTransfer::GetPointer<S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__>(env, _sv2);
    S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p2 = pp2 ? *pp2 : S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp4 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv4);
    S_S_r4r4r4_S_r4r4r4__ p4 = pp4 ? *pp4 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ p2, Il2CppObject* p3, struct S_S_r4r4r4_S_r4r4r4__ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SpinUntil(System.Func`1[System.Boolean], System.TimeSpan)bool w_boS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WaitAll(System.Threading.WaitHandle[], System.TimeSpan, Boolean)bool w_boS_i8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_i8_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_i8_ p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2)bool w_boS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera)bool w_boS_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ScreenPointToLocalPointInRectangle(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector2 ByRef)bool w_boS_r4r4_oPS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oPS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p4 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ScreenPointToWorldPointInRectangle(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector3 ByRef)bool w_boS_r4r4_oPS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oPS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p4 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_r4r4r4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector4)bool w_boS_r4r4_oS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ComputePenetration(UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3 ByRef, Single ByRef)bool w_boS_r4r4r4_S_r4r4r4r4_oS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4r4_S_r4r4r4r4_oS_r4r4r4_S_r4r4r4r4_PS_r4r4r4_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv6);
    S_r4r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p7 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv7)); // valuetype ref
    S_r4r4r4_ up7;
    if (!p7) {
        memset(&up7, 0, sizeof(p7));
    }
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, Il2CppObject* p4, struct S_r4r4r4_ p5, struct S_r4r4r4r4_ p6, void* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GenerateSecondaryUVSet(UnityEngine.Mesh, UnityEditor.UnwrapParam)bool w_boS_r4r4r4r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4r4r4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4i4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4i4_>(env, _sv2);
    S_r4r4r4r4i4_ p2 = pp2 ? *pp2 : S_r4r4r4r4i4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsCurveCreated(UnityEngine.AnimationClip, UnityEditor.EditorCurveBinding)bool w_boS_sosi4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv2);
    S_sosi4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_sosi4i4i4i4i4i4i4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_sosi4i4i4i4i4i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetDiscreteIntValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding, Int32 ByRef)bool w_boS_sosi4i4i4i4i4i4i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv2);
    S_sosi4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_sosi4i4i4i4i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_sosi4i4i4i4i4i4i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetObjectReferenceValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding, UnityEngine.Object ByRef)bool w_boS_sosi4i4i4i4i4i4i4_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv2);
    S_sosi4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_sosi4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_sosi4i4i4i4i4i4i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetFloatValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding, Single ByRef)bool w_boS_sosi4i4i4i4i4i4i4_Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_sosi4i4i4i4i4i4i4_Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv2);
    S_sosi4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_sosi4i4i4i4i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_sosi4i4i4i4i4i4i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Texture, UnityEngine.GUILayoutOption[])bool w_boVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BeginToggleGroup(UnityEngine.GUIContent, Boolean)bool w_bob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bob");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.GUIContent, Boolean, UnityEngine.GUILayoutOption[])bool w_bobVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bobVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, bool p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(UnityEngine.GUIContent, Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_boboVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boboVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, bool p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Byte[], Int32)bool w_boi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WaitAll(System.Threading.Tasks.Task[], Int32, System.Threading.CancellationToken)bool w_boi4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, struct S_o_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DropdownButton(UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.GUILayoutOption[])bool w_boi4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4Vo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WaitAll(System.Threading.WaitHandle[], Int32, Boolean)bool w_boi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4b");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean OpenAsset(UnityEngine.Object, Int32, Int32)bool w_boi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ReformatCubemap(UnityEngine.Cubemap, Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean)bool w_boi4i4i4bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4i4bb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, bool p5, bool p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GenerateAtlas(UnityEngine.Vector2[], Int32, Int32, System.Collections.Generic.List`1[UnityEngine.Rect])bool w_boi4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAddGlyphsToTexture(System.Collections.Generic.List`1[System.UInt32], Int32, UnityEngine.TextCore.LowLevel.GlyphPackingMode, System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], UnityEngine.TextCore.LowLevel.GlyphRenderMode, UnityEngine.Texture2D, UnityEngine.TextCore.Glyph[] ByRef)bool w_boi4i4ooi4oPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4i4ooi4oPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up8 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv8)); // object ret
    Il2CppObject** p8 = &up8;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DropdownButton(UnityEngine.GUIContent, UnityEngine.FocusType, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_boi4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4oVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ConvertTexture(UnityEngine.Texture, Int32, UnityEngine.Texture, Int32)bool w_boi4oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4oi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ClearManagedReferenceWithMissingType(UnityEngine.Object, Int64)bool w_boi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.Type, System.Type)bool w_boo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryCreate(System.Uri, System.Uri, System.Uri ByRef)bool w_booPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsTouching(UnityEngine.Collider2D, UnityEngine.Collider2D, UnityEngine.ContactFilter2D)bool w_booS_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booS_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle, System.TimeSpan, Boolean)bool w_booS_i8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booS_i8_b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_i8_ p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(UnityEngine.Texture, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_booVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDefined(System.Reflection.MemberInfo, System.Type, Boolean)bool w_boob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PropertyField(UnityEditor.SerializedProperty, UnityEngine.GUIContent, Boolean, UnityEngine.GUILayoutOption[])bool w_boobVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boobVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsDerivedFrom(System.Xml.Schema.XmlSchemaType, System.Xml.Schema.XmlSchemaType, System.Xml.Schema.XmlSchemaDerivationMethod)bool w_booi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle, Int32, Boolean)bool w_booi4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booi4b");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryPackGlyphsInAtlas(System.Collections.Generic.List`1[UnityEngine.TextCore.Glyph], System.Collections.Generic.List`1[UnityEngine.TextCore.Glyph], Int32, UnityEngine.TextCore.LowLevel.GlyphPackingMode, UnityEngine.TextCore.LowLevel.GlyphRenderMode, Int32, Int32, System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect])bool w_booi4i4i4i4i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booi4i4i4i4i4oo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, Il2CppObject* p8, Il2CppObject* p9, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryAddGlyphsToTexture(System.Collections.Generic.List`1[UnityEngine.TextCore.Glyph], System.Collections.Generic.List`1[UnityEngine.TextCore.Glyph], Int32, UnityEngine.TextCore.LowLevel.GlyphPackingMode, System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], System.Collections.Generic.List`1[UnityEngine.TextCore.GlyphRect], UnityEngine.TextCore.LowLevel.GlyphRenderMode, UnityEngine.Texture2D)bool w_booi4i4ooi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booi4i4ooi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, int32_t p7, Il2CppObject* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean RegisterDynamicProperty(System.Runtime.Remoting.Contexts.IDynamicProperty, System.ContextBoundObject, System.Runtime.Remoting.Contexts.Context)bool w_booo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetSensorGateFrustum(UnityEngine.Camera, UnityEngine.Vector3[], UnityEngine.Vector3[], Single ByRef)bool w_boooPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boooPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Verify_v15(System.Security.Cryptography.RSA, System.Security.Cryptography.HashAlgorithm, Byte[], Byte[])bool w_boooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boooo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Verify_v15(System.Security.Cryptography.RSA, System.Security.Cryptography.HashAlgorithm, Byte[], Byte[], Boolean)bool w_boooob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boooob");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BlendCubemap(UnityEngine.Texture, UnityEngine.Texture, Single, UnityEngine.RenderTexture)bool w_boor4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boor4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BuildAssetBundle(UnityEngine.Object, UnityEngine.Object[], System.String, UInt32 ByRef, UnityEditor.BuildAssetBundleOptions, UnityEditor.BuildTarget)bool w_boosPu4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boosPu4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, void* p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BuildAssetBundle(UnityEngine.Object, UnityEngine.Object[], System.String, UnityEditor.BuildAssetBundleOptions, UnityEditor.BuildTarget)bool w_boosi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boosi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean tryPrimitiveArrayGet(System.Type, IntPtr, System.Object, Int32)bool w_bopOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bopOi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, Il2CppObject* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryPrimitiveArraySet(System.Type, IntPtr, System.Object, Int32, Int32)bool w_bopOi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bopOi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, void* p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CompareName(UnityEngine.Object, System.String)bool w_bos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bos");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean MatchSearchGroups(UnityEditor.Search.SearchContext, System.String, Boolean)bool w_bosDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosDb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.Type, System.String, System.Object ByRef)bool w_bosPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryCreate(System.Uri, System.String, System.Uri ByRef)bool w_bosPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetStat(UnityEngine.IntegratedSubsystem, System.String, Single ByRef)bool w_bosPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BumpMapTextureNeedsFixingInternal(UnityEngine.Material, System.String, Boolean)bool w_bosb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.Type, System.String, Boolean, System.Object ByRef)bool w_bosbPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosbPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, bool p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PropertyIsAnimatable(UnityEngine.Object, System.String, UnityEngine.Object)bool w_boso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsPersistantListenerValid(UnityEngine.Events.UnityEventBase, System.String, UnityEngine.Object, UnityEngine.Events.PersistentListenerMode, System.Type)bool w_bosoi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosoi4o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, Il2CppObject* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetFloatValue(UnityEngine.GameObject, System.String, System.Type, System.String, Single ByRef)bool w_bososPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bososPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppString* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WarnPrefab(UnityEngine.Object, System.String, System.String, System.String)bool w_bosss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(Mono.Math.BigInteger, UInt32)bool w_bou4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bou4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean BindHandle(IntPtr)bool w_bp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bp");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef bool (*FuncToCall)(void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetBooleanArrayElement(IntPtr, Int32)bool w_bpi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, System.Decimal ByRef)bool w_bpi4PS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4PS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_i4i4i4i4u8_* p3 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_i4i4i4i4u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, SByte ByRef)bool w_bpi4Pi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pi1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, Int16 ByRef)bool w_bpi4Pi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pi2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, Int32 ByRef)bool w_bpi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, Int64 ByRef)bool w_bpi4Pi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, Single ByRef)bool w_bpi4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_unpack_float2(IntPtr, Int32, Single ByRef, Single ByRef)bool w_bpi4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_unpack_float3(IntPtr, Int32, Single ByRef, Single ByRef, Single ByRef)bool w_bpi4Pr4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_unpack_float4(IntPtr, Int32, Single ByRef, Single ByRef, Single ByRef, Single ByRef)bool w_bpi4Pr4Pr4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr4Pr4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_unpack_float5(IntPtr, Int32, Single ByRef, Single ByRef, Single ByRef, Single ByRef, Single ByRef)bool w_bpi4Pr4Pr4Pr4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr4Pr4Pr4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, void* p5, void* p6, void* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_unpack_float6(IntPtr, Int32, Single ByRef, Single ByRef, Single ByRef, Single ByRef, Single ByRef, Single ByRef)bool w_bpi4Pr4Pr4Pr4Pr4Pr4Pr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr4Pr4Pr4Pr4Pr4Pr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
 // LuaValToCSVal P any
    void* p8 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, Double ByRef)bool w_bpi4Pr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, Byte ByRef)bool w_bpi4Pu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pu1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_unpack_decimal(IntPtr, Int32, Byte ByRef, Byte ByRef, Int32 ByRef, UInt64 ByRef)bool w_bpi4Pu1Pu1Pi4Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pu1Pu1Pi4Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, void* p4, void* p5, void* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, UInt16 ByRef)bool w_bpi4Pu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pu2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, UInt32 ByRef)bool w_bpi4Pu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnPack(IntPtr, Int32, UInt64 ByRef)bool w_bpi4Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, System.Decimal)bool w_bpi4S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4S_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp3 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv3);
    S_i4i4i4i4u8_ p3 = pp3 ? *pp3 : S_i4i4i4i4u8_ {};
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, struct S_i4i4i4i4u8_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, SByte)bool w_bpi4i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4i1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int8_t p3 = converter::Converter<int8_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, int8_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, Int16)bool w_bpi4i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4i2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int16_t p3 = converter::Converter<int16_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, int16_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, Int32)bool w_bpi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, Int64)bool w_bpi4i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4i8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, int64_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, Single)bool w_bpi4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_pack_float2(IntPtr, Int32, Single, Single)bool w_bpi4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, float p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_pack_float3(IntPtr, Int32, Single, Single, Single)bool w_bpi4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, float p3, float p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_pack_float4(IntPtr, Int32, Single, Single, Single, Single)bool w_bpi4r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, float p3, float p4, float p5, float p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_pack_float5(IntPtr, Int32, Single, Single, Single, Single, Single)bool w_bpi4r4r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r4r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, float p3, float p4, float p5, float p6, float p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_pack_float6(IntPtr, Int32, Single, Single, Single, Single, Single, Single)bool w_bpi4r4r4r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r4r4r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, float p3, float p4, float p5, float p6, float p7, float p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, Double)bool w_bpi4r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4r8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<double>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    double p3 = converter::Converter<double>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, double p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean LoadField(IntPtr, Int32, System.String)bool w_bpi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef bool (*FuncToCall)(void* p1, int32_t p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean xlua_is_eq_str(IntPtr, Int32, System.String, Int32)bool w_bpi4si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4si4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, Il2CppString* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, Byte)bool w_bpi4u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4u1");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, uint8_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, UInt16)bool w_bpi4u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4u2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, uint16_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, UInt32)bool w_bpi4u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4u4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Pack(IntPtr, Int32, UInt64)bool w_bpi4u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpi4u8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(void* p1, int32_t p2, uint64_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(IntPtr, IntPtr)bool w_bpp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpp");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
    typedef bool (*FuncToCall)(void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CallBooleanMethodUnsafe(IntPtr, IntPtr, UnityEngine.jvalue*)bool w_bppPS_bi1ci2i4i8r4r8p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bppPS_bi1ci2i4i8r4r8p_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_bi1ci2i4i8r4r8p_* p3 = DataTransfer::GetPointer<S_bi1ci2i4i8r4r8p_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_bi1ci2i4i8r4r8p_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(void* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CallBooleanMethod(IntPtr, IntPtr, System.Span`1[UnityEngine.jvalue])bool w_bppS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bppS_S_p_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(void* p1, void* p2, struct S_S_p_i4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CallBooleanMethod(IntPtr, IntPtr, UnityEngine.jvalue[])bool w_bppo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bppo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void* p1, void* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Single)bool w_br4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Single, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_br4S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(float p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(Single, Single)bool w_br4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AreAlmostEqualUlps(Single, Single, Int32)bool w_br4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4i4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(float p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AreEqual(Single, Single, Single)bool w_br4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(float p1, float p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ShowCameraPreviewAt(Single, Single, Single, Single)bool w_br4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4r4r4");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(Double)bool w_br8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef bool (*FuncToCall)(double p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFormat(Double, System.Span`1[System.Byte], Int32 ByRef, System.Buffers.StandardFormat)bool w_br8S_S_p_i4_Pi4DS_u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br8S_S_p_i4_Pi4DS_u1u1_");
    
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(double p1, struct S_S_p_i4_ p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(Double, Double)bool w_br8r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br8r8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(double p1, double p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AreAlmostEqualUlps(Double, Double, Int64)bool w_br8r8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br8r8i8");
    

    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(double p1, double p2, int64_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsNullOrEmpty(System.String)bool w_bs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bs");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef bool (*FuncToCall)(Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CancelRequest(System.String, System.String)bool w_bsDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsDs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean QueueConfig(System.String, System.Object, Int32, System.String)bool w_bsODi4Ds(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsODi4Ds");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.DateTimeOffset ByRef)bool w_bsPS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p2 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u8_i2_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, UnityEditor.GlobalObjectId ByRef)bool w_bsPS_S_u8u8_S_u4u4u4u4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_S_u8u8_S_u4u4u4u4_i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_S_u8u8_S_u4u4u4u4_i4_* p2 = DataTransfer::GetPointer<S_S_u8u8_S_u4u4u4u4_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_u8u8_S_u4u4u4u4_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Guid ByRef)bool w_bsPS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Decimal ByRef)bool w_bsPS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_i4i4i4i4u8_* p2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4i4u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Numerics.BigInteger ByRef)bool w_bsPS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_i4o_* p2 = DataTransfer::GetPointer<S_i4o_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4o_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.TimeSpan ByRef)bool w_bsPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_i8_* p2 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseHtmlString(System.String, UnityEngine.Color ByRef)bool w_bsPS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindDevice(System.String, UnityEditor.Hardware.DevDevice ByRef)bool w_bsPS_ssssi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_ssssi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_ssssi4i4_* p2 = DataTransfer::GetPointer<S_ssssi4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_ssssi4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, UnityEditor.GUID ByRef)bool w_bsPS_u4u4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u4u4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_u4u4u4u4_* p2 = DataTransfer::GetPointer<S_u4u4u4u4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u4u4u4u4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.DateTime ByRef)bool w_bsPS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_u8_* p2 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetHashForAssetBundle(System.String, UnityEngine.Hash128 ByRef)bool w_bsPS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_u8u8_* p2 = DataTransfer::GetPointer<S_u8u8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_u8u8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Boolean ByRef)bool w_bsPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPropertyOptionalBool(System.String, Boolean ByRef, UnityEditor.BuildTargetGroup)bool w_bsPbi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPbi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Char ByRef)bool w_bsPc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPc");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, SByte ByRef)bool w_bsPi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Int16 ByRef)bool w_bsPi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Int32 ByRef)bool w_bsPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetPropertyOptionalInt(System.String, Int32 ByRef, UnityEditor.BuildTargetGroup)bool w_bsPi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Int64 ByRef)bool w_bsPi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Version ByRef)bool w_bsPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Single ByRef)bool w_bsPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Double ByRef)bool w_bsPr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CanOpenForEdit(System.String, System.String ByRef)bool w_bsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DecodeXmlNamespaceForClrTypeNamespace(System.String, System.String ByRef, System.String ByRef)bool w_bsPsPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsPs");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
     // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetLocalFileSystemName(System.String, System.String ByRef, UInt64 ByRef, UInt64 ByRef)bool w_bsPsPu8Pu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsPu8Pu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsOpenForEdit(System.String, System.String ByRef, UnityEditor.StatusQueryOptions)bool w_bsPsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPsi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, Byte ByRef)bool w_bsPu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, UInt16 ByRef)bool w_bsPu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, UInt32 ByRef)bool w_bsPu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, UInt64 ByRef)bool w_bsPu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryFromBase64String(System.String, System.Span`1[System.Byte], Int32 ByRef)bool w_bsS_S_p_i4_Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_S_p_i4_Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color)bool w_bsS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color, UnityEngine.FullScreenMovieControlMode)bool w_bsS_r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color, UnityEngine.FullScreenMovieControlMode, UnityEngine.FullScreenMovieScalingMode)bool w_bsS_r4r4r4r4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean op_Equality(System.String, UnityEditor.Search.StringView)bool w_bsS_si4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_si4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_si4i4_* pp2 = DataTransfer::GetPointer<S_si4i4_>(env, _sv2);
    S_si4i4_ p2 = pp2 ? *pp2 : S_si4i4_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_si4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ClearCachedVersion(System.String, UnityEngine.Hash128)bool w_bsS_u8u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_u8u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_u8u8_* pp2 = DataTransfer::GetPointer<S_u8u8_>(env, _sv2);
    S_u8u8_ p2 = pp2 ? *pp2 : S_u8u8_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_u8u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(System.String, UnityEngine.GUILayoutOption[])bool w_bsVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetBool(System.String, Boolean)bool w_bsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(System.String, Boolean, UnityEngine.GUILayoutOption[])bool w_bsbVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsbVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, bool p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CompileEditorScriptsSyncPure(System.String, Boolean, UnityEditor.BuildTargetGroup, UnityEditor.BuildTarget, Int32)bool w_bsbi4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsbi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Toggle(System.String, Boolean, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_bsboVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsboVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, bool p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsControl(System.String, Int32)bool w_bsi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryOpenExisting(System.String, System.Security.AccessControl.EventWaitHandleRights, System.Threading.EventWaitHandle ByRef)bool w_bsi4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean PrefetchSocketPolicy(System.String, Int32, Int32)bool w_bsi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CompilePlayerScriptsSyncPure(System.String, UnityEditor.BuildOptions, UnityEditor.BuildTargetGroup, UnityEditor.BuildTarget, Int32)bool w_bsi4i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4i4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, System.Decimal ByRef)bool w_bsi4oPS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPS_i4i4i4i4u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i4i4i4i4u8_* p4 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i4i4i4i4u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, System.Numerics.BigInteger ByRef)bool w_bsi4oPS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPS_i4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i4o_* p4 = DataTransfer::GetPointer<S_i4o_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i4o_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, SByte ByRef)bool w_bsi4oPi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Int16 ByRef)bool w_bsi4oPi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Int32 ByRef)bool w_bsi4oPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Int64 ByRef)bool w_bsi4oPi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPi8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Single ByRef)bool w_bsi4oPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Double ByRef)bool w_bsi4oPr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPr8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, Byte ByRef)bool w_bsi4oPu1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu1");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, UInt16 ByRef)bool w_bsi4oPu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu2");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, UInt32 ByRef)bool w_bsi4oPu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.Globalization.NumberStyles, System.IFormatProvider, UInt64 ByRef)bool w_bsi4oPu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4oPu8");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean ToBoolean(System.String, System.IFormatProvider)bool w_bso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bso");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.IFormatProvider, System.TimeSpan ByRef)bool w_bsoPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_i8_* p3 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_i8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean SaveCursorToFile(System.String, UnityEngine.Texture2D, UnityEngine.Vector2)bool w_bsoS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoS_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, struct S_r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Button(System.String, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_bsoVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoVo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean StaticFlagField(System.String, UnityEditor.SerializedProperty, Int32)bool w_bsoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef)bool w_bsoi4PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p4 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_S_u8_i2_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)bool w_bsoi4PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean UnregisterDynamicProperty(System.String, System.ContextBoundObject, System.Runtime.Remoting.Contexts.Context)bool w_bsoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.TimeSpan ByRef)bool w_bsooPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsooPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef)bool w_bsooi4PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p5 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_u8_i2_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef)bool w_bsooi4PS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_i8_* p5 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_i8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)bool w_bsooi4PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_u8_* p5 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_u8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.String, System.String)bool w_bss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FuzzyMatch(System.String, System.String, System.Collections.Generic.List`1[System.Int32])bool w_bssDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssDo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String, System.Guid ByRef)bool w_bssPS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p3 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FuzzyMatch(System.String, System.String, Int64 ByRef, System.Collections.Generic.List`1[System.Int32])bool w_bssPi8Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssPi8Do");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, void* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean StringsEqual(System.String, System.String, Boolean)bool w_bssb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssb");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.String, System.String, System.StringComparison)bool w_bssi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsMatch(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)bool w_bssi4S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4S_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, struct S_i8_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.TimeSpan ByRef)bool w_bssoPS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssoPS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal Pstruct
    S_i8_* p4 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv4)); // valuetype ref
    S_i8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTimeOffset ByRef)bool w_bssoi4PS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_S_u8_i2_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_S_u8_i2_* p5 = DataTransfer::GetPointer<S_S_u8_i2_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_S_u8_i2_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.TimeSpanStyles, System.TimeSpan ByRef)bool w_bssoi4PS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_i8_* p5 = DataTransfer::GetPointer<S_i8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_i8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef)bool w_bssoi4PS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_u8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal Pstruct
    S_u8_* p5 = DataTransfer::GetPointer<S_u8_>(env, pesapi_unboxing(env, _sv5)); // valuetype ref
    S_u8_ up5;
    if (!p5) {
        memset(&up5, 0, sizeof(p5));
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, void* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DisplayCancelableProgressBar(System.String, System.String, Single)bool w_bssr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssr4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DisplayDialog(System.String, System.String, System.String)bool w_bsss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AddInput(System.String, System.String, System.String, Int32, UnityEngine.ClusterInputType)bool w_bsssi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsssi4i4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DisplayDialog(System.String, System.String, System.String, UnityEditor.DialogOptOutDecisionType, System.String)bool w_bsssi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsssi4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, Il2CppString* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DisplayDialog(System.String, System.String, System.String, System.String)bool w_bssss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssss");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean DisplayDialog(System.String, System.String, System.String, System.String, UnityEditor.DialogOptOutDecisionType, System.String)bool w_bssssi4s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssssi4s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
     // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(env, _sv6);
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, int32_t p5, Il2CppString* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CanConnectToCacheServer(System.String, UInt16)bool w_bsu2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsu2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(Il2CppString* p1, uint16_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean get_IsInvalid()bool w_bt(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bt");
    

    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetBooleanValue(Boolean)bool w_btDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btDb");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Import(ImportOptions)bool w_btDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btDi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Exists(NiceIO.NPath)bool w_btDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btDo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Object)bool w_btO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btO");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(System.Object, System.Object)bool w_btOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btOO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean AreEqual(System.Object, System.Object, NUnit.Framework.Constraints.Tolerance ByRef)bool w_btOOPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btOOPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetData(System.Object, System.Object ByRef)bool w_btOPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btOPO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean CanChangeType(System.Object, System.Type, System.Globalization.CultureInfo)bool w_btOoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btOoo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetRawMetadata(System.Reflection.Assembly, Byte* ByRef, Int32 ByRef)bool w_btPPu1Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPPu1Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadToAny(System.Buffers.ReadOnlySequence`1[T] ByRef, System.ReadOnlySpan`1[T], Boolean)bool w_btPS_OOi4i4_S_S_p_i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_OOi4i4_S_S_p_i4_Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_OOi4i4_* p1 = DataTransfer::GetPointer<S_OOi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_OOi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadTo(System.Buffers.ReadOnlySequence`1[T] ByRef, T, Boolean)bool w_btPS_OOi4i4_S__Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_OOi4i4_S__Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_OOi4i4_* p1 = DataTransfer::GetPointer<S_OOi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_OOi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S__* pp2 = DataTransfer::GetPointer<S__>(env, _sv2);
    S__ p2 = pp2 ? *pp2 : S__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S__ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadTo(System.Buffers.ReadOnlySequence`1[T] ByRef, T, T, Boolean)bool w_btPS_OOi4i4_S__S__Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_OOi4i4_S__S__Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_OOi4i4_* p1 = DataTransfer::GetPointer<S_OOi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_OOi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S__* pp2 = DataTransfer::GetPointer<S__>(env, _sv2);
    S__ p2 = pp2 ? *pp2 : S__ {};
        
     // LuaValToCSVal struct
    S__* pp3 = DataTransfer::GetPointer<S__>(env, _sv3);
    S__ p3 = pp3 ? *pp3 : S__ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S__ p2, struct S__ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGet(System.SequencePosition ByRef, System.ReadOnlyMemory`1[T] ByRef, Boolean)bool w_btPS_Oi4_PS_Oi4i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_Oi4_PS_Oi4i4_Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_Oi4_* p1 = DataTransfer::GetPointer<S_Oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_Oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_Oi4i4_* p2 = DataTransfer::GetPointer<S_Oi4i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_Oi4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, void* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadToAny(System.ReadOnlySpan`1[T] ByRef, System.ReadOnlySpan`1[T], Boolean)bool w_btPS_S_p_i4_S_S_p_i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_p_i4_S_S_p_i4_Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_p_i4_* p1 = DataTransfer::GetPointer<S_S_p_i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_p_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S_S_p_i4_ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadTo(System.ReadOnlySpan`1[T] ByRef, T, Boolean)bool w_btPS_S_p_i4_S__Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_p_i4_S__Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_p_i4_* p1 = DataTransfer::GetPointer<S_S_p_i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_p_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S__* pp2 = DataTransfer::GetPointer<S__>(env, _sv2);
    S__ p2 = pp2 ? *pp2 : S__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S__ p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadTo(System.ReadOnlySpan`1[T] ByRef, T, T, Boolean)bool w_btPS_S_p_i4_S__S__Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_p_i4_S__S__Db");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_p_i4_* p1 = DataTransfer::GetPointer<S_S_p_i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_p_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S__* pp2 = DataTransfer::GetPointer<S__>(env, _sv2);
    S__ p2 = pp2 ? *pp2 : S__ {};
        
     // LuaValToCSVal struct
    S__* pp3 = DataTransfer::GetPointer<S__>(env, _sv3);
    S__ p3 = pp3 ? *pp3 : S__ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S__ p2, struct S__ p3, void* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean IsKeywordEnabled(UnityEngine.Rendering.LocalKeyword ByRef)bool w_btPS_S_p_su4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_p_su4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_p_su4_* p1 = DataTransfer::GetPointer<S_S_p_su4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_p_su4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean GetGroundHit(UnityEngine.WheelHit ByRef)bool w_btPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean FindClosestEdge(UnityEngine.AI.NavMeshHit ByRef)bool w_btPS_S_r4r4r4_S_r4r4r4_r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_r4r4r4_S_r4r4r4_r4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_r4i4i4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_r4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryPeek(T ByRef)bool w_btPS__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S__* p1 = DataTransfer::GetPointer<S__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor ByRef, System.Guid, System.Object[])bool w_btPS__S_i4i2i2u1u1u1u1u1u1u1u1_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__S_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal Pstruct
    S__* p1 = DataTransfer::GetPointer<S__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WriteEvent(System.Diagnostics.Eventing.EventDescriptor ByRef, System.Object[])bool w_btPS__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__o");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal Pstruct
    S__* p1 = DataTransfer::GetPointer<S__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean WriteEvent(System.Diagnostics.Eventing.EventDescriptor ByRef, System.String)bool w_btPS__s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS__s");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S__* p1 = DataTransfer::GetPointer<S__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetCullingParameters(UnityEngine.Rendering.ScriptableCullingParameters ByRef)bool w_btPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p1 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetGuid(System.Guid ByRef)bool w_btPS_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i2i2u1u1u1u1u1u1u1u1_* p1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i2i2u1u1u1u1u1u1u1u1_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Equals(UnityEngine.TextGenerationSettings ByRef)bool w_btPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p1 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetBuffer(System.ArraySegment`1[System.Byte] ByRef)bool w_btPS_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_oi4i4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_oi4i4_* p1 = DataTransfer::GetPointer<S_oi4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_oi4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(System.Collections.Generic.KeyValuePair`2[TKey,TValue] ByRef, System.String, Unity.Properties.IProperty`1[System.Collections.Generic.KeyValuePair`2[TKey,TValue]] ByRef)bool w_btPS_oo_sPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_oo_sPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_oo_* p1 = DataTransfer::GetPointer<S_oo_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_oo_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetPosition(UnityEngine.Vector3 ByRef)bool w_btPS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetRotation(UnityEngine.Quaternion ByRef)bool w_btPS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetCameraToWorldMatrix(UnityEngine.Matrix4x4 ByRef)bool w_btPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetHapticCapabilities(UnityEngine.XR.HapticCapabilities ByRef)bool w_btPS_u4bbu4u4u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u4bbu4u4u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u4bbu4u4u4_* p1 = DataTransfer::GetPointer<S_u4bbu4u4u4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u4bbu4u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean OpenAnimationStream(UnityEngine.Animator, UnityEngine.Animations.AnimationStream ByRef)bool w_btPS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u4pppppp_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u4pppppp_* p1 = DataTransfer::GetPointer<S_u4pppppp_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u4pppppp_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Store(UnityEditor.Search.PropertyDatabaseRecordKey ByRef, System.Object)bool w_btPS_u8S_u8u8__O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8S_u8u8__O");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                            }
     // LuaValToCSVal Pstruct
    S_u8S_u8u8__* p1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8S_u8u8__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoad(UnityEditor.Search.PropertyDatabaseRecordKey ByRef, System.Object ByRef)bool w_btPS_u8S_u8u8__PO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8S_u8u8__PO");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u8S_u8u8__* p1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8S_u8u8__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryLoad(UnityEditor.Search.PropertyDatabaseRecordKey ByRef, UnityEditor.Search.IPropertyDatabaseRecordValue ByRef)bool w_btPS_u8S_u8u8__Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8S_u8u8__Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u8S_u8u8__* p1 = DataTransfer::GetPointer<S_u8S_u8u8__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8S_u8u8__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetRootBone(UnityEngine.XR.Bone ByRef)bool w_btPS_u8u4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_u8u4_");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_u8u4_* p1 = DataTransfer::GetPointer<S_u8u4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_u8u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadLittleEndian(System.Buffers.SequenceReader`1[System.Byte] ByRef, Int16 ByRef)bool w_btPi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPi2");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadLittleEndian(System.Buffers.SequenceReader`1[System.Byte] ByRef, Int32 ByRef)bool w_btPi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Remove(Int32 ByRef, System.ComponentModel.MaskedTextResultHint ByRef)bool w_btPi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPi4Pi4");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryReadLittleEndian(System.Buffers.SequenceReader`1[System.Byte] ByRef, Int64 ByRef)bool w_btPi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPi8");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetTarget(T ByRef)bool w_btPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPo");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(TSet ByRef, System.Object, Unity.Properties.IProperty`1[TSet] ByRef)bool w_btPoOPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPoOPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppObject* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryTake(T ByRef, System.TimeSpan)bool w_btPoS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPoS_i8_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef bool (*FuncToCall)(void*,void* p1, struct S_i8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryTake(T ByRef, Int32)bool w_btPoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPoi4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef bool (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(TList ByRef, Int32, Unity.Properties.IProperty`1[TList] ByRef)bool w_btPoi4Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPoi4Po");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,void* p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryTake(T ByRef, Int32, System.Threading.CancellationToken)bool w_btPoi4S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPoi4S_o_");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_o_* pp3 = DataTransfer::GetPointer<S_o_>(env, _sv3);
    S_o_ p3 = pp3 ? *pp3 : S_o_ {};
        
    typedef bool (*FuncToCall)(void*,void* p1, int32_t p2, struct S_o_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetProperty(TContainer ByRef, System.String, Unity.Properties.IProperty`1[TContainer] ByRef)bool w_btPosPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPosPo");
    
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,void* p1, Il2CppString* p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean TryGetLeftEyeOpenAmount(Single ByRef)bool w_btPr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPr4");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
// Boolean Validate(System.String ByRef)bool w_btPs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPs");
    
    auto TIp1 = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, converter::Converter<bool>::toScript(env, ret));        return true;
}
}

