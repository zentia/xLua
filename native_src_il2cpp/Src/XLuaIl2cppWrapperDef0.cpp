// Auto Gen
    
#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// System.Nullable`1[System.ReadOnlyMemory`1[System.Byte]] get_AlgorithmParameters()bool w_N_bS_Oi4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_Oi4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_Oi4i4__ (*FuncToCall)(void*,const void* method);
    struct N_bS_Oi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.DateTimeOffset] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bS_S_u8_i2__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_S_u8_i2__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bS_S_u8_i2__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bS_S_u8_i2__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Guid] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Guid] get_ProviderControlGuid()bool w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i2i2u1u1u1u1u1u1u1u1__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i4i2i2u1u1u1u1u1u1u1u1__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.ValueTuple`2[System.Int32,System.Int32]] get_Progress()bool w_N_bS_i4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_i4i4__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Decimal] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bS_i4i4i4i4u8__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i4i4i4u8__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bS_i4i4i4i4u8__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bS_i4i4i4i4u8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Decimal] Sum(System.Linq.ParallelQuery`1[System.Nullable`1[System.Decimal]])bool w_N_bS_i4i4i4i4u8__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i4i4i4i4u8__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_i4i4i4i4u8__ (*FuncToCall)(void*,const void* method);
    struct N_bS_i4i4i4i4u8__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.TimeSpan] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bS_i8__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_i8__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bS_i8__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bS_i8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[Bee.BinLog.NodeInfo] get_EnqueueingNode()bool w_N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____ (*FuncToCall)(void*,const void* method);
    struct N_bS_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4____ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[UnityEngine.Vector2] get_autoFocusPoint()bool w_N_bS_r4r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_r4r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_r4r4__ (*FuncToCall)(void*,const void* method);
    struct N_bS_r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.DateTime] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bS_u8__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_u8__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bS_u8__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bS_u8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.DateTime] get_datePublished()bool w_N_bS_u8__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bS_u8__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bS_u8__ (*FuncToCall)(void*,const void* method);
    struct N_bS_u8__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Boolean] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bb_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bb_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bb_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bb_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Boolean] get_UseServicePointManagerCallback()bool w_N_bb_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bb_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bb_ (*FuncToCall)(void*,const void* method);
    struct N_bb_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Boolean] IsCompatibilitySwitchSet(System.String)bool w_N_bb_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bb_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct N_bb_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct N_bb_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Int16] get_Opcode()bool w_N_bi2_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi2_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bi2_ (*FuncToCall)(void*,const void* method);
    struct N_bi2_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Int32] get_CurrentId()bool w_N_bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bi4_ (*FuncToCall)(const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Int32] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bi4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bi4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Int32] get_InvalidCultureId()bool w_N_bi4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bi4_ (*FuncToCall)(void*,const void* method);
    struct N_bi4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Int64] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bi8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bi8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bi8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Int64] get_LowestBreakIteration()bool w_N_bi8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bi8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bi8_ (*FuncToCall)(void*,const void* method);
    struct N_bi8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Single] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_br4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_br4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_br4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_br4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Single] Sum(System.Linq.ParallelQuery`1[System.Nullable`1[System.Single]])bool w_N_br4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_br4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_br4_ (*FuncToCall)(void*,const void* method);
    struct N_br4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Single] GetFloatValue(ExCSS.UnitType)bool w_N_br4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_br4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct N_br4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct N_br4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Double] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_br8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_br8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_br8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_br8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Double] Sum(System.Linq.ParallelQuery`1[System.Nullable`1[System.Double]])bool w_N_br8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_br8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_br8_ (*FuncToCall)(void*,const void* method);
    struct N_br8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.Byte] get_Level()bool w_N_bu1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bu1_ (*FuncToCall)(void*,const void* method);
    struct N_bu1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.UInt32] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bu4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bu4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bu4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.UInt32] get_Timestamp()bool w_N_bu4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct N_bu4_ (*FuncToCall)(void*,const void* method);
    struct N_bu4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[System.UInt64] op_Explicit(System.Xml.Linq.XAttribute)bool w_N_bu8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_N_bu8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct N_bu8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct N_bu8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyNullableValueType(env, ret, TIret));        return true;
}
// System.Object get_HostContext()bool w_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_O");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppObject* (*FuncToCall)(const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObjectValue(System.Object)bool w_OO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetComObjectData(System.Object, System.Object)bool w_OOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeType(System.Object, System.TypeCode)bool w_OOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeType(System.Object, System.TypeCode, System.IFormatProvider)bool w_OOi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOi4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeType(System.Object, System.Type)bool w_OOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetEditor(System.Object, System.Type, Boolean)bool w_OOob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeType(System.Object, System.Type, System.IFormatProvider)bool w_OOoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object VolatileRead(System.Object ByRef)bool w_OPO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OPO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Exchange(System.Object ByRef, System.Object)bool w_OPOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OPOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CompareExchange(System.Object ByRef, System.Object, System.Object)bool w_OPOOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OPOOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                                            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetNativeOverlappedState(System.Threading.NativeOverlapped*)bool w_OPS_ppi4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OPS_ppi4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_ppi4i4p_* p1 = DataTransfer::GetPointer<S_ppi4i4p_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_ppi4i4p_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Box(Void*, System.Type)bool w_OPvo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OPvo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!pesapi_is_binary(env, _sv1) && !pesapi_is_null(env, _sv1) && !pesapi_is_undefined(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(TypedReference)bool w_OS_S_p_pp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_pp_* pp1 = DataTransfer::GetPointer<S_S_p_pp_>(env, _sv1);
    S_S_p_pp_ p1 = pp1 ? *pp1 : S_S_p_pp_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_S_p_pp_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object RaySnap(UnityEngine.Ray)bool w_OS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object IntersectRayTriangle(UnityEngine.Ray, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Boolean)bool w_OS_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OS_S_r4r4r4_S_r4r4r4__S_r4r4r4_S_r4r4r4_S_r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef Il2CppObject* (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetRuntimeInterfaceAsObject(System.Guid, System.Guid)bool w_OS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OS_i4i2i2u1u1u1u1u1u1u1u1_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv1);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(env, _sv2);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, struct S_i4i2i2u1u1u1u1u1u1u1u1_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.Type)bool w_Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(System.Type, System.String)bool w_OoDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoDs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, System.Object)bool w_OoO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object InvokeMethod(System.Reflection.MethodInfo, System.Object, System.Object[])bool w_OoOVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoOVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ExpandoTrySetValue(System.Dynamic.ExpandoObject, System.Object, Int32, System.Object, System.String, Boolean)bool w_OoOi4Osb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoOi4Osb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                                if (!converter::Converter<Il2CppString*>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(env, _sv5);
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppString* p5, bool p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetCurrentValue(UnityEngine.GameObject, UnityEditor.EditorCurveBinding)bool w_OoS_sosi4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoS_sosi4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_sosi4i4i4i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_sosi4i4i4i4i4i4i4_>(env, _sv2);
    S_sosi4i4i4i4i4i4i4_ p2 = pp2 ? *pp2 : S_sosi4i4i4i4i4i4i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_sosi4i4i4i4i4i4i4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.Type, System.Object[])bool w_OoVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.Type, Boolean)bool w_Oob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, SByte)bool w_Ooi1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi1");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int8_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, Int16)bool w_Ooi2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi2");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, Int32)bool w_Ooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.Type, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo)bool w_Ooi4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.Type, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[])bool w_Ooi4oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4oooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, Int64)bool w_Ooi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetCurrentValue(UnityEditorInternal.AnimationWindowState, UnityEditorInternal.AnimationWindowCurve)bool w_Ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.Type, System.Object[], System.Object[])bool w_Oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.IServiceProvider, System.Type, System.Type[], System.Object[])bool w_Ooooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(System.Type, System.String)bool w_Oos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(System.Type, System.String, System.Object)bool w_OosO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OosO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Parse(System.Type, System.String, Boolean)bool w_Oosb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oosb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, Byte)bool w_Oou1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou1");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, UInt16)bool w_Oou2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou2");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, UInt32)bool w_Oou4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ToObject(System.Type, UInt64)bool w_Oou8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<uint64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object WrapIUnknownWithComObject(IntPtr)bool w_Op(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Op");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object charCaster(IntPtr, Int32, System.Object)bool w_Opi4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Opi4O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetTypedObjectForIUnknown(IntPtr, System.Type)bool w_Opo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Opo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetData(System.String)bool w_Os(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Os");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(System.String, System.Object)bool w_OsO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OsO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateFromName(System.String, System.Object[])bool w_OsVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OsVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Execute(System.String, UnityEditor.CommandHint)bool w_Osi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Osi8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Execute(System.String, UnityEditor.CommandHint, System.Object[])bool w_Osi8VO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Osi8VO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int64_t p2, void* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object FromJson(System.String, System.Type)bool w_Oso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(System.String, System.String, System.Object)bool w_OssO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OssO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Eval(System.String, System.String, System.String, System.Type[], System.Object[])bool w_Osssoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Osssoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Clone()bool w_Ot(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ot");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef Il2CppObject* (*FuncToCall)(void*,const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(System.String, UnityEditor.Search.SearchContext)bool w_OtDsDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtDsDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object get_Item(System.Object)bool w_OtO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Create(System.Object, System.Object, System.Xml.XmlNode)bool w_OtOOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Invoke(System.Object, System.Object[])bool w_OtOVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Convert(System.Object, System.TypeCode)bool w_OtOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo)bool w_OtOi4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOi4ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Convert(System.Object, System.Type)bool w_OtOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeType(System.Object, System.Type, System.Xml.IXmlNamespaceResolver)bool w_OtOoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetRealObject(System.Runtime.Serialization.StreamingContext)bool w_OtS_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtS_Oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_Oi4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValueDirect(TypedReference)bool w_OtS_S_p_pp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtS_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_pp_* pp1 = DataTransfer::GetPointer<S_S_p_pp_>(env, _sv1);
    S_S_p_pp_ p1 = pp1 ? *pp1 : S_S_p_pp_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_S_p_pp_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object DynamicInvoke(System.Object[])bool w_OtVO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtVO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int32[])bool w_OtVi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtVi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int64[])bool w_OtVi8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtVi8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int32)bool w_Oti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeTypeXsltResult(Int32, System.Object)bool w_Oti4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ChangeTypeXsltArgument(Int32, System.Object, System.Type)bool w_Oti4Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4Oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int32, Int32)bool w_Oti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int32, Int32, Int32)bool w_Oti4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Invoke(System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo)bool w_Oti4ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int64)bool w_Oti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int64, Int64)bool w_Oti8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(Int64, Int64, Int64)bool w_Oti8i8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8i8i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, int64_t p2, int64_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object SetHostExecutionContext(System.Threading.HostExecutionContext)bool w_Oto(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oto");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(System.Type, System.String)bool w_OtoDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtoDs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ValidateEndElement(System.Xml.Schema.XmlSchemaInfo, System.Object)bool w_OtoO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtoO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Deserialize(System.Xml.XmlReader, System.Xml.Serialization.XmlDeserializationEvents)bool w_OtoS_ooooO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtoS_ooooO_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_ooooO_* pp2 = DataTransfer::GetPointer<S_ooooO_>(env, _sv2);
    S_ooooO_ p2 = pp2 ? *pp2 : S_ooooO_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_ooooO_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ReadObject(System.Xml.XmlReader, Boolean)bool w_Otob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ReadObject(System.Xml.XmlDictionaryReader, Boolean, System.Runtime.Serialization.DataContractResolver)bool w_Otobo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otobo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Deserialize(System.IO.Stream, System.Runtime.Remoting.Messaging.HeaderHandler)bool w_Otoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ConvertFrom(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.Object)bool w_OtooO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtooO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ConvertTo(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.Object, System.Type)bool w_OtooOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtooOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object DeserializeMethodResponse(System.IO.Stream, System.Runtime.Remoting.Messaging.HeaderHandler, System.Runtime.Remoting.Messaging.IMethodCallMessage)bool w_Otooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.IServiceProvider, System.Type, System.Type[], System.Object[])bool w_Otoooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otoooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ConvertFromString(System.ComponentModel.ITypeDescriptorContext, System.Globalization.CultureInfo, System.String)bool w_Otoos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otoos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ReadElementContentAs(System.Type, System.Xml.IXmlNamespaceResolver, System.String, System.String)bool w_Otooss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otooss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(env, _sv4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ConvertFromInvariantString(System.ComponentModel.ITypeDescriptorContext, System.String)bool w_Otos(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otos");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Deserialize(System.Xml.XmlReader, System.String, System.Xml.Serialization.XmlDeserializationEvents)bool w_OtosS_ooooO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtosS_ooooO_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_ooooO_* pp3 = DataTransfer::GetPointer<S_ooooO_>(env, _sv3);
    S_ooooO_ p3 = pp3 ? *pp3 : S_ooooO_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, struct S_ooooO_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ConvertAssemblyToTypeLib(System.Reflection.Assembly, System.String, System.Runtime.InteropServices.TypeLibExporterFlags, System.Runtime.InteropServices.ITypeLibExporterNotifySink)bool w_Otosi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otosi4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetEntity(System.Uri, System.String, System.Type)bool w_Otoso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otoso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(IntPtr, Int32)bool w_Otpi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otpi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object decimalCaster(IntPtr, Int32, System.Object)bool w_Otpi4O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otpi4O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object getCsObj(IntPtr, Int32, Int32)bool w_Otpi4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otpi4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(IntPtr, Int32, System.Type)bool w_Otpi4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otpi4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateDelegateBridge(IntPtr, System.Type, Int32)bool w_Otpoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otpoi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,void* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object Evaluate(Single)bool w_Otr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(System.String)bool w_Ots(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ots");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(System.String, System.Object)bool w_OtsO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtsO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(System.String, System.Object, Microsoft.Win32.RegistryValueOptions)bool w_OtsOi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtsOi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetObject(System.String, Boolean)bool w_Otsb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstance(System.String, Boolean, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[])bool w_Otsbi4oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsbi4oooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[])bool w_Otsi4oOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo)bool w_Otsi4oOoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Reflection.ParameterModifier[], System.Globalization.CultureInfo, System.String[])bool w_Otsi4oOoooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOoooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object GetValue(System.String, System.Type)bool w_Otso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstanceAndUnwrap(System.String, System.String)bool w_Otss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstanceAndUnwrap(System.String, System.String, Boolean, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[])bool w_Otssbi4oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otssbi4oooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstanceAndUnwrap(System.String, System.String, Boolean, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo, System.Object[], System.Security.Policy.Evidence)bool w_Otssbi4ooooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otssbi4ooooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];
    auto TIp9 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, Il2CppObject* p8, Il2CppObject* p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object CreateInstanceAndUnwrap(System.String, System.String, System.Object[])bool w_Otsso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ValidateAttribute(System.String, System.String, System.Xml.Schema.XmlValueGetter, System.Xml.Schema.XmlSchemaInfo)bool w_Otssoo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otssoo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// System.Object ValidateAttribute(System.String, System.String, System.String, System.Xml.Schema.XmlSchemaInfo)bool w_Otssso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otssso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, CSRefToLuaValue(env, TIret, ret));        return true;
}
// UnityEngine.ContactPairPoint& GetContactPoint(Int32)bool w_PS_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(void*,int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_S_r4r4r4_r4S_r4r4r4_u4S_r4r4r4_u4_);        return true;
}
// UnityEngine.ContactPair& GetContactPair(Int32)bool w_PS_i4i4pu4u2u2S_r4r4r4__ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4i4pu4u2u2S_r4r4r4__ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(void*,int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_i4i4pu4u2u2S_r4r4r4__);        return true;
}
// UnityEngine.NVIDIA.DLSSCommandExecutionData& get_executeData()bool w_PS_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_);        return true;
}
// System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped)bool w_PS_ppi4i4p_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_ppi4i4p_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef void* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_ppi4i4p_);        return true;
}
// System.Threading.NativeOverlapped* Pack(System.Threading.IOCompletionCallback, System.Object)bool w_PS_ppi4i4p_toO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_ppi4i4p_toO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef void* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_ppi4i4p_);        return true;
}
// System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.IOCompletionCallback, System.Object, System.Object)bool w_PS_ppi4i4p_toOO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_ppi4i4p_toOO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef void* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_ppi4i4p_);        return true;
}
// UnityEngine.NVIDIA.DLSSCommandInitializationData& get_initData()bool w_PS_u4u4u4u4i4i4u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_u4u4u4u4i4i4u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, // unknown ret signature: PS_u4u4u4u4i4i4u4_);        return true;
}
// SByte* GetDirectBufferAddress(IntPtr)bool w_Pi1p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pi1p");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef void* (*FuncToCall)(void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, // unknown ret signature: Pi1);        return true;
}
// T& GetPinnableReference()bool w_Pot(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pot");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, // unknown ret signature: Po);        return true;
}
// T& get_Item(Int32)bool w_Poti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Poti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(void*,int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, // unknown ret signature: Po);        return true;
}
// Byte* get_PositionPointer()bool w_Pu1t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pu1t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, // unknown ret signature: Pu1);        return true;
}
// UInt64* GetBytesReadArray()bool w_Pu8t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pu8t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, // unknown ret signature: Pu8);        return true;
}
// Void* Unbox(System.Object)bool w_PvO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PvO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef void* (*FuncToCall)(Il2CppObject* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* PinGCObjectAndGetAddress(System.Object, UInt64 ByRef)bool w_PvOPu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PvOPu8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* CreateCounterValue(IntPtr ByRef, Char*, Int32, UInt16, Unity.Profiling.LowLevel.MarkerFlags, Byte, Byte, Int32, Unity.Profiling.ProfilerCounterOptions)bool w_PvPpPci4u2u2u1u1i4u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PvPpPci4u2u2u1u1i4u2");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!!true) return false;                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv4)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv5)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv6)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv9)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    uint16_t p4 = converter::Converter<uint16_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    uint16_t p5 = converter::Converter<uint16_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    uint8_t p6 = converter::Converter<uint8_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    uint8_t p7 = converter::Converter<uint8_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    uint16_t p9 = converter::Converter<uint16_t>::toCpp(env, _sv9);        
        
    typedef void* (*FuncToCall)(void* p1, void* p2, int32_t p3, uint16_t p4, uint16_t p5, uint8_t p6, uint8_t p7, int32_t p8, uint16_t p9, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* CreateCounterValue(IntPtr ByRef, System.String, UInt16, Unity.Profiling.LowLevel.MarkerFlags, Byte, Byte, Int32, Unity.Profiling.ProfilerCounterOptions)bool w_PvPpsu2u2u1u1i4u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PvPpsu2u2u1u1i4u2");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv3)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv4)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv5)) return false;                if (!converter::Converter<uint8_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<uint16_t>::accept(env, _sv8)) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    uint16_t p4 = converter::Converter<uint16_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    uint8_t p5 = converter::Converter<uint8_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    uint8_t p6 = converter::Converter<uint8_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    uint16_t p8 = converter::Converter<uint16_t>::toCpp(env, _sv8);        
        
    typedef void* (*FuncToCall)(void* p1, Il2CppString* p2, uint16_t p3, uint16_t p4, uint8_t p5, uint8_t p6, int32_t p7, uint16_t p8, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* Malloc(Int64, Int32, Unity.Collections.Allocator)bool w_Pvi8i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pvi8i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef void* (*FuncToCall)(int64_t p1, int32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* MallocTracked(Int64, Int32, Unity.Collections.Allocator, Int32)bool w_Pvi8i4i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pvi8i4i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef void* (*FuncToCall)(int64_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* PinGCArrayAndGetDataAddress(System.Array, UInt64 ByRef)bool w_PvoPu8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PvoPu8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef void* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* op_Explicit(IntPtr)bool w_Pvp(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pvp");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef void* (*FuncToCall)(void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* ToPointer()bool w_Pvt(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pvt");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// Void* GetCounterValuePtr(Int32)bool w_Pvti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pvti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef void* (*FuncToCall)(void*,int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, pesapi_create_binary(env, ret, 0));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] get_Sequence()bool w_S_OOi4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_OOi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(System.SequencePosition)bool w_S_OOi4i4_tS_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_tS_Oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,struct S_Oi4_ p1, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(System.SequencePosition, System.SequencePosition)bool w_S_OOi4i4_tS_Oi4_S_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_tS_Oi4_S_Oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};
        
     // LuaValToCSVal struct
    S_Oi4_* pp2 = DataTransfer::GetPointer<S_Oi4_>(env, _sv2);
    S_Oi4_ p2 = pp2 ? *pp2 : S_Oi4_ {};
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,struct S_Oi4_ p1, struct S_Oi4_ p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(System.SequencePosition, Int32)bool w_S_OOi4i4_tS_Oi4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_tS_Oi4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,struct S_Oi4_ p1, int32_t p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(System.SequencePosition, Int64)bool w_S_OOi4i4_tS_Oi4_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_tS_Oi4_i8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_Oi4_* pp1 = DataTransfer::GetPointer<S_Oi4_>(env, _sv1);
    S_Oi4_ p1 = pp1 ? *pp1 : S_Oi4_ {};
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,struct S_Oi4_ p1, int64_t p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(Int32, System.SequencePosition)bool w_S_OOi4i4_ti4S_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_ti4S_Oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_Oi4_* pp2 = DataTransfer::GetPointer<S_Oi4_>(env, _sv2);
    S_Oi4_ p2 = pp2 ? *pp2 : S_Oi4_ {};
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,int32_t p1, struct S_Oi4_ p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(Int32, Int32)bool w_S_OOi4i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(Int64)bool w_S_OOi4i4_ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_ti8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,int64_t p1, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(Int64, System.SequencePosition)bool w_S_OOi4i4_ti8S_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_ti8S_Oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_Oi4_* pp2 = DataTransfer::GetPointer<S_Oi4_>(env, _sv2);
    S_Oi4_ p2 = pp2 ? *pp2 : S_Oi4_ {};
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,int64_t p1, struct S_Oi4_ p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.ReadOnlySequence`1[T] Slice(Int64, Int64)bool w_S_OOi4i4_ti8i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OOi4i4_ti8i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
    typedef struct S_OOi4i4_ (*FuncToCall)(void*,int64_t p1, int64_t p2, const void* method);
    struct S_OOi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask`1[System.Net.WebSockets.ValueWebSocketReceiveResult] ReceiveAsync(System.Memory`1[System.Byte], System.Threading.CancellationToken)bool w_S_OS_u4i4_i2b_tS_Oi4i4_S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_OS_u4i4_i2b_tS_Oi4i4_S_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef struct S_OS_u4i4_i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, struct S_o_ p2, const void* method);
    struct S_OS_u4i4_i2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask DisposeAsync()bool w_S_Oi2b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Oi2b_ (*FuncToCall)(void*,const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory`1[System.Byte], System.Threading.CancellationToken)bool w_S_Oi2b_tS_Oi4i4_DS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tS_Oi4i4_DS_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_Oi2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, void* p2, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory`1[System.Byte], System.Threading.CancellationToken)bool w_S_Oi2b_tS_Oi4i4_S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tS_Oi4i4_S_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef struct S_Oi2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, struct S_o_ p2, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask SendAsync(System.ReadOnlyMemory`1[System.Byte], System.Net.WebSockets.WebSocketMessageType, Boolean, System.Threading.CancellationToken)bool w_S_Oi2b_tS_Oi4i4_i4bS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi2b_tS_Oi4i4_i4bS_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_o_* pp4 = DataTransfer::GetPointer<S_o_>(env, _sv4);
    S_o_ p4 = pp4 ? *pp4 : S_o_ {};
        
    typedef struct S_Oi2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, int32_t p2, bool p3, struct S_o_ p4, const void* method);
    struct S_Oi2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.Serialization.StreamingContext get_StreamingContext()bool w_S_Oi4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Oi4_ (*FuncToCall)(void*,const void* method);
    struct S_Oi4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.SequencePosition GetPosition(Int64)bool w_S_Oi4_ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4_ti8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_Oi4_ (*FuncToCall)(void*,int64_t p1, const void* method);
    struct S_Oi4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.SequencePosition GetPosition(Int64, System.SequencePosition)bool w_S_Oi4_ti8S_Oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4_ti8S_Oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_Oi4_* pp2 = DataTransfer::GetPointer<S_Oi4_>(env, _sv2);
    S_Oi4_ p2 = pp2 ? *pp2 : S_Oi4_ {};
        
    typedef struct S_Oi4_ (*FuncToCall)(void*,int64_t p1, struct S_Oi4_ p2, const void* method);
    struct S_Oi4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask`1[System.Int32] ReadAsync(System.Memory`1[System.Byte], System.Threading.CancellationToken)bool w_S_Oi4i2b_tS_Oi4i4_DS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i2b_tS_Oi4i4_DS_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_Oi4i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, void* p2, const void* method);
    struct S_Oi4i2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask`1[System.Int32] ReadAsync(System.Memory`1[System.Byte], System.Threading.CancellationToken)bool w_S_Oi4i2b_tS_Oi4i4_S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i2b_tS_Oi4i4_S_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
     // LuaValToCSVal struct
    S_o_* pp2 = DataTransfer::GetPointer<S_o_>(env, _sv2);
    S_o_ p2 = pp2 ? *pp2 : S_o_ {};
        
    typedef struct S_Oi4i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, struct S_o_ p2, const void* method);
    struct S_Oi4i2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask`1[System.Int32] SendAsync(System.Net.Sockets.Socket, System.ReadOnlyMemory`1[System.Byte], System.Net.Sockets.SocketFlags, System.Threading.CancellationToken)bool w_S_Oi4i2b_tS_Oi4i4_i4DS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i2b_tS_Oi4i4_i4DS_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_Oi4i2b_ (*FuncToCall)(void*,struct S_Oi4i4_ p1, int32_t p2, void* p3, const void* method);
    struct S_Oi4i2b_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Memory`1[T] get_Empty()bool w_S_Oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Oi4i4_ (*FuncToCall)(const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlyMemory`1[T] op_Implicit(System.Memory`1[T])bool w_S_Oi4i4_S_Oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_S_Oi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Oi4i4_* pp1 = DataTransfer::GetPointer<S_Oi4i4_>(env, _sv1);
    S_Oi4i4_ p1 = pp1 ? *pp1 : S_Oi4i4_ {};
        
    typedef struct S_Oi4i4_ (*FuncToCall)(struct S_Oi4i4_ p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Memory`1[T] op_Implicit(System.ArraySegment`1[T])bool w_S_Oi4i4_S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_S_oi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv1);
    S_oi4i4_ p1 = pp1 ? *pp1 : S_oi4i4_ {};
        
    typedef struct S_Oi4i4_ (*FuncToCall)(struct S_oi4i4_ p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Memory`1[T] op_Implicit(T[])bool w_S_Oi4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_Oi4i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String)bool w_S_Oi4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Oi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Memory`1[T] GetMemory(Int32)bool w_S_Oi4i4_tDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_tDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_Oi4i4_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String, System.Range)bool w_S_Oi4i4_tS_S_i4_S_i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_tS_S_i4_S_i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_i4_S_i4__* pp1 = DataTransfer::GetPointer<S_S_i4_S_i4__>(env, _sv1);
    S_S_i4_S_i4__ p1 = pp1 ? *pp1 : S_S_i4_S_i4__ {};
        
    typedef struct S_Oi4i4_ (*FuncToCall)(void*,struct S_S_i4_S_i4__ p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlyMemory`1[System.Char] AsMemory(System.String, System.Index)bool w_S_Oi4i4_tS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_tS_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef struct S_Oi4i4_ (*FuncToCall)(void*,struct S_i4_ p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Memory`1[T] Slice(Int32)bool w_S_Oi4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_Oi4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Memory`1[T] Slice(Int32, Int32)bool w_S_Oi4i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Oi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_Oi4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_Oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ValueTask`1[TResult] Preserve()bool w_S_Ooi2b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Ooi2b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Ooi2b_ (*FuncToCall)(void*,const void* method);
    struct S_Ooi2b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// MeshDataArray AllocateWritableMeshData(Int32)bool w_S_Ppi4i4i4S_pi4i4__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Ppi4i4i4S_pi4i4__i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_Ppi4i4i4S_pi4i4__ (*FuncToCall)(int32_t p1, const void* method);
    struct S_Ppi4i4i4S_pi4i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// MeshDataArray AcquireReadOnlyMeshData(UnityEngine.Mesh)bool w_S_Ppi4i4i4S_pi4i4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Ppi4i4i4S_pi4i4__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_Ppi4i4i4S_pi4i4__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_Ppi4i4i4S_pi4i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Collections.NativeSlice`1[T] op_Implicit(Unity.Collections.NativeArray`1[T])bool w_S_Pu1i4i4i4i4S_pi4i4__S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pu1i4i4i4i4S_pi4i4__S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef struct S_Pu1i4i4i4i4S_pi4i4__ (*FuncToCall)(struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    struct S_Pu1i4i4i4i4S_pi4i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Buffers.MemoryHandle Pin()bool w_S_PvS_p_o_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_PvS_p_o_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_PvS_p_o_ (*FuncToCall)(void*,const void* method);
    struct S_PvS_p_o_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// ReadOnly AsReadOnly()bool w_S_Pvi4S_pi4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4S_pi4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Pvi4S_pi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_Pvi4S_pi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Collections.NativeArray`1[System.Byte] GetDirectByteBuffer(IntPtr)bool w_S_Pvi4i4i4S_pi4i4_i4_p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_p");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void* p1, const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Collections.NativeArray`1[System.Byte] get_RawImageDataReference()bool w_S_Pvi4i4i4S_pi4i4_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Collections.NativeArray`1[System.Int32] GetLightIndexMap(Unity.Collections.Allocator)bool w_S_Pvi4i4i4S_pi4i4_i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Collections.NativeArray`1[T] GetSubArray(Int32, Int32)bool w_S_Pvi4i4i4S_pi4i4_i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_Pvi4i4i4S_pi4i4_i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_Pvi4i4i4S_pi4i4_i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_Pvi4i4i4S_pi4i4_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_S_OOi4i4_S_Oi4_S_Oi4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_OOi4i4_S_Oi4_S_Oi4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_OOi4i4_S_Oi4_S_Oi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_OOi4i4_S_Oi4_S_Oi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ValueTaskAwaiter GetAwaiter()bool w_S_S_Oi2b__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Oi2b__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Oi2b__ (*FuncToCall)(void*,const void* method);
    struct S_S_Oi2b__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable ConfigureAwait(Boolean)bool w_S_S_Oi2b__tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Oi2b__tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_S_Oi2b__ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_S_Oi2b__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Net.Security.SslApplicationProtocol get_NegotiatedApplicationProtocol()bool w_S_S_Oi4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Oi4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Oi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_Oi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ValueTaskAwaiter`1[TResult] GetAwaiter()bool w_S_S_Ooi2b__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Ooi2b__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Ooi2b__ (*FuncToCall)(void*,const void* method);
    struct S_S_Ooi2b__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1[TResult] ConfigureAwait(Boolean)bool w_S_S_Ooi2b__tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Ooi2b__tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_S_Ooi2b__ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_S_Ooi2b__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_S_Pu1i4i4i4i4S_pi4i4__i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pu1i4i4i4i4S_pi4i4__i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Pu1i4i4i4i4S_pi4i4__i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_Pu1i4i4i4i4S_pi4i4__i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.PickingIncludeExcludeList GetPickingIncludeExcludeList(Unity.Collections.Allocator)bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void* p1, const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ParticleSystemJobs.ParticleSystemNativeArray4 get_customData1()bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ParticleSystemJobs.ParticleSystemNativeArray3 get_positions()bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.ObjectChangeEventStream Clone(Unity.Collections.Allocator)bool w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_S_Pvi4i4i4S_pi4i4_i4_i4S___t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_Pvi4i4i4S_pi4i4_i4_i4S___t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_Pvi4i4i4S_pi4i4_i4_i4S___ (*FuncToCall)(void*,const void* method);
    struct S_S_Pvi4i4i4S_pi4i4_i4_i4S___ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.AsyncIteratorMethodBuilder Create()bool w_S_S_S_S_oo_o___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_S_oo_o___");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_S_S_oo_o___ (*FuncToCall)(const void* method);
    struct S_S_S_S_oo_o___ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder Create()bool w_S_S_S_S_oo_o__bb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_S_oo_o__bb_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_S_S_oo_o__bb_ (*FuncToCall)(const void* method);
    struct S_S_S_S_oo_o__bb_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// AssetDatabaseCounters get_counters()bool w_S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___ (*FuncToCall)(const void* method);
    struct S_S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8__S_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8_S_i8i8___ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.AsyncTaskMethodBuilder Create()bool w_S_S_S_oo_o__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_oo_o__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_S_oo_o__ (*FuncToCall)(const void* method);
    struct S_S_S_oo_o__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1[TResult] Create()bool w_S_S_S_oo_o_obb_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_oo_o_obb_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_S_oo_o_obb_ (*FuncToCall)(const void* method);
    struct S_S_S_oo_o_obb_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_S_S_p_i4_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_p_i4_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_S_p_i4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_S_p_i4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleTransformOrigin op_Implicit(UnityEngine.UIElements.TransformOrigin)bool w_S_S_S_r4i4_S_r4i4_r4_i4_S_S_r4i4_S_r4i4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4_i4_S_S_r4i4_S_r4i4_r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4_>(env, _sv1);
    S_S_r4i4_S_r4i4_r4_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4_ {};
        
    typedef struct S_S_S_r4i4_S_r4i4_r4_i4_ (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4_ p1, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleTransformOrigin op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_S_r4i4_S_r4i4_r4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_S_r4i4_S_r4i4_r4_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleTranslate op_Implicit(UnityEngine.UIElements.Translate)bool w_S_S_S_r4i4_S_r4i4_r4b_i4_S_S_r4i4_S_r4i4_r4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4b_i4_S_S_r4i4_S_r4i4_r4b_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4i4_r4b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4i4_r4b_>(env, _sv1);
    S_S_r4i4_S_r4i4_r4b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4i4_r4b_ {};
        
    typedef struct S_S_S_r4i4_S_r4i4_r4b_i4_ (*FuncToCall)(struct S_S_r4i4_S_r4i4_r4b_ p1, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleTranslate op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_S_r4i4_S_r4i4_r4b_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4i4_r4b_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_S_r4i4_S_r4i4_r4b_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_S_r4i4_S_r4i4_r4b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleRotate op_Implicit(UnityEngine.UIElements.Rotate)bool w_S_S_S_r4i4_S_r4r4r4_b_i4_S_S_r4i4_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4r4r4_b_i4_S_S_r4i4_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4i4_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4i4_S_r4r4r4_b_>(env, _sv1);
    S_S_r4i4_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4i4_S_r4r4r4_b_ {};
        
    typedef struct S_S_S_r4i4_S_r4r4r4_b_i4_ (*FuncToCall)(struct S_S_r4i4_S_r4r4r4_b_ p1, const void* method);
    struct S_S_S_r4i4_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleRotate op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_S_r4i4_S_r4r4r4_b_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4i4_S_r4r4r4_b_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_S_r4i4_S_r4r4r4_b_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_S_r4i4_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SubMeshDescriptor GetSubMesh(Int32)bool w_S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_S_r4r4r4_S_r4r4r4__i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleScale op_Implicit(UnityEngine.UIElements.Scale)bool w_S_S_S_r4r4r4_b_i4_S_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_b_i4_S_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_b_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_b_>(env, _sv1);
    S_S_r4r4r4_b_ p1 = pp1 ? *pp1 : S_S_r4r4r4_b_ {};
        
    typedef struct S_S_S_r4r4r4_b_i4_ (*FuncToCall)(struct S_S_r4r4r4_b_ p1, const void* method);
    struct S_S_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleScale op_Implicit(UnityEngine.Vector2)bool w_S_S_S_r4r4r4_b_i4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_b_i4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_S_S_r4r4r4_b_i4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_S_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleScale op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_S_r4r4r4_b_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_b_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_S_r4r4r4_b_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_S_r4r4r4_b_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleEnum`1[T] op_Implicit(T)bool w_S_S__i4_S__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S__i4_S__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef struct S_S__i4_ (*FuncToCall)(struct S__ p1, const void* method);
    struct S_S__i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleEnum`1[T] op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S__i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S__i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S__i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S__i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackgroundSize op_Implicit(UnityEngine.UIElements.BackgroundSize)bool w_S_S_i4S_r4i4_S_r4i4__i4_S_i4S_r4i4_S_r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4_S_r4i4__i4_S_i4S_r4i4_S_r4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4i4_S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4_S_r4i4__>(env, _sv1);
    S_i4S_r4i4_S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4_S_r4i4__ {};
        
    typedef struct S_S_i4S_r4i4_S_r4i4__i4_ (*FuncToCall)(struct S_i4S_r4i4_S_r4i4__ p1, const void* method);
    struct S_S_i4S_r4i4_S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackgroundSize op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_i4S_r4i4_S_r4i4__i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4_S_r4i4__i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_i4S_r4i4_S_r4i4__i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_i4S_r4i4_S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackgroundPosition op_Implicit(UnityEngine.UIElements.BackgroundPosition)bool w_S_S_i4S_r4i4__i4_S_i4S_r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4__i4_S_i4S_r4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4S_r4i4__* pp1 = DataTransfer::GetPointer<S_i4S_r4i4__>(env, _sv1);
    S_i4S_r4i4__ p1 = pp1 ? *pp1 : S_i4S_r4i4__ {};
        
    typedef struct S_S_i4S_r4i4__i4_ (*FuncToCall)(struct S_i4S_r4i4__ p1, const void* method);
    struct S_S_i4S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackgroundPosition op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_i4S_r4i4__i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_r4i4__i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_i4S_r4i4__i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_i4S_r4i4__i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Range get_All()bool w_S_S_i4_S_i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4_S_i4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_i4_S_i4__ (*FuncToCall)(const void* method);
    struct S_S_i4_S_i4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Range StartAt(System.Index)bool w_S_S_i4_S_i4__S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4_S_i4__S_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef struct S_S_i4_S_i4__ (*FuncToCall)(struct S_i4_ p1, const void* method);
    struct S_S_i4_S_i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// PositionEnumerator get_allPositionsWithin()bool w_S_S_i4i4_S_i4i4_S_i4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_S_i4i4_S_i4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_i4i4_S_i4i4_S_i4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4_S_i4i4_S_i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Bee.Core.TraceEvent CreateEvent(System.String, System.Collections.Generic.Dictionary`2[System.String,System.String])bool w_S_S_i4i4__tDsDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4__tDsDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_S_i4i4__ (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    struct S_S_i4i4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Bee.Core.TraceEvent CreateEvent(System.DateTimeOffset, System.String, System.Collections.Generic.Dictionary`2[System.String,System.String])bool w_S_S_i4i4__tS_S_u8_i2_DsDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4__tS_S_u8_i2_DsDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_i4i4__ (*FuncToCall)(void*,struct S_S_u8_i2_ p1, void* p2, void* p3, const void* method);
    struct S_S_i4i4__ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Bee.Core.TraceEvent CreateEvent(System.TimeSpan, System.String, System.Collections.Generic.Dictionary`2[System.String,System.String])bool w_S_S_i4i4__tS_i8_DsDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4__tS_i8_DsDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_i4i4__ (*FuncToCall)(void*,struct S_i8_ p1, void* p2, void* p3, const void* method);
    struct S_S_i4i4__ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackgroundRepeat op_Implicit(UnityEngine.UIElements.BackgroundRepeat)bool w_S_S_i4i4_i4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef struct S_S_i4i4_i4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_S_i4i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackgroundRepeat op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_i4i4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_i4i4_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_i4i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.FilteringSettings get_defaultValue()bool w_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ (*FuncToCall)(const void* method);
    struct S_S_i4i4_i4u4i4S_i2i2_S_i2i2__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// PositionEnumerator get_allPositionsWithin()bool w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4_S_i4i4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4i4_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt BoundsIntField(UnityEngine.BoundsInt, UnityEngine.GUILayoutOption[])bool w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_S_i4i4i4_S_i4i4i4__Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp1 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv1);
    S_S_i4i4i4_S_i4i4i4__ p1 = pp1 ? *pp1 : S_S_i4i4i4_S_i4i4i4__ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_S_i4i4i4_S_i4i4i4__ p1, void* p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt BoundsIntField(UnityEngine.Rect, UnityEngine.BoundsInt)bool w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_S_S_i4i4i4_S_i4i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_S_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp2 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv2);
    S_S_i4i4i4_S_i4i4i4__ p2 = pp2 ? *pp2 : S_S_i4i4i4_S_i4i4i4__ {};
        
    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_S_i4i4i4_S_i4i4i4__ p2, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt BoundsIntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.BoundsInt)bool w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_oS_S_i4i4i4_S_i4i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_oS_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp3 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv3);
    S_S_i4i4i4_S_i4i4i4__ p3 = pp3 ? *pp3 : S_S_i4i4i4_S_i4i4i4__ {};
        
    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_S_i4i4i4_S_i4i4i4__ p3, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt BoundsIntField(UnityEngine.Rect, System.String, UnityEngine.BoundsInt)bool w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_sS_S_i4i4i4_S_i4i4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__S_r4r4r4r4_sS_S_i4i4i4_S_i4i4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp3 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv3);
    S_S_i4i4i4_S_i4i4i4__ p3 = pp3 ? *pp3 : S_S_i4i4i4_S_i4i4i4__ {};
        
    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_S_i4i4i4_S_i4i4i4__ p3, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt BoundsIntField(UnityEngine.GUIContent, UnityEngine.BoundsInt, UnityEngine.GUILayoutOption[])bool w_S_S_i4i4i4_S_i4i4i4__oS_S_i4i4i4_S_i4i4i4__Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__oS_S_i4i4i4_S_i4i4i4__Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp2 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv2);
    S_S_i4i4i4_S_i4i4i4__ p2 = pp2 ? *pp2 : S_S_i4i4i4_S_i4i4i4__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(Il2CppObject* p1, struct S_S_i4i4i4_S_i4i4i4__ p2, void* p3, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt BoundsIntField(System.String, UnityEngine.BoundsInt, UnityEngine.GUILayoutOption[])bool w_S_S_i4i4i4_S_i4i4i4__sS_S_i4i4i4_S_i4i4i4__Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__sS_S_i4i4i4_S_i4i4i4__Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_S_i4i4i4_S_i4i4i4__* pp2 = DataTransfer::GetPointer<S_S_i4i4i4_S_i4i4i4__>(env, _sv2);
    S_S_i4i4i4_S_i4i4i4__ p2 = pp2 ? *pp2 : S_S_i4i4i4_S_i4i4i4__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(Il2CppString* p1, struct S_S_i4i4i4_S_i4i4i4__ p2, void* p3, const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.BoundsInt get_cellBounds()bool w_S_S_i4i4i4_S_i4i4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4i4i4_S_i4i4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_i4i4i4_S_i4i4i4__ (*FuncToCall)(void*,const void* method);
    struct S_S_i4i4i4_S_i4i4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath FromKey(System.Object)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath Pop(Unity.Properties.PropertyPath ByRef)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath AppendKey(Unity.Properties.PropertyPath ByRef, System.Object)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath Combine(Unity.Properties.PropertyPath ByRef, Unity.Properties.PropertyPath ByRef)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p2 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, void* p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath AppendPart(Unity.Properties.PropertyPath ByRef, Unity.Properties.PropertyPathPart ByRef)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_i4si4O_* p2 = DataTransfer::GetPointer<S_i4si4O_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i4si4O_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, void* p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath AppendIndex(Unity.Properties.PropertyPath ByRef, Int32)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, int32_t p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath SubPath(Unity.Properties.PropertyPath ByRef, Int32, Int32)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, int32_t p2, int32_t p3, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath AppendProperty(Unity.Properties.PropertyPath ByRef, Unity.Properties.IProperty)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, Il2CppObject* p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath Combine(Unity.Properties.PropertyPath ByRef, System.String)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal Pstruct
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_* p1 = DataTransfer::GetPointer<S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, Il2CppString* p2, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath FromPart(Unity.Properties.PropertyPathPart ByRef)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_PS_i4si4O_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4si4O_* p1 = DataTransfer::GetPointer<S_i4si4O_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4si4O_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath FromIndex(Int32)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath FromName(System.String)bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPath get_Path()bool w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ (*FuncToCall)(void*,const void* method);
    struct S_S_i4si4O_S_i4si4O_S_i4si4O_S_i4si4O_i4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleCursor op_Implicit(UnityEngine.UIElements.Cursor)bool w_S_S_oS_r4r4_i4_i4_S_oS_r4r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oS_r4r4_i4_i4_S_oS_r4r4_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oS_r4r4_i4_* pp1 = DataTransfer::GetPointer<S_oS_r4r4_i4_>(env, _sv1);
    S_oS_r4r4_i4_ p1 = pp1 ? *pp1 : S_oS_r4r4_i4_ {};
        
    typedef struct S_S_oS_r4r4_i4_i4_ (*FuncToCall)(struct S_oS_r4r4_i4_ p1, const void* method);
    struct S_S_oS_r4r4_i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleCursor op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_oS_r4r4_i4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oS_r4r4_i4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_oS_r4r4_i4_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_oS_r4r4_i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1[TResult] ConfigureAwait(Boolean)bool w_S_S_ob__tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_ob__tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_S_ob__ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_S_ob__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_S_oi4i4S_i4s___t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi4i4S_i4s___t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_oi4i4S_i4s___ (*FuncToCall)(void*,const void* method);
    struct S_S_oi4i4S_i4s___ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_S_oi4oob_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oi4oob_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_oi4oob_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_oi4oob_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.ECParameters ExportParameters()bool w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ (*FuncToCall)(void*,const void* method);
    struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.ECParameters ExportParameters(Boolean)bool w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_S_oo_oS_ooS_oo_oooi4N_bS_s__ooo__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[TResult] Create()bool w_S_S_oo_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oo_o_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_oo_o_ (*FuncToCall)(const void* method);
    struct S_S_oo_o_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackground op_Implicit(UnityEngine.UIElements.Background)bool w_S_S_oooo_i4_S_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_i4_S_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oooo_* pp1 = DataTransfer::GetPointer<S_oooo_>(env, _sv1);
    S_oooo_ p1 = pp1 ? *pp1 : S_oooo_ {};
        
    typedef struct S_S_oooo_i4_ (*FuncToCall)(struct S_oooo_ p1, const void* method);
    struct S_S_oooo_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackground op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_oooo_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_oooo_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_oooo_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleBackground op_Implicit(UnityEngine.Texture2D)bool w_S_S_oooo_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_oooo_i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_oooo_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.SearchExpressionContext get_current()bool w_S_S_oooo_ooi4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_oooo_ooi4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_oooo_ooi4_ (*FuncToCall)(void*,const void* method);
    struct S_S_oooo_ooi4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererListParams ConvertToParameters(UnityEngine.Rendering.RendererUtils.RendererListDesc ByRef)bool w_S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___PS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___PS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_* p1 = DataTransfer::GetPointer<S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ (*FuncToCall)(void* p1, const void* method);
    struct S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean)bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_Db");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, void* p2, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean)bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_Db");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, void* p3, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean)bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_S_Pvi4i4i4S_pi4i4_i4_bb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, bool p3, bool p4, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean)bool w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___tS_Pvi4i4i4S_pi4i4_i4_bb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv1);
    S_Pvi4i4i4S_pi4i4_i4_ p1 = pp1 ? *pp1 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, bool p2, bool p3, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ScopedRenderPass BeginScopedRenderPass(Int32, Int32, Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.AttachmentDescriptor], Int32)bool w_S_S_pS_pi4i4___ti4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pS_pi4i4___ti4i4i4S_Pvi4i4i4S_pi4i4_i4_Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp4 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv4);
    S_Pvi4i4i4S_pi4i4_i4_ p4 = pp4 ? *pp4 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_S_pS_pi4i4___ (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, struct S_Pvi4i4i4S_pi4i4_i4_ p4, void* p5, const void* method);
    struct S_S_pS_pi4i4___ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[T] get_Empty()bool w_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_p_i4_ (*FuncToCall)(const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Span`1[T] op_Implicit(Unity.Collections.NativeArray`1[T] ByRef)bool w_S_S_p_i4_PS_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_PS_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_Pvi4i4i4S_pi4i4_i4_* p1 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_Pvi4i4i4S_pi4i4_i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_S_p_i4_ (*FuncToCall)(void* p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[T] op_Implicit(System.Span`1[T])bool w_S_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef struct S_S_p_i4_ (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[T] op_Implicit(System.ArraySegment`1[T])bool w_S_S_p_i4_S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_S_oi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4_>(env, _sv1);
    S_oi4i4_ p1 = pp1 ? *pp1 : S_oi4i4_ {};
        
    typedef struct S_S_p_i4_ (*FuncToCall)(struct S_oi4i4_ p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[T] op_Implicit(T[])bool w_S_S_p_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_p_i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[System.Char] op_Implicit(System.String)bool w_S_S_p_i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_S_p_i4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Span`1[T] get_Span()bool w_S_S_p_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_p_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Span`1[T] GetSpan(Int32)bool w_S_S_p_i4_tDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_tDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_S_p_i4_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[System.Char] Trim(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char])bool w_S_S_p_i4_tS_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_tS_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef struct S_S_p_i4_ (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[System.Char] Trim(System.ReadOnlySpan`1[System.Char], Char)bool w_S_S_p_i4_tc(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_tc");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef struct S_S_p_i4_ (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[System.Char] AsSpan(System.String, Int32)bool w_S_S_p_i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_p_i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ReadOnlySpan`1[System.Char] AsSpan(System.String, Int32, Int32)bool w_S_S_p_i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_S_p_i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TypedReference MakeTypedReference(System.Object, System.Reflection.FieldInfo[])bool w_S_S_p_pp_Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_pp_Oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_p_pp_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_S_p_pp_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TypedReference GetNextArg()bool w_S_S_p_pp_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_pp_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_p_pp_ (*FuncToCall)(void*,const void* method);
    struct S_S_p_pp_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TypedReference GetNextArg(System.RuntimeTypeHandle)bool w_S_S_p_pp_tS_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_pp_tS_p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef struct S_S_p_pp_ (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    struct S_S_p_pp_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.LocalKeyword FindKeyword(System.String)bool w_S_S_p_su4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_su4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_S_p_su4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_S_p_su4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationLayerMixerPlayable get_Null()bool w_S_S_pu4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_pu4__ (*FuncToCall)(const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.Playable op_Implicit(UnityEngine.Animations.AnimationClipPlayable)bool w_S_S_pu4__S_S_pu4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_S_pu4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_pu4__* pp1 = DataTransfer::GetPointer<S_S_pu4__>(env, _sv1);
    S_S_pu4__ p1 = pp1 ? *pp1 : S_S_pu4__ {};
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_S_pu4__ p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.Playables.TextureMixerPlayable Create(UnityEngine.Playables.PlayableGraph)bool w_S_S_pu4__S_pu4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationLayerMixerPlayable Create(UnityEngine.Playables.PlayableGraph, Int32)bool w_S_S_pu4__S_pu4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, void* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Audio.AudioMixerPlayable Create(UnityEngine.Playables.PlayableGraph, Int32, Boolean)bool w_S_S_pu4__S_pu4_Di4Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_Di4Db");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, void* p2, void* p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationLayerMixerPlayable Create(UnityEngine.Playables.PlayableGraph, Int32, Boolean)bool w_S_S_pu4__S_pu4_i4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_i4b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, int32_t p2, bool p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationClipPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.AnimationClip)bool w_S_S_pu4__S_pu4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, Il2CppObject* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.ScriptPlayable`1[T] Create(UnityEngine.Playables.PlayableGraph, T, Int32)bool w_S_S_pu4__S_pu4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_oDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, Il2CppObject* p2, void* p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Audio.AudioClipPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.AudioClip, Boolean)bool w_S_S_pu4__S_pu4_ob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_ob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, Il2CppObject* p2, bool p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.ScriptPlayableOutput Create(UnityEngine.Playables.PlayableGraph, System.String)bool w_S_S_pu4__S_pu4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, Il2CppString* p2, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationPlayableOutput Create(UnityEngine.Playables.PlayableGraph, System.String, UnityEngine.Animator)bool w_S_S_pu4__S_pu4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__S_pu4_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_pu4_* pp1 = DataTransfer::GetPointer<S_pu4_>(env, _sv1);
    S_pu4_ p1 = pp1 ? *pp1 : S_pu4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_S_pu4__ (*FuncToCall)(struct S_pu4_ p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationMixerPlayable PlayMixer(UnityEngine.Animator, Int32, UnityEngine.Playables.PlayableGraph ByRef)bool w_S_S_pu4__oi4PS_pu4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__oi4PS_pu4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal Pstruct
    S_pu4_* p3 = DataTransfer::GetPointer<S_pu4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_pu4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef struct S_S_pu4__ (*FuncToCall)(Il2CppObject* p1, int32_t p2, void* p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.AnimationClipPlayable PlayClip(UnityEngine.Animator, UnityEngine.AnimationClip, UnityEngine.Playables.PlayableGraph ByRef)bool w_S_S_pu4__ooPS_pu4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__ooPS_pu4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal Pstruct
    S_pu4_* p3 = DataTransfer::GetPointer<S_pu4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_pu4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef struct S_S_pu4__ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, void* p3, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.PlayableOutput get_output()bool w_S_S_pu4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_pu4__ (*FuncToCall)(void*,const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.Playable GetRootPlayable(Int32)bool w_S_S_pu4__ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_pu4__ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_pu4__ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_pu4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ArticulationReducedSpace get_jointPosition()bool w_S_S_r4_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ArticulationReducedSpace GetJointForcesForAcceleration(UnityEngine.ArticulationReducedSpace)bool w_S_S_r4_i4_tS_S_r4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4_i4_tS_S_r4_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4_i4_* pp1 = DataTransfer::GetPointer<S_S_r4_i4_>(env, _sv1);
    S_S_r4_i4_ p1 = pp1 ? *pp1 : S_S_r4_i4_ {};
        
    typedef struct S_S_r4_i4_ (*FuncToCall)(void*,struct S_S_r4_i4_ p1, const void* method);
    struct S_S_r4_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.TransformOrigin Initial()bool w_S_S_r4i4_S_r4i4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4i4_S_r4i4_r4_ (*FuncToCall)(const void* method);
    struct S_S_r4i4_S_r4i4_r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.TransformOrigin get_value()bool w_S_S_r4i4_S_r4i4_r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4i4_S_r4i4_r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4i4_S_r4i4_r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Translate None()bool w_S_S_r4i4_S_r4i4_r4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4b_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4i4_S_r4i4_r4b_ (*FuncToCall)(const void* method);
    struct S_S_r4i4_S_r4i4_r4b_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Translate get_value()bool w_S_S_r4i4_S_r4i4_r4b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4i4_r4b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4i4_S_r4i4_r4b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4i4_S_r4i4_r4b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Rotate None()bool w_S_S_r4i4_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4i4_S_r4r4r4_b_ (*FuncToCall)(const void* method);
    struct S_S_r4i4_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Rotate get_value()bool w_S_S_r4i4_S_r4r4r4_b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_S_r4r4r4_b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4i4_S_r4r4r4_b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4i4_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleLength op_Implicit(UnityEngine.UIElements.Length)bool w_S_S_r4i4_i4_S_r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_i4_S_r4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4i4_* pp1 = DataTransfer::GetPointer<S_r4i4_>(env, _sv1);
    S_r4i4_ p1 = pp1 ? *pp1 : S_r4i4_ {};
        
    typedef struct S_S_r4i4_i4_ (*FuncToCall)(struct S_r4i4_ p1, const void* method);
    struct S_S_r4i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleLength op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_r4i4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4i4_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_r4i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleLength op_Implicit(Single)bool w_S_S_r4i4_i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4i4_i4_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4i4_i4_ (*FuncToCall)(float p1, const void* method);
    struct S_S_r4i4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TerrainTools.BrushTransform FromRect(UnityEngine.Rect)bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TerrainTools.BrushTransform CalculateBrushTransform(UnityEngine.Terrain, UnityEngine.Vector2, Single, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__oS_r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__oS_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, float p3, float p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ColliderDistance2D Distance(UnityEngine.Collider2D, UnityEngine.Collider2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ColliderDistance2D Distance(UnityEngine.Collider2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4i4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_S_r4r4r4_S_r4r4r4__r4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, int32_t p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, int32_t p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, int32_t p7, float p8, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32, Single, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;                if (!converter::Converter<float>::accept(env, _sv9)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(env, _sv9);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, int32_t p7, float p8, float p9, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32, Single, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_i4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, float p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<float>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(env, _sv8);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, int32_t p6, float p7, float p8, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, int32_t p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, int32_t p4, float p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32, Single, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, int32_t p4, float p5, float p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, float p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32, Single, Single)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_S_r4r4_r4S_r4r4_r4i4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, int32_t p5, float p6, float p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D GetRayIntersection(UnityEngine.Ray, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_S_r4r4r4_S_r4r4r4__r4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_S_r4r4r4_S_r4r4r4__r4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, float p2, void* p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, void* p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Linecast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.ContactFilter2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv3);
    S_bbbbbbS_i4_r4r4r4r4_ p3 = pp3 ? *pp3 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_bbbbbbS_i4_r4r4r4r4_ p3, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, void* p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CapsuleCast(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.CapsuleDirection2D, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_i4r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4_>(env, _sv5);
    S_r4r4_ p5 = pp5 ? *pp5 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp7 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv7);
    S_bbbbbbS_i4_r4r4r4r4_ p7 = pp7 ? *pp7 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, int32_t p3, float p4, struct S_r4r4_ p5, float p6, struct S_bbbbbbS_i4_r4r4r4r4_ p7, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, void* p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D Raycast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv4);
    S_bbbbbbS_i4_r4r4r4r4_ p4 = pp4 ? *pp4 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_bbbbbbS_i4_r4r4r4r4_ p4, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, void* p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D BoxCast(UnityEngine.Vector2, UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_S_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp6 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv6);
    S_bbbbbbS_i4_r4r4r4r4_ p6 = pp6 ? *pp6 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, struct S_r4r4_ p4, float p5, struct S_bbbbbbS_i4_r4r4r4r4_ p6, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, void* p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RaycastHit2D CircleCast(UnityEngine.Vector2, Single, UnityEngine.Vector2, Single, UnityEngine.ContactFilter2D)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_tS_r4r4_r4S_r4r4_r4S_bbbbbbS_i4_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_bbbbbbS_i4_r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_bbbbbbS_i4_r4r4r4r4_>(env, _sv5);
    S_bbbbbbS_i4_r4r4r4r4_ p5 = pp5 ? *pp5 : S_bbbbbbS_i4_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, float p4, struct S_bbbbbbS_i4_r4r4r4r4_ p5, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ContactPoint2D GetContact(Int32)bool w_S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_r4r4_S_r4r4_S_r4r4_r4r4r4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.PenData GetLastPenContactEvent()bool w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ (*FuncToCall)(const void* method);
    struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.PenData GetPenEvent(Int32)bool w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.TextShadow get_value()bool w_S_S_r4r4_r4S_r4r4r4r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_r4S_r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4_r4S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4_r4S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ContactPoint GetContact(Int32)bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_i4i4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.SketchUpImportCamera GetDefaultCamera()bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4r4r4r4b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIVertex GetVertexByIndex(UInt32)bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4_S_r4r4_S_r4r4_S_r4r4__tu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4_S_r4r4_S_r4r4_S_r4r4__tu4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_S_i4u1u1u1u1_S_r4r4_S_r4r4_S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds BoundsField(UnityEngine.Bounds, UnityEngine.GUILayoutOption[])bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, void* p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds TransformBounds(UnityEngine.Bounds, UnityEngine.Transform)bool w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, Il2CppObject* p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Ray GUIPointToWorldRay(UnityEngine.Vector2)bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds BoundsField(UnityEngine.Rect, UnityEngine.Bounds)bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_S_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_S_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_S_r4r4r4_S_r4r4r4__ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds BoundsField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Bounds)bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_oS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_oS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv3);
    S_S_r4r4r4_S_r4r4r4__ p3 = pp3 ? *pp3 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_S_r4r4r4_S_r4r4r4__ p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds BoundsField(UnityEngine.Rect, System.String, UnityEngine.Bounds)bool w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_sS_S_r4r4r4_S_r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4_sS_S_r4r4r4_S_r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv3);
    S_S_r4r4r4_S_r4r4r4__ p3 = pp3 ? *pp3 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_S_r4r4r4_S_r4r4r4__ p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds CalculateSelectionBounds(Boolean, Boolean)bool w_S_S_r4r4r4_S_r4r4r4__bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__bb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p1, bool p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds CalculateSelectionBounds(Boolean, Boolean, Boolean)bool w_S_S_r4r4r4_S_r4r4r4__bbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__bbb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(bool p1, bool p2, bool p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds CalculateRelativeRectTransformBounds(UnityEngine.Transform)bool w_S_S_r4r4r4_S_r4r4r4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds BoundsField(UnityEngine.GUIContent, UnityEngine.Bounds, UnityEngine.GUILayoutOption[])bool w_S_S_r4r4r4_S_r4r4r4__oS_S_r4r4r4_S_r4r4r4__Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_S_r4r4r4_S_r4r4r4__Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, void* p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Ray ScreenPointToRay(UnityEngine.Camera, UnityEngine.Vector2)bool w_S_S_r4r4r4_S_r4r4r4__oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds CalculateBounds(UnityEngine.Vector3[], UnityEngine.Matrix4x4)bool w_S_S_r4r4r4_S_r4r4r4__oS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds CalculateRelativeRectTransformBounds(UnityEngine.Transform, UnityEngine.Transform)bool w_S_S_r4r4r4_S_r4r4r4__oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds BoundsField(System.String, UnityEngine.Bounds, UnityEngine.GUILayoutOption[])bool w_S_S_r4r4r4_S_r4r4r4__sS_S_r4r4r4_S_r4r4r4__Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__sS_S_r4r4r4_S_r4r4r4__Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv2);
    S_S_r4r4r4_S_r4r4r4__ p2 = pp2 ? *pp2 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppString* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, void* p3, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds get_sourceBounds()bool w_S_S_r4r4r4_S_r4r4r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds GetBoundsLocal(UnityEngine.Vector3Int)bool w_S_S_r4r4r4_S_r4r4r4__tS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3)bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds GetBoundsLocal(UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3, MonoOrStereoscopicEye)bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Bounds GetSingleMeshWorldAABB(Int32)bool w_S_S_r4r4r4_S_r4r4r4__ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Pose get_identity()bool w_S_S_r4r4r4_S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4_S_r4r4r4r4__ (*FuncToCall)(const void* method);
    struct S_S_r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Pose GetTransformedBy(UnityEngine.Pose)bool w_S_S_r4r4r4_S_r4r4r4r4__tS_S_r4r4r4_S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4r4__tS_S_r4r4r4_S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4r4__>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4r4__ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4r4__ (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4r4__ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Pose GetTransformedBy(UnityEngine.Transform)bool w_S_S_r4r4r4_S_r4r4r4r4__to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4r4__to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_r4r4r4_S_r4r4r4r4__ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Scale None()bool w_S_S_r4r4r4_b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_b_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4_b_ (*FuncToCall)(const void* method);
    struct S_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Scale op_Implicit(UnityEngine.Vector2)bool w_S_S_r4r4r4_b_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_b_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_S_r4r4r4_b_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Scale get_value()bool w_S_S_r4r4r4_b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4_b_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Plane Normalize(System.Numerics.Plane)bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Plane Translate(UnityEngine.Plane, UnityEngine.Vector3)bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Plane Transform(System.Numerics.Plane, System.Numerics.Quaternion)bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Plane Transform(System.Numerics.Plane, System.Numerics.Matrix4x4)bool w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_S_r4r4r4_r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_S_r4r4r4_r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Plane CreateFromVertices(System.Numerics.Vector3, System.Numerics.Vector3, System.Numerics.Vector3)bool w_S_S_r4r4r4_r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Plane get_flipped()bool w_S_S_r4r4r4_r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Plane TransformPlane(UnityEngine.Plane)bool w_S_S_r4r4r4_r4_tS_S_r4r4r4_r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_tS_S_r4r4r4_r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_r4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_r4_>(env, _sv1);
    S_S_r4r4r4_r4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_r4_ {};
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(void*,struct S_S_r4r4r4_r4_ p1, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Plane GetShadowCullingPlane(Int32)bool w_S_S_r4r4r4_r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4r4_r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TreeInstance GetTreeInstance(Int32)bool w_S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_r4r4r4_r4r4r4S_i4u1u1u1u1_S_i4u1u1u1u1_i4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.CameraProperties get_cameraProperties()bool w_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UI.ColorBlock get_colors()bool w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleColor op_Implicit(UnityEngine.Color)bool w_S_S_r4r4r4r4_i4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_i4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_S_r4r4r4r4_i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4r4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleColor op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_S_r4r4r4r4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_r4r4r4r4_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_r4r4r4r4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SortingSettings get_sortingSettings()bool w_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.BlendState get_defaultValue()bool w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ (*FuncToCall)(const void* method);
    struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.BlendState get_blendState()bool w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ (*FuncToCall)(void*,const void* method);
    struct S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector`1[T] get_Zero()bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector`1[T] op_UnaryNegation(System.Numerics.Vector`1[T])bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector`1[T] op_Addition(System.Numerics.Vector`1[T], System.Numerics.Vector`1[T])bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv2);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2 = pp2 ? *pp2 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector`1[System.Single] ConditionalSelect(System.Numerics.Vector`1[System.Int32], System.Numerics.Vector`1[System.Single], System.Numerics.Vector`1[System.Single])bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv2);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2 = pp2 ? *pp2 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp3 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv3);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p3 = pp3 ? *pp3 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p3, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector`1[T] op_Multiply(System.Numerics.Vector`1[T], T)bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp1 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv1);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1 = pp1 ? *pp1 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
     // LuaValToCSVal struct
    S__* pp2 = DataTransfer::GetPointer<S__>(env, _sv2);
    S__ p2 = pp2 ? *pp2 : S__ {};
        
    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p1, struct S__ p2, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector`1[T] op_Multiply(T, System.Numerics.Vector`1[T])bool w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__S__S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
     // LuaValToCSVal struct
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__* pp2 = DataTransfer::GetPointer<S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__>(env, _sv2);
    S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2 = pp2 ? *pp2 : S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ {};
        
    typedef struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ (*FuncToCall)(struct S__ p1, struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ p2, const void* method);
    struct S_S_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1i1u2u2u2u2u2u2u2u2i2i2i2i2i2i2i2i2u4u4u4u4i4i4i4i4u8u8i8i8r4r4r4r4r8r8__ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription GetDescription(Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle)bool w_S_S_u2_u2u1u1i4i4Pu1_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u2_u2u1u1i4i4Pu1_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_S_u2_u2u1u1i4i4Pu1_ (*FuncToCall)(struct S_u8_ p1, const void* method);
    struct S_S_u2_u2u1u1i4i4Pu1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.ObjectIdentifier get_serializedObject()bool w_S_S_u4u4u4u4_i8i4s_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4_i8i4s_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u4u4u4u4_i8i4s_ (*FuncToCall)(void*,const void* method);
    struct S_S_u4u4u4u4_i8i4s_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.AI.NavMeshLocation MoveLocation(UnityEngine.Experimental.AI.NavMeshLocation, UnityEngine.Vector3, Int32)bool w_S_S_u8_S_r4r4r4__tS_S_u8_S_r4r4r4__S_r4r4r4_Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_S_r4r4r4__tS_S_u8_S_r4r4r4__S_r4r4r4_Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_u8_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_u8_S_r4r4r4__>(env, _sv1);
    S_S_u8_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_u8_S_r4r4r4__ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_u8_S_r4r4r4__ (*FuncToCall)(void*,struct S_S_u8_S_r4r4r4__ p1, struct S_r4r4r4_ p2, void* p3, const void* method);
    struct S_S_u8_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.AI.NavMeshLocation MapLocation(UnityEngine.Vector3, UnityEngine.Vector3, Int32, Int32)bool w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_r4r4r4_i4Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_r4r4r4_i4Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_S_u8_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, int32_t p3, void* p4, const void* method);
    struct S_S_u8_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.AI.NavMeshLocation CreateLocation(UnityEngine.Vector3, UnityEngine.Experimental.AI.PolygonId)bool w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_S_r4r4r4__tS_r4r4r4_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
    typedef struct S_S_u8_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_u8_ p2, const void* method);
    struct S_S_u8_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset get_Now()bool w_S_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u8_i2_ (*FuncToCall)(const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_S_u8_i2_S_S_p_i4_DoDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_p_i4_DoDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_S_u8_i2_S_S_p_i4_S_S_p_i4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_p_i4_S_S_p_i4_oDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_S_u8_i2_S_S_p_i4_ooDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_p_i4_ooDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset op_Addition(System.DateTimeOffset, System.TimeSpan)bool w_S_S_u8_i2_S_S_u8_i2_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_u8_i2_S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_u8_i2_ p1, struct S_i8_ p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ConvertTime(System.DateTimeOffset, System.TimeZoneInfo)bool w_S_S_u8_i2_S_S_u8_i2_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_u8_i2_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_u8_i2_ p1, Il2CppObject* p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ConvertTimeBySystemTimeZoneId(System.DateTimeOffset, System.String)bool w_S_S_u8_i2_S_S_u8_i2_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_S_u8_i2_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_S_u8_i2_ p1, Il2CppString* p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset op_Implicit(System.DateTime)bool w_S_S_u8_i2_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(struct S_u8_ p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset FromFileTime(Int64)bool w_S_S_u8_i2_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset op_Explicit(System.Xml.Linq.XAttribute)bool w_S_S_u8_i2_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset Parse(System.String)bool w_S_S_u8_i2_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset Parse(System.String, System.IFormatProvider)bool w_S_S_u8_i2_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset Parse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_S_u8_i2_soi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_soi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_S_u8_i2_sooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_sooi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ToDateTimeOffset(System.String, System.String)bool w_S_S_u8_i2_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ParseExact(System.String, System.String, System.IFormatProvider)bool w_S_S_u8_i2_sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_sso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles)bool w_S_S_u8_i2_ssoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ssoi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ToLocalTime()bool w_S_S_u8_i2_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset ToOffset(System.TimeSpan)bool w_S_S_u8_i2_tS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset AddMonths(Int32)bool w_S_S_u8_i2_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset AddTicks(Int64)bool w_S_S_u8_i2_ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ti8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,int64_t p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset AddDays(Double)bool w_S_S_u8_i2_tr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_tr8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,double p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.DateTimeOffset GetCreationTime(System.String)bool w_S_S_u8_i2_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8_i2_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_S_u8_i2_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_S_u8_i2_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Loading.ContentFileUnloadHandle UnloadAsync()bool w_S_S_u8i4i4p__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8i4i4p__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u8i4i4p__ (*FuncToCall)(void*,const void* method);
    struct S_S_u8i4i4p__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.GlobalObjectId GetGlobalObjectIdSlow(Int32)bool w_S_S_u8u8_S_u4u4u4u4_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8_S_u4u4u4u4_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_S_u8u8_S_u4u4u4u4_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_u8u8_S_u4u4u4u4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.GlobalObjectId GetGlobalObjectIdSlow(UnityEngine.Object)bool w_S_S_u8u8_S_u4u4u4u4_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8_S_u4u4u4u4_i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_S_u8u8_S_u4u4u4u4_i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_u8u8_S_u4u4u4u4_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.GlobalObjectId get_globalObjectId()bool w_S_S_u8u8_S_u4u4u4u4_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8_S_u4u4u4u4_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_S_u8u8_S_u4u4u4u4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_S_u8u8_S_u4u4u4u4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Experimental.ArtifactID LookupArtifact(UnityEditor.Experimental.ArtifactKey)bool w_S_S_u8u8__S_S_u4u4u4u4_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u8u8__S_S_u4u4u4u4_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4u4u4u4_o_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(env, _sv1);
    S_S_u4u4u4u4_o_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_o_ {};
        
    typedef struct S_S_u8u8__ (*FuncToCall)(struct S_S_u4u4u4u4_o_ p1, const void* method);
    struct S_S_u8u8__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ValueTuple Create()bool w_S__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S__ (*FuncToCall)(const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// T op_Explicit(System.Nullable`1[T])bool w_S__S_bS___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__S_bS___");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_bS___* pp1 = DataTransfer::GetPointer<S_bS___>(env, _sv1);
    S_bS___ p1 = pp1 ? *pp1 : S_bS___ {};
        
    typedef struct S__ (*FuncToCall)(struct S_bS___ p1, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GPUFence CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)bool w_S__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S__ (*FuncToCall)(int32_t p1, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// T get_Value()bool w_S__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S__ (*FuncToCall)(void*,const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// T GetValueOrDefault(T)bool w_S__tS__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__tS__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef struct S__ (*FuncToCall)(void*,struct S__ p1, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// T get_Item(Int32)bool w_S__ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S__ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// T GetValueFromBag(UnityEngine.UIElements.IUxmlAttributes, UnityEngine.UIElements.CreationContext)bool w_S__toS_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S__toS_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_oooo_* pp2 = DataTransfer::GetPointer<S_oooo_>(env, _sv2);
    S_oooo_ p2 = pp2 ? *pp2 : S_oooo_ {};
        
    typedef struct S__ (*FuncToCall)(void*,Il2CppObject* p1, struct S_oooo_ p2, const void* method);
    struct S__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ParallelLoopResult For(Int32, Int32, System.Action`1[System.Int32])bool w_S_bN_bi8__i4i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i4i4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_bN_bi8__ (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ParallelLoopResult For(Int32, Int32, System.Threading.Tasks.ParallelOptions, System.Action`1[System.Int32])bool w_S_bN_bi8__i4i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i4i4oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_bN_bi8__ (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ParallelLoopResult For(Int64, Int64, System.Action`1[System.Int64])bool w_S_bN_bi8__i8i8o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i8i8o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_bN_bi8__ (*FuncToCall)(int64_t p1, int64_t p2, Il2CppObject* p3, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.Tasks.ParallelLoopResult For(Int64, Int64, System.Threading.Tasks.ParallelOptions, System.Action`1[System.Int64])bool w_S_bN_bi8__i8i8oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bN_bi8__i8i8oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int64_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_bN_bi8__ (*FuncToCall)(int64_t p1, int64_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_bN_bi8__ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Nullable`1[T] op_Implicit(T)bool w_S_bS___S__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS___S__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S__* pp1 = DataTransfer::GetPointer<S__>(env, _sv1);
    S__ p1 = pp1 ? *pp1 : S__ {};
        
    typedef struct S_bS___ (*FuncToCall)(struct S__ p1, const void* method);
    struct S_bS___ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.SceneManagement.StageHandle GetCurrentStageHandle()bool w_S_bS_i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_bS_i4__ (*FuncToCall)(const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.SceneManagement.StageHandle GetStageHandle(UnityEngine.SceneManagement.Scene)bool w_S_bS_i4__S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__S_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef struct S_bS_i4__ (*FuncToCall)(struct S_i4_ p1, const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.SceneManagement.StageHandle GetStageHandle(UnityEngine.GameObject)bool w_S_bS_i4__o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_bS_i4__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.SceneManagement.StageHandle get_stageHandle()bool w_S_bS_i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bS_i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_bS_i4__ (*FuncToCall)(void*,const void* method);
    struct S_bS_i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// State GetCurveState(UnityEngine.AnimationClip, UnityEditor.EditorCurveBinding[])bool w_S_bbbb_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbb_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_bbbb_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_bbbb_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.ContactFilter2D NoFilter()bool w_S_bbbbbbS_i4_r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbbbbS_i4_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_bbbbbbS_i4_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_bbbbbbS_i4_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Rendering.PlatformShaderSettings GetShaderSettingsForPlatform(UnityEditor.BuildTargetGroup, UnityEngine.Rendering.ShaderHardwareTier)bool w_S_bbbi4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbi4_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_bbbi4_ (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    struct S_bbbi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.PhysicsJobOptions2D get_jobOptions()bool w_S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_bbi4i4i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.AsyncFlowControl SuppressFlow()bool w_S_boo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_boo_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_boo_ (*FuncToCall)(const void* method);
    struct S_boo_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TestResult testDoString2LoadLua_Step_1()bool w_S_bs_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bs_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_bs_ (*FuncToCall)(void*,const void* method);
    struct S_bs_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ConsoleKeyInfo ReadKey()bool w_S_ci4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ci4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ci4i4_ (*FuncToCall)(const void* method);
    struct S_ci4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ConsoleKeyInfo ReadKey(Boolean)bool w_S_ci4i4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ci4i4_b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_ci4i4_ (*FuncToCall)(bool p1, const void* method);
    struct S_ci4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SortingLayerRange get_all()bool w_S_i2i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i2i2_ (*FuncToCall)(const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Section CreateSection(Int16)bool w_S_i2i2_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_i2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef struct S_i2i2_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Section CreateSection(Int16, Section)bool w_S_i2i2_i2S_i2i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_i2S_i2i2_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i2i2_* pp2 = DataTransfer::GetPointer<S_i2i2_>(env, _sv2);
    S_i2i2_ p2 = pp2 ? *pp2 : S_i2i2_ {};
        
    typedef struct S_i2i2_ (*FuncToCall)(int16_t p1, struct S_i2i2_ p2, const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.SortingLayerRange get_sortingLayerRange()bool w_S_i2i2_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i2i2_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i2i2_ (*FuncToCall)(void*,const void* method);
    struct S_i2i2_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleTextShadow op_Implicit(UnityEngine.UIElements.TextShadow)bool w_S_i4S_S_r4r4_r4S_r4r4r4r4___S_S_r4r4_r4S_r4r4r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_S_r4r4_r4S_r4r4r4r4___S_S_r4r4_r4S_r4r4r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4_r4S_r4r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4r4r4__>(env, _sv1);
    S_S_r4r4_r4S_r4r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4_r4S_r4r4r4r4__ {};
        
    typedef struct S_i4S_S_r4r4_r4S_r4r4r4r4___ (*FuncToCall)(struct S_S_r4r4_r4S_r4r4r4r4__ p1, const void* method);
    struct S_i4S_S_r4r4_r4S_r4r4r4r4___ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleTextShadow op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_i4S_S_r4r4_r4S_r4r4r4r4___i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_S_r4r4_r4S_r4r4r4r4___i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4S_S_r4r4_r4S_r4r4r4r4___ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4S_S_r4r4_r4S_r4r4r4r4___ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleFontDefinition op_Implicit(UnityEngine.UIElements.FontDefinition)bool w_S_i4S_oo__S_oo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_oo__S_oo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oo_* pp1 = DataTransfer::GetPointer<S_oo_>(env, _sv1);
    S_oo_ p1 = pp1 ? *pp1 : S_oo_ {};
        
    typedef struct S_i4S_oo__ (*FuncToCall)(struct S_oo_ p1, const void* method);
    struct S_i4S_oo__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleFontDefinition op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_i4S_oo__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_oo__i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4S_oo__ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4S_oo__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.BackgroundSize get_value()bool w_S_i4S_r4i4_S_r4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4i4_S_r4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4S_r4i4_S_r4i4__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_r4i4_S_r4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.BackgroundPosition get_value()bool w_S_i4S_r4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4S_r4i4__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_r4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Touch GetSecondaryTouch(Int32)bool w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Touch GetTouch(Int32)bool w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.LODParameters get_lodParameters()bool w_S_i4S_r4r4r4_r4r4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4r4_r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4S_r4r4r4_r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4S_r4r4r4_r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ShadowSplitData get_splitData()bool w_S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Index get_Start()bool w_S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4_ (*FuncToCall)(const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshLinkInstance AddLink(UnityEngine.AI.NavMeshLinkData)bool w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshLinkInstance AddLink(UnityEngine.AI.NavMeshLinkData, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_>(env, _sv1);
    S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4_r4i4r4i4i4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Index FromStart(Int32)bool w_S_i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.SceneManagement.Scene LoadScene(Int32, UnityEngine.SceneManagement.LoadSceneParameters)bool w_S_i4_i4S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(int32_t p1, struct S_i4i4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.SceneManagement.Scene NewScene(UnityEditor.SceneManagement.NewSceneSetup, UnityEditor.SceneManagement.NewSceneMode)bool w_S_i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4_ (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshDataInstance AddNavMeshData(UnityEngine.AI.NavMeshData)bool w_S_i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshDataInstance AddNavMeshData(UnityEngine.AI.NavMeshData, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_S_i4_oS_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_oS_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Cache AddCache(System.String)bool w_S_i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.SceneManagement.Scene CreateScene(System.String, UnityEngine.SceneManagement.CreateSceneParameters)bool w_S_i4_sS_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_sS_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p1, struct S_i4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.SceneManagement.Scene LoadScene(System.String, UnityEngine.SceneManagement.LoadSceneParameters)bool w_S_i4_sS_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_sS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p1, struct S_i4i4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.SceneManagement.Scene OpenScene(System.String, UnityEditor.SceneManagement.OpenSceneMode)bool w_S_i4_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_si4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4_ (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Index get_Start()bool w_S_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ShaderTagId GetShaderPassName(Int32)bool w_S_i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, UnityEngine.Rendering.ShaderTagId)bool w_S_i4_ti4S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4S_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p1, struct S_i4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, Int32, UnityEngine.Rendering.ShaderTagId)bool w_S_i4_ti4i4S_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4i4S_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_i4_* pp3 = DataTransfer::GetPointer<S_i4_>(env, _sv3);
    S_i4_ p3 = pp3 ? *pp3 : S_i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, struct S_i4_ p3, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.Emit.MethodToken GetMethodToken(System.Reflection.MethodInfo)bool w_S_i4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.Emit.SignatureToken GetSignatureToken(Byte[], Int32)bool w_S_i4_toi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_toi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.Emit.MethodToken GetMethodToken(System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable`1[System.Type])bool w_S_i4_too(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_too");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.Emit.MethodToken GetArrayMethodToken(System.Type, System.String, System.Reflection.CallingConventions, System.Type, System.Type[])bool w_S_i4_tosi4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_tosi4oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.Emit.StringToken GetStringConstant(System.String)bool w_S_i4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.QueryParameters get_Default()bool w_S_i4bi4b_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4bi4b_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4bi4b_ (*FuncToCall)(const void* method);
    struct S_i4bi4b_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UI.Navigation get_defaultNavigation()bool w_S_i4boooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4boooo_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4boooo_ (*FuncToCall)(const void* method);
    struct S_i4boooo_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UI.Navigation get_navigation()bool w_S_i4boooo_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4boooo_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4boooo_ (*FuncToCall)(void*,const void* method);
    struct S_i4boooo_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid NewGuid()bool w_S_i4i2i2u1u1u1u1u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid Parse(System.ReadOnlySpan`1[System.Char])bool w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char])bool w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_S_S_p_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_S_S_p_i4_S_S_p_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid GenerateGuidForType(System.Type)bool w_S_i4i2i2u1u1u1u1u1u1u1u1_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid Parse(System.String)bool w_S_i4i2i2u1u1u1u1u1u1u1u1_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid ParseExact(System.String, System.String)bool w_S_i4i2i2u1u1u1u1u1u1u1u1_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Guid get_InheritedObjectType()bool w_S_i4i2i2u1u1u1u1u1u1u1u1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i2i2u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i2i2u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_i4i2i2u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TableAutoTransComplexStruct ComplexStructMethod(TableAutoTransComplexStruct)bool w_S_i4i4S_i4i4i4i4u8_S_u1__tS_i4i4S_i4i4i4i4u8_S_u1__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4S_i4i4i4i4u8_S_u1__tS_i4i4S_i4i4i4i4u8_S_u1__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4S_i4i4i4i4u8_S_u1__* pp1 = DataTransfer::GetPointer<S_i4i4S_i4i4i4i4u8_S_u1__>(env, _sv1);
    S_i4i4S_i4i4i4i4u8_S_u1__ p1 = pp1 ? *pp1 : S_i4i4S_i4i4i4i4u8_S_u1__ {};
        
    typedef struct S_i4i4S_i4i4i4i4u8_S_u1__ (*FuncToCall)(void*,struct S_i4i4S_i4i4i4i4u8_S_u1__ p1, const void* method);
    struct S_i4i4S_i4i4i4i4u8_S_u1__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Resolution get_currentResolution()bool w_S_i4i4S_u4u4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4S_u4u4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4S_u4u4__ (*FuncToCall)(const void* method);
    struct S_i4i4S_u4u4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int get_mainWindowPosition()bool w_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int op_UnaryNegation(UnityEngine.Vector2Int)bool w_S_i4i4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int Min(UnityEngine.Vector2Int, UnityEngine.Vector2Int)bool w_S_i4i4_S_i4i4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int op_Multiply(UnityEngine.Vector2Int, Int32)bool w_S_i4i4_S_i4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p1, int32_t p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int op_Explicit(UnityEngine.Vector3Int)bool w_S_i4i4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int FloorToInt(UnityEngine.Vector2)bool w_S_i4i4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int Vector2IntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector2Int)bool w_S_i4i4_S_r4r4r4r4_oS_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4r4r4_oS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4_>(env, _sv3);
    S_i4i4_ p3 = pp3 ? *pp3 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_i4i4_ p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int Vector2IntField(UnityEngine.Rect, System.String, UnityEngine.Vector2Int)bool w_S_i4i4_S_r4r4r4r4_sS_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4r4r4_sS_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4_>(env, _sv3);
    S_i4i4_ p3 = pp3 ? *pp3 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_i4i4_ p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.PropertyName op_Implicit(Int32)bool w_S_i4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int op_Multiply(Int32, UnityEngine.Vector2Int)bool w_S_i4i4_i4S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_i4S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(int32_t p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int Vector2IntField(UnityEngine.GUIContent, UnityEngine.Vector2Int, UnityEngine.GUILayoutOption[])bool w_S_i4i4_oS_i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_oS_i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4_ (*FuncToCall)(Il2CppObject* p1, struct S_i4i4_ p2, void* p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextureMipmapLimitSettings GetTextureMipmapLimitSettings(System.String)bool w_S_i4i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4i4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int Vector2IntField(System.String, UnityEngine.Vector2Int, UnityEngine.GUILayoutOption[])bool w_S_i4i4_sS_i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_sS_i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4_ (*FuncToCall)(Il2CppString* p1, struct S_i4i4_ p2, void* p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int get_min()bool w_S_i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ValueTuple`2[System.Int32,System.Int32] GetOffsetAndLength(Int32)bool w_S_i4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2Int GetBrushOffset(Int32, Int32)bool w_S_i4i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.U2D.SpriteAtlasPackingSettings GetPackingSettings(UnityEngine.U2D.SpriteAtlas)bool w_S_i4i4bbbb_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4bbbb_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4bbbb_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4bbbb_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Rendering.TierSettings GetTierSettings(UnityEditor.Build.NamedBuildTarget, UnityEngine.Rendering.GraphicsTier)bool w_S_i4i4bbbbbbbbi4i4_S_s_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4bbbbbbbbi4i4_S_s_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_s_* pp1 = DataTransfer::GetPointer<S_s_>(env, _sv1);
    S_s_ p1 = pp1 ? *pp1 : S_s_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4bbbbbbbbi4i4_ (*FuncToCall)(struct S_s_ p1, int32_t p2, const void* method);
    struct S_i4i4bbbbbbbbi4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Rendering.TierSettings GetTierSettings(UnityEditor.BuildTargetGroup, UnityEngine.Rendering.GraphicsTier)bool w_S_i4i4bbbbbbbbi4i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4bbbbbbbbi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4bbbbbbbbi4i4_ (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    struct S_i4i4bbbbbbbbi4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Mono.Cecil.Cil.ImageDebugDirectory get_Directory()bool w_S_i4i4i2i2i4i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i2i2i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i2i2i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i2i2i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int get_zero()bool w_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int op_Explicit(UnityEngine.Vector2Int)bool w_S_i4i4i4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int op_UnaryNegation(UnityEngine.Vector3Int)bool w_S_i4i4i4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int Min(UnityEngine.Vector3Int, UnityEngine.Vector3Int)bool w_S_i4i4i4_S_i4i4i4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p1, struct S_i4i4i4_ p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int op_Multiply(UnityEngine.Vector3Int, Int32)bool w_S_i4i4i4_S_i4i4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4i4_ p1, int32_t p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int FloorToInt(UnityEngine.Vector3)bool w_S_i4i4i4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int Vector3IntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector3Int)bool w_S_i4i4i4_S_r4r4r4r4_oS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r4r4r4r4_oS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv3);
    S_i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_i4i4i4_ p3, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int Vector3IntField(UnityEngine.Rect, System.String, UnityEngine.Vector3Int)bool w_S_i4i4i4_S_r4r4r4r4_sS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_r4r4r4r4_sS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv3);
    S_i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_i4i4i4_ p3, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int op_Multiply(Int32, UnityEngine.Vector3Int)bool w_S_i4i4i4_i4S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_i4S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(int32_t p1, struct S_i4i4i4_ p2, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int Vector3IntField(UnityEngine.GUIContent, UnityEngine.Vector3Int, UnityEngine.GUILayoutOption[])bool w_S_i4i4i4_oS_i4i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_oS_i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4i4_ (*FuncToCall)(Il2CppObject* p1, struct S_i4i4i4_ p2, void* p3, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int Vector3IntField(System.String, UnityEngine.Vector3Int, UnityEngine.GUILayoutOption[])bool w_S_i4i4i4_sS_i4i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_sS_i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv2);
    S_i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4i4_ (*FuncToCall)(Il2CppString* p1, struct S_i4i4i4_ p2, void* p3, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.LockCookie ReleaseLock()bool w_S_i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.LockCookie UpgradeToWriterLock(System.TimeSpan)bool w_S_i4i4i4_tS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3Int LocalToCell(UnityEngine.Vector3)bool w_S_i4i4i4_tS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.LockCookie UpgradeToWriterLock(Int32)bool w_S_i4i4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AnimatorTransitionInfo GetAnimatorTransitionInfo(Int32)bool w_S_i4i4i4br4r4bi4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4br4r4bi4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4br4r4bi4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4i4br4r4bi4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.OffMeshLinkData get_currentOffMeshLinkData()bool w_S_i4i4i4i4S_r4r4r4_S_r4r4r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4S_r4r4r4_S_r4r4r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// State get_state()bool w_S_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt RectIntField(UnityEngine.RectInt, UnityEngine.GUILayoutOption[])bool w_S_i4i4i4i4_S_i4i4i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_i4i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_i4i4i4i4_ p1, void* p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt RectIntField(UnityEngine.Rect, UnityEngine.RectInt)bool w_S_i4i4i4i4_S_r4r4r4r4_S_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_S_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_i4i4i4i4_ p2, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt RectIntField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.RectInt)bool w_S_i4i4i4i4_S_r4r4r4r4_oS_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_oS_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv3);
    S_i4i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4i4_ {};
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_i4i4i4i4_ p3, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt RectIntField(UnityEngine.Rect, System.String, UnityEngine.RectInt)bool w_S_i4i4i4i4_S_r4r4r4r4_sS_i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_S_r4r4r4r4_sS_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv3);
    S_i4i4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4i4_ {};
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_i4i4i4i4_ p3, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt RectIntField(UnityEngine.GUIContent, UnityEngine.RectInt, UnityEngine.GUILayoutOption[])bool w_S_i4i4i4i4_oS_i4i4i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_oS_i4i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(Il2CppObject* p1, struct S_i4i4i4i4_ p2, void* p3, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt RectIntField(System.String, UnityEngine.RectInt, UnityEngine.GUILayoutOption[])bool w_S_i4i4i4i4_sS_i4i4i4i4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_sS_i4i4i4i4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(Il2CppString* p1, struct S_i4i4i4i4_ p2, void* p3, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RectInt get_pixelRect()bool w_S_i4i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.VertexAttributeDescriptor GetVertexAttribute(Int32)bool w_S_i4i4i4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.LightBakingOutput get_bakingOutput()bool w_S_i4i4i4i4b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AudioConfiguration GetConfiguration()bool w_S_i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.U2D.SpriteAtlasTextureSettings GetTextureSettings(UnityEngine.U2D.SpriteAtlas)bool w_S_i4i4i4i4i4bbbb_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4bbbb_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4i4bbbb_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4bbbb_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.MemoryProfiler.VirtualMachineInformation get_virtualMachineInformation()bool w_S_i4i4i4i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RenderTextureDescriptor get_eyeTextureDesc()bool w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RenderTextureDescriptor get_descriptor()bool w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.Object)bool w_S_i4i4i4i4u8_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.Object, System.IFormatProvider)bool w_S_i4i4i4i4u8_Oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_Oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_S_i4i4i4i4u8_S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_S_p_i4_Di4Do");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.Decimal)bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Max(System.Decimal, System.Decimal)bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Clamp(System.Decimal, System.Decimal, System.Decimal)bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp3 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv3);
    S_i4i4i4i4u8_ p3 = pp3 ? *pp3 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, struct S_i4i4i4i4u8_ p3, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Round(System.Decimal, Int32)bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, int32_t p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Round(System.Decimal, Int32, System.MidpointRounding)bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, int32_t p2, int32_t p3, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal op_Explicit(System.Numerics.BigInteger)bool w_S_i4i4i4i4u8_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4o_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.DateTime)bool w_S_i4i4i4i4u8_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Boolean)bool w_S_i4i4i4i4u8_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_b");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(bool p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Char)bool w_S_i4i4i4i4u8_c(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_c");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppChar>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppChar p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(SByte)bool w_S_i4i4i4i4u8_i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int8_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Int16)bool w_S_i4i4i4i4u8_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Int32)bool w_S_i4i4i4i4u8_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Int64)bool w_S_i4i4i4i4u8_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal op_Explicit(System.Xml.Linq.XAttribute)bool w_S_i4i4i4i4u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Single)bool w_S_i4i4i4i4u8_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(float p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Double)bool w_S_i4i4i4i4u8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(double p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.String)bool w_S_i4i4i4i4u8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Parse(System.String, System.Globalization.NumberStyles)bool w_S_i4i4i4i4u8_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_si4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_S_i4i4i4i4u8_si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_si4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.String, System.IFormatProvider)bool w_S_i4i4i4i4u8_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal get_Value()bool w_S_i4i4i4i4u8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(System.Object)bool w_S_i4i4i4i4u8_tO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal DecimalParamMethod(System.Decimal)bool w_S_i4i4i4i4u8_tS_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tS_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal NextDecimal(System.Decimal, System.Decimal)bool w_S_i4i4i4i4u8_tS_i4i4i4i4u8_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tS_i4i4i4i4u8_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv2);
    S_i4i4i4i4u8_ p2 = pp2 ? *pp2 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p1, struct S_i4i4i4i4u8_ p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ReadDecimal(Int64)bool w_S_i4i4i4i4u8_ti8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_ti8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,int64_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal GetDecimal(IntPtr, Int32)bool w_S_i4i4i4i4u8_tpi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tpi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,void* p1, int32_t p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal GetDecimal(System.String)bool w_S_i4i4i4i4u8_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ReadElementContentAsDecimal(System.String, System.String)bool w_S_i4i4i4i4u8_tss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_tss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(Byte)bool w_S_i4i4i4i4u8_u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint8_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(UInt16)bool w_S_i4i4i4i4u8_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(UInt32)bool w_S_i4i4i4i4u8_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Decimal ToDecimal(UInt64)bool w_S_i4i4i4i4u8_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint64_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.RenderBuffer)bool w_S_i4i4i4pi4i4i4_S_i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_S_i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(struct S_i4p_ p1, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Rendering.BuiltinRenderTextureType)bool w_S_i4i4i4pi4i4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Texture)bool w_S_i4i4i4pi4i4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(System.String)bool w_S_i4i4i4pi4i4i4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RenderTargetIdentifier get_depthRenderTarget()bool w_S_i4i4i4pi4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4pi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4pi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AnimatorStateInfo get_animatorStateInfo()bool w_S_i4i4i4r4r4r4r4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4r4r4r4r4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4i4r4r4r4r4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4r4r4r4r4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AnimatorStateInfo GetCurrentAnimatorStateInfo(Int32)bool w_S_i4i4i4r4r4r4r4i4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4r4r4r4r4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4i4r4r4r4r4i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4i4r4r4r4r4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RasterState get_rasterState()bool w_S_i4i4r4u1u1u1u1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4r4u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4r4u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4r4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// ConStruct get_IncludeStruct()bool w_S_i4i4s_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4s_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4s_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4s_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.AudioImporterSampleSettings get_defaultSampleSettings()bool w_S_i4i4u4i4r4i4b_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4u4i4r4i4b_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4i4u4i4r4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4u4i4r4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.AudioImporterSampleSettings GetOverrideSampleSettings(UnityEditor.BuildTargetGroup)bool w_S_i4i4u4i4r4i4b_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4u4i4r4i4b_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4i4u4i4r4i4b_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4u4i4r4i4b_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.AudioImporterSampleSettings GetOverrideSampleSettings(System.String)bool w_S_i4i4u4i4r4i4b_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4u4i4r4i4b_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4i4u4i4r4i4b_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_i4i4u4i4r4i4b_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_i4oS_oi4i4o_S_oS_i4b_oi4_o_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4oS_oi4i4o_S_oS_i4b_oi4_o_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4oS_oi4i4o_S_oS_i4b_oi4_o_ (*FuncToCall)(void*,const void* method);
    struct S_i4oS_oi4i4o_S_oS_i4b_oi4_o_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger get_Zero()bool w_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4o_ (*FuncToCall)(const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Parse(System.ReadOnlySpan`1[System.Char], System.Globalization.NumberStyles, System.IFormatProvider)bool w_S_i4o_S_S_p_i4_Di4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_S_p_i4_Di4Do");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, void* p3, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Explicit(System.Decimal)bool w_S_i4o_S_i4i4i4i4u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4i4i4i4u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Abs(System.Numerics.BigInteger)bool w_S_i4o_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Add(System.Numerics.BigInteger, System.Numerics.BigInteger)bool w_S_i4o_S_i4o_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p1, struct S_i4o_ p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger DivRem(System.Numerics.BigInteger, System.Numerics.BigInteger, System.Numerics.BigInteger ByRef)bool w_S_i4o_S_i4o_S_i4o_PS_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_S_i4o_PS_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
     // LuaValToCSVal Pstruct
    S_i4o_* p3 = DataTransfer::GetPointer<S_i4o_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_i4o_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p1, struct S_i4o_ p2, void* p3, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger ModPow(System.Numerics.BigInteger, System.Numerics.BigInteger, System.Numerics.BigInteger)bool w_S_i4o_S_i4o_S_i4o_S_i4o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_S_i4o_S_i4o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
     // LuaValToCSVal struct
    S_i4o_* pp2 = DataTransfer::GetPointer<S_i4o_>(env, _sv2);
    S_i4o_ p2 = pp2 ? *pp2 : S_i4o_ {};
        
     // LuaValToCSVal struct
    S_i4o_* pp3 = DataTransfer::GetPointer<S_i4o_>(env, _sv3);
    S_i4o_ p3 = pp3 ? *pp3 : S_i4o_ {};
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p1, struct S_i4o_ p2, struct S_i4o_ p3, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Pow(System.Numerics.BigInteger, Int32)bool w_S_i4o_S_i4o_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_S_i4o_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4o_* pp1 = DataTransfer::GetPointer<S_i4o_>(env, _sv1);
    S_i4o_ p1 = pp1 ? *pp1 : S_i4o_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4o_ (*FuncToCall)(struct S_i4o_ p1, int32_t p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(SByte)bool w_S_i4o_i1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(int8_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(Int16)bool w_S_i4o_i2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleList`1[T] op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_i4o_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(Int64)bool w_S_i4o_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleList`1[T] op_Implicit(System.Collections.Generic.List`1[T])bool w_S_i4o_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i4o_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Explicit(Single)bool w_S_i4o_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(float p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Explicit(Double)bool w_S_i4o_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(double p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Parse(System.String)bool w_S_i4o_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Parse(System.String, System.Globalization.NumberStyles)bool w_S_i4o_si4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_si4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Parse(System.String, System.Globalization.NumberStyles, System.IFormatProvider)bool w_S_i4o_si4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_si4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger Parse(System.String, System.IFormatProvider)bool w_S_i4o_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_i4o_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(Byte)bool w_S_i4o_u1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u1");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint8_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(uint8_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(UInt16)bool w_S_i4o_u2(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u2");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint16_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(UInt32)bool w_S_i4o_u4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.BigInteger op_Implicit(UInt64)bool w_S_i4o_u8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4o_u8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4o_ (*FuncToCall)(uint64_t p1, const void* method);
    struct S_i4o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyCollection`1[System.Collections.Generic.KeyValuePair`2[TKey,TValue]] GetProperties()bool w_S_i4ooS_oS_oo___t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ooS_oS_oo___t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4ooS_oS_oo___ (*FuncToCall)(void*,const void* method);
    struct S_i4ooS_oS_oo___ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyCollection`1[System.Collections.Generic.KeyValuePair`2[TKey,TValue]] GetProperties(System.Collections.Generic.KeyValuePair`2[TKey,TValue] ByRef)bool w_S_i4ooS_oS_oo___tPS_oo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ooS_oS_oo___tPS_oo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_oo_* p1 = DataTransfer::GetPointer<S_oo_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_oo_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_i4ooS_oS_oo___ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_i4ooS_oS_oo___ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyCollection`1[TContainer] get_Empty()bool w_S_i4ooS_oo__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ooS_oo__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4ooS_oo__ (*FuncToCall)(const void* method);
    struct S_i4ooS_oo__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyCollection`1[TContainer] GetProperties()bool w_S_i4ooS_oo__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ooS_oo__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4ooS_oo__ (*FuncToCall)(void*,const void* method);
    struct S_i4ooS_oo__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyCollection`1[TContainer] GetProperties(TContainer ByRef)bool w_S_i4ooS_oo__tPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ooS_oo__tPo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef struct S_i4ooS_oo__ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_i4ooS_oo__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Presets.PresetType GetPresetType()bool w_S_i4os_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4os_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4os_ (*FuncToCall)(void*,const void* method);
    struct S_i4os_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RenderBuffer get_activeColorBuffer()bool w_S_i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4p_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4p_ (*FuncToCall)(const void* method);
    struct S_i4p_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.RenderBuffer get_colorBuffer()bool w_S_i4p_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4p_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4p_ (*FuncToCall)(void*,const void* method);
    struct S_i4p_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.GlobalIllumination.Cookie Defaults()bool w_S_i4r4S_r4r4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4S_r4r4__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4r4S_r4r4__ (*FuncToCall)(const void* method);
    struct S_i4r4S_r4r4__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Experimental.OnDemandProgress GetOnDemandArtifactProgress(UnityEditor.Experimental.ArtifactKey)bool w_S_i4r4_S_S_u4u4u4u4_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_S_S_u4u4u4u4_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u4u4u4u4_o_* pp1 = DataTransfer::GetPointer<S_S_u4u4u4u4_o_>(env, _sv1);
    S_S_u4u4u4u4_o_ p1 = pp1 ? *pp1 : S_S_u4u4u4u4_o_ {};
        
    typedef struct S_i4r4_ (*FuncToCall)(struct S_S_u4u4u4u4_o_ p1, const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Experimental.OnDemandProgress GetOnDemandArtifactProgress(System.String)bool w_S_i4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Experimental.OnDemandProgress GetOnDemandArtifactProgress(System.String, System.Type)bool w_S_i4r4_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_i4r4_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AnimatorClipInfo get_animatorClipInfo()bool w_S_i4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.PhysicsShape2D GetShape(Int32)bool w_S_i4r4i4i4i4i4S_r4r4_S_r4r4__ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4i4i4i4i4S_r4r4_S_r4r4__ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4r4i4i4i4i4S_r4r4_S_r4r4__ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4r4i4i4i4i4S_r4r4_S_r4r4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// MinMaxCurve get_directionX()bool w_S_i4r4oor4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4oor4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4r4oor4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4oor4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshBuildSettings CreateSettings()bool w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ (*FuncToCall)(const void* method);
    struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshBuildSettings GetSettingsByID(Int32)bool w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4r4r4r4r4r4r4r4i4r4i4i4i4u4i4S_u1__ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.NVIDIA.DLSSCommandExecutionData get_execData()bool w_S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4r4r4r4r4r4u4u4u4u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StylePropertyName op_Implicit(System.String)bool w_S_i4s_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4s_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i4s_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4s_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Properties.PropertyPathPart get_Item(Int32)bool w_S_i4si4O_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4si4O_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4si4O_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4si4O_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// CameraMode GetBuiltinCameraMode(UnityEditor.DrawCameraMode)bool w_S_i4ss_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ss_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4ss_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4ss_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// CameraMode AddCameraMode(System.String, System.String)bool w_S_i4ss_ss(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ss_ss");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_i4ss_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    struct S_i4ss_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// CameraMode get_cameraMode()bool w_S_i4ss_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ss_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4ss_ (*FuncToCall)(void*,const void* method);
    struct S_i4ss_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.IO.WaitForChangedResult WaitForChanged(System.IO.WatcherChangeTypes)bool w_S_i4ssb_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssb_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i4ssb_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4ssb_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.IO.WaitForChangedResult WaitForChanged(System.IO.WatcherChangeTypes, Int32)bool w_S_i4ssb_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssb_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_i4ssb_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_i4ssb_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextCore.FaceInfo GetFaceInfo()bool w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextCore.FaceInfo get_faceInfo()bool w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4ssi4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color32 PassAndReturnColor32(UnityEngine.Color32)bool w_S_i4u1u1u1u1_S_i4u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_S_i4u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
        
    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(struct S_i4u1u1u1u1_ p1, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color32 Lerp(UnityEngine.Color32, UnityEngine.Color32, Single)bool w_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_S_i4u1u1u1u1_S_i4u1u1u1u1_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
        
     // LuaValToCSVal struct
    S_i4u1u1u1u1_* pp2 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(env, _sv2);
    S_i4u1u1u1u1_ p2 = pp2 ? *pp2 : S_i4u1u1u1u1_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(struct S_i4u1u1u1u1_ p1, struct S_i4u1u1u1u1_ p2, float p3, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color32 op_Implicit(UnityEngine.Color)bool w_S_i4u1u1u1u1_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color32 get_Color()bool w_S_i4u1u1u1u1_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i4u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct S_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Reporting.BuildSummary get_summary()bool w_S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i8S_u4u4u4u4_i4i4i4i4i4su4u8u8i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan get_LeaseManagerPollTime()bool w_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i8_ (*FuncToCall)(const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider)bool w_S_i8_S_S_p_i4_Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_p_i4_Do");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_i8_ (*FuncToCall)(struct S_S_p_i4_ p1, void* p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.TimeSpanStyles)bool w_S_i8_S_S_p_i4_S_S_p_i4_oDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_p_i4_S_S_p_i4_oDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_i8_ (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles)bool w_S_i8_S_S_p_i4_ooDi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_p_i4_ooDi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_i8_ (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_Subtraction(System.DateTimeOffset, System.DateTimeOffset)bool w_S_i8_S_S_u8_i2_S_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_S_u8_i2_S_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
     // LuaValToCSVal struct
    S_S_u8_i2_* pp2 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv2);
    S_S_u8_i2_ p2 = pp2 ? *pp2 : S_S_u8_i2_ {};
        
    typedef struct S_i8_ (*FuncToCall)(struct S_S_u8_i2_ p1, struct S_S_u8_i2_ p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_UnaryNegation(System.TimeSpan)bool w_S_i8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(struct S_i8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_Subtraction(System.TimeSpan, System.TimeSpan)bool w_S_i8_S_i8_S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_i8_S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(struct S_i8_ p1, struct S_i8_ p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_Multiply(System.TimeSpan, Double)bool w_S_i8_S_i8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_i8_r8");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<double>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
 // LuaValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(env, _sv2);        
        
    typedef struct S_i8_ (*FuncToCall)(struct S_i8_ p1, double p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_Subtraction(System.DateTime, System.DateTime)bool w_S_i8_S_u8_S_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_u8_S_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
     // LuaValToCSVal struct
    S_u8_* pp2 = DataTransfer::GetPointer<S_u8_>(env, _sv2);
    S_u8_ p2 = pp2 ? *pp2 : S_u8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(struct S_u8_ p1, struct S_u8_ p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan FromTicks(Int64)bool w_S_i8_i8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_i8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
    typedef struct S_i8_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_Explicit(System.Xml.Linq.XAttribute)bool w_S_i8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan FromDays(Double)bool w_S_i8_r8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_r8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_i8_ (*FuncToCall)(double p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan op_Multiply(Double, System.TimeSpan)bool w_S_i8_r8S_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_r8S_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_i8_* pp2 = DataTransfer::GetPointer<S_i8_>(env, _sv2);
    S_i8_ p2 = pp2 ? *pp2 : S_i8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(double p1, struct S_i8_ p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan Parse(System.String)bool w_S_i8_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan Parse(System.String, System.IFormatProvider)bool w_S_i8_so(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_so");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan ParseExact(System.String, System.String[], System.IFormatProvider)bool w_S_i8_soo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_soo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.TimeSpanStyles)bool w_S_i8_sooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_sooi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan ParseExact(System.String, System.String, System.IFormatProvider)bool w_S_i8_sso(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_sso");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.TimeSpanStyles)bool w_S_i8_ssoi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_ssoi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
    typedef struct S_i8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan get_BaseUtcOffset()bool w_S_i8_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i8_ (*FuncToCall)(void*,const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan GetUtcOffset(System.DateTimeOffset)bool w_S_i8_tS_S_u8_i2_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_S_u8_i2_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_u8_i2_* pp1 = DataTransfer::GetPointer<S_S_u8_i2_>(env, _sv1);
    S_S_u8_i2_ p1 = pp1 ? *pp1 : S_S_u8_i2_ {};
        
    typedef struct S_i8_ (*FuncToCall)(void*,struct S_S_u8_i2_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan Add(System.TimeSpan)bool w_S_i8_tS_i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_i8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan GetUtcOffset(System.DateTime)bool w_S_i8_tS_u8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_u8_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan Renewal(System.Runtime.Remoting.Lifetime.ILease)bool w_S_i8_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_i8_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.TimeSpan Multiply(Double)bool w_S_i8_tr8(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tr8");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<double>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(env, _sv1);        
        
    typedef struct S_i8_ (*FuncToCall)(void*,double p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TimestampConversionRatio get_TimestampToNanosecondsConversionRatio()bool w_S_i8i8_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i8i8_ (*FuncToCall)(const void* method);
    struct S_i8i8_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.ProfilerRecorderSample GetSample(Int32)bool w_S_i8i8i8_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8i8_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_i8i8i8_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Diagnostics.CounterSample get_Sample()bool w_S_i8i8i8i8i8i8i8i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8i8i8i8i8i8i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_i8i8i8i8i8i8i8i4_ (*FuncToCall)(void*,const void* method);
    struct S_i8i8i8i8i8i8i8i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Mono.Cecil.Cil.InstructionOffset get_Start()bool w_S_oN_bi4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oN_bi4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oN_bi4__ (*FuncToCall)(void*,const void* method);
    struct S_oN_bi4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.CustomAttributeTypedArgument get_TypedValue()bool w_S_oO_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oO_ (*FuncToCall)(void*,const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ComponentModel.Design.Serialization.MemberRelationship get_Item(System.Object, System.ComponentModel.MemberDescriptor)bool w_S_oO_tOo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_tOo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_oO_ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ComponentModel.Design.Serialization.MemberRelationship get_Item(System.ComponentModel.Design.Serialization.MemberRelationship)bool w_S_oO_tS_oO_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oO_tS_oO_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_oO_* pp1 = DataTransfer::GetPointer<S_oO_>(env, _sv1);
    S_oO_ p1 = pp1 ? *pp1 : S_oO_ {};
        
    typedef struct S_oO_ (*FuncToCall)(void*,struct S_oO_ p1, const void* method);
    struct S_oO_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Bee.Core.SectionDisposable Section(System.String, System.Collections.Generic.Dictionary`2[System.String,System.String])bool w_S_oS_S_i4i4___tDsDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_S_i4i4___tDsDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_oS_S_i4i4___ (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    struct S_oS_S_i4i4___ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Bee.BinLog.NodeInfo get_EnqueuedNode()bool w_S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___ (*FuncToCall)(void*,const void* method);
    struct S_oS_i4S_i4_S_i4_S_i4_S_i4_S_i4_S_i4___ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1[T] WithCancellation(System.Threading.CancellationToken)bool w_S_oS_o_b_tS_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_o_b_tS_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_o_* pp1 = DataTransfer::GetPointer<S_o_>(env, _sv1);
    S_o_ p1 = pp1 ? *pp1 : S_o_ {};
        
    typedef struct S_oS_o_b_ (*FuncToCall)(void*,struct S_o_ p1, const void* method);
    struct S_oS_o_b_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1[T] ConfigureAwait(Boolean)bool w_S_oS_o_b_tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_o_b_tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_oS_o_b_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_oS_o_b_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationTokenRegistration Register(System.Action)bool w_S_oS_oi4__to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationTokenRegistration Register(System.Action`1[System.Object], System.Object)bool w_S_oS_oi4__toO(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__toO");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationTokenRegistration Register(System.Action`1[System.Object], System.Object, Boolean)bool w_S_oS_oi4__toOb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__toOb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationTokenRegistration Register(System.Action`1[System.Object], System.Object, Boolean, Boolean)bool w_S_oS_oi4__toObb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__toObb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, bool p3, bool p4, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationTokenRegistration Register(System.Action, Boolean)bool w_S_oS_oi4__tob(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oi4__tob");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
    typedef struct S_oS_oi4__ (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    struct S_oS_oi4__ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.AsyncVoidMethodBuilder Create()bool w_S_oS_oo_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_oo_o_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oS_oo_o_ (*FuncToCall)(const void* method);
    struct S_oS_oo_o_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Cursor get_value()bool w_S_oS_r4r4_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oS_r4r4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oS_r4r4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.TextGenerationSettings GetGenerationSettings(UnityEngine.Vector2)bool w_S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_tS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_tS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationToken get_None()bool w_S_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_o_ (*FuncToCall)(const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.LockHolder Hold(System.Threading.Lock)bool w_S_o_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_o_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Threading.CancellationToken get_CancellationToken()bool w_S_o_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_o_ (*FuncToCall)(void*,const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetAsyncEnumerator()bool w_S_ob_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ob_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ob_ (*FuncToCall)(void*,const void* method);
    struct S_ob_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.Rendering.RayTracingInstanceCullingResults CullInstances(UnityEngine.Experimental.Rendering.RayTracingInstanceCullingConfig ByRef)bool w_S_ob_tPS_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ob_tPS_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__* p1 = DataTransfer::GetPointer<S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4S_r4r4r4_r4ooS_oo_S_i4i4oo_S_i4i4oo_S_i4i4i4_S_obbb_S_i4S_r4r4r4_r4r4i4__ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_ob_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_ob_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.CompilerServices.ConfiguredAsyncDisposable ConfigureAwait(System.IAsyncDisposable, Boolean)bool w_S_ob_tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ob_tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_ob_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_ob_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleFont op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_oi4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_oi4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleFont op_Implicit(UnityEngine.Font)bool w_S_oi4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oi4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_oi4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oi4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_oi4i4S_oo_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4S_oo_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oi4i4S_oo_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4S_oo_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ArraySegment`1[T] get_Empty()bool w_S_oi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oi4i4_ (*FuncToCall)(const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ArraySegment`1[System.Byte] CreateServerBuffer(Int32)bool w_S_oi4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_oi4i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ArraySegment`1[System.Byte] CreateClientBuffer(Int32, Int32)bool w_S_oi4i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_oi4i4_ (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ArraySegment`1[T] op_Implicit(T[])bool w_S_oi4i4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oi4i4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ArraySegment`1[T] Slice(Int32)bool w_S_oi4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_oi4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.ArraySegment`1[T] Slice(Int32, Int32)bool w_S_oi4i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_oi4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_oi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_oi4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_oi4i4o_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4o_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oi4i4o_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Net.Sockets.SocketInformation DuplicateAndClose(Int32)bool w_S_oi4o_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4o_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_oi4o_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_oi4o_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_oi4oob_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4oob_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oi4oob_ (*FuncToCall)(void*,const void* method);
    struct S_oi4oob_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.ECCurve CreateFromOid(System.Security.Cryptography.Oid)bool w_S_ooS_oo_oooi4N_bS_s__ooo_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooS_oo_oooi4N_bS_s__ooo_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_ooS_oo_oooi4N_bS_s__ooo_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_ooS_oo_oooi4N_bS_s__ooo_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.ECCurve CreateFromFriendlyName(System.String)bool w_S_ooS_oo_oooi4N_bS_s__ooo_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooS_oo_oooi4N_bS_s__ooo_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_ooS_oo_oooi4N_bS_s__ooo_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_ooS_oo_oooi4N_bS_s__ooo_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Pool.PooledObject`1[TCollection] Get(TCollection ByRef)bool w_S_oo_Po(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_Po");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef struct S_oo_ (*FuncToCall)(void* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Player.ScriptCompilationResult CompilePlayerScripts(UnityEditor.Build.Player.ScriptCompilationSettings, System.String)bool w_S_oo_S_i4i4i4i4oo_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_S_i4i4i4i4oo_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4oo_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4oo_>(env, _sv1);
    S_i4i4i4i4oo_ p1 = pp1 ? *pp1 : S_i4i4i4i4oo_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
    typedef struct S_oo_ (*FuncToCall)(struct S_i4i4i4i4oo_ p1, Il2CppString* p2, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.AssetIndexChangeSet GetDiff(Int64, System.Collections.Generic.IEnumerable`1[System.String], System.Func`2[System.String,System.Boolean])bool w_S_oo_i8oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_i8oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int64_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_oo_ (*FuncToCall)(int64_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.FontDefinition FromFont(UnityEngine.Font)bool w_S_oo_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oo_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.FontDefinition get_value()bool w_S_oo_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oo_ (*FuncToCall)(void*,const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Pool.PooledObject`1[T] Get(T ByRef)bool w_S_oo_tPo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_tPo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(env, pesapi_unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef struct S_oo_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.UQueryState`1[T] RebuildOn(UnityEngine.UIElements.VisualElement)bool w_S_oo_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oo_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oo_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_oo_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.SearchMonitorView GetView(Boolean)bool w_S_oobb_Db(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oobb_Db");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_oobb_ (*FuncToCall)(void* p1, const void* method);
    struct S_oobb_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_ooi4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooi4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ooi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_ooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Enumerator GetEnumerator()bool w_S_ooi4oi4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooi4oi4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ooi4oi4_ (*FuncToCall)(void*,const void* method);
    struct S_ooi4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.AI.NavMeshTriangulation CalculateTriangulation()bool w_S_ooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ooo_ (*FuncToCall)(const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet)bool w_S_ooo_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv1);
    S_oi4i4i4_ p1 = pp1 ? *pp1 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv2);
    S_u4u4u4u4u4bbbbbbb_ p2 = pp2 ? *pp2 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_ooo_ (*FuncToCall)(struct S_oi4i4i4_ p1, struct S_u4u4u4u4u4bbbbbbb_ p2, Il2CppObject* p3, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache)bool w_S_ooo_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv1);
    S_oi4i4i4_ p1 = pp1 ? *pp1 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv2);
    S_u4u4u4u4u4bbbbbbb_ p2 = pp2 ? *pp2 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_ooo_ (*FuncToCall)(struct S_oi4i4i4_ p1, struct S_u4u4u4u4u4bbbbbbb_ p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildUsageCache, UnityEditor.Build.Content.DependencyType)bool w_S_ooo_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_ooi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_ooi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_oi4i4i4_* pp1 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv1);
    S_oi4i4i4_ p1 = pp1 ? *pp1 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp2 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv2);
    S_u4u4u4u4u4bbbbbbb_ p2 = pp2 ? *pp2 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef struct S_ooo_ (*FuncToCall)(struct S_oi4i4i4_ p1, struct S_u4u4u4u4u4bbbbbbb_ p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Mono.Security.Cryptography.DHParameters ExportParameters(Boolean)bool w_S_ooo_tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooo_tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_ooo_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_ooo_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Background FromTexture2D(UnityEngine.Texture2D)bool w_S_oooo_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oooo_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Background get_icon()bool w_S_oooo_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oooo_ (*FuncToCall)(void*,const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Reflection.InterfaceMapping GetInterfaceMap(System.Type)bool w_S_oooo_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_oooo_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.UQueryBuilder`1[T] Active()bool w_S_ooooi4i4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.UQueryBuilder`1[UnityEngine.UIElements.VisualElement] Query(UnityEngine.UIElements.VisualElement, System.String, System.String)bool w_S_ooooi4i4i4_tDsDs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_tDsDs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.UQueryBuilder`1[UnityEngine.UIElements.VisualElement] Query(UnityEngine.UIElements.VisualElement, System.String, System.String[])bool w_S_ooooi4i4i4_tDsVs(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_tDsVs");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,void* p1, void* p2, const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.UQueryBuilder`1[T] Where(System.Func`2[T,System.Boolean])bool w_S_ooooi4i4i4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.UQueryBuilder`1[T] Class(System.String)bool w_S_ooooi4i4i4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooooi4i4i4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_ooooi4i4i4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_ooooi4i4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Trails GetTrails()bool w_S_oooooi4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooi4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oooooi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_oooooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteGameManagersSerializedFile(System.String, UnityEditor.Build.Content.WriteManagerParameters)bool w_S_oooooo_sS_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_sS_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_* pp2 = DataTransfer::GetPointer<S_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_>(env, _sv2);
    S_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_ p2 = pp2 ? *pp2 : S_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_ {};
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, struct S_S_oi4i4i4_S_u4u4u4u4u4bbbbbbb_o_ p2, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSerializedFile(System.String, UnityEditor.Build.Content.WriteParameters)bool w_S_oooooo_sS_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_sS_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_* pp2 = DataTransfer::GetPointer<S_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_>(env, _sv2);
    S_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p2 = pp2 ? *pp2 : S_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ {};
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, struct S_oS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p2, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, UnityEditor.Build.Content.WriteSceneParameters)bool w_S_oooooo_sS_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_sS_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_* pp2 = DataTransfer::GetPointer<S_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_>(env, _sv2);
    S_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p2 = pp2 ? *pp2 : S_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ {};
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, struct S_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo_ p2, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSerializedFile(System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap)bool w_S_oooooo_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_oi4i4i4_* pp3 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv3);
    S_oi4i4i4_ p3 = pp3 ? *pp3 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp4 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv4);
    S_u4u4u4u4u4bbbbbbb_ p4 = pp4 ? *pp4 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, struct S_oi4i4i4_ p3, struct S_u4u4u4u4u4bbbbbbb_ p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSerializedFile(System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap, UnityEditor.Build.Content.AssetBundleInfo)bool w_S_oooooo_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_soS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_oi4i4i4_* pp3 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv3);
    S_oi4i4i4_ p3 = pp3 ? *pp3 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp4 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv4);
    S_u4u4u4u4u4bbbbbbb_ p4 = pp4 ? *pp4 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, struct S_oi4i4i4_ p3, struct S_u4u4u4u4u4bbbbbbb_ p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, System.String, System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap)bool w_S_oooooo_sssoS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_sssoS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_oi4i4i4_* pp5 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv5);
    S_oi4i4i4_ p5 = pp5 ? *pp5 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp6 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv6);
    S_u4u4u4u4u4bbbbbbb_ p6 = pp6 ? *pp6 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, struct S_oi4i4i4_ p5, struct S_u4u4u4u4u4bbbbbbb_ p6, Il2CppObject* p7, Il2CppObject* p8, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, System.String, System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap, UnityEditor.Build.Content.PreloadInfo)bool w_S_oooooo_sssoS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_ooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_sssoS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_ooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];
    auto TIp9 = wrapData->TypeInfos[10];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_oi4i4i4_* pp5 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv5);
    S_oi4i4i4_ p5 = pp5 ? *pp5 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp6 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv6);
    S_u4u4u4u4u4bbbbbbb_ p6 = pp6 ? *pp6 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, struct S_oi4i4i4_ p5, struct S_u4u4u4u4u4bbbbbbb_ p6, Il2CppObject* p7, Il2CppObject* p8, Il2CppObject* p9, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Build.Content.WriteResult WriteSceneSerializedFile(System.String, System.String, System.String, UnityEditor.Build.Content.WriteCommand, UnityEditor.Build.Content.BuildSettings, UnityEditor.Build.Content.BuildUsageTagGlobal, UnityEditor.Build.Content.BuildUsageTagSet, UnityEditor.Build.Content.BuildReferenceMap, UnityEditor.Build.Content.PreloadInfo, UnityEditor.Build.Content.SceneBundleInfo)bool w_S_oooooo_sssoS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooo_sssoS_oi4i4i4_S_u4u4u4u4u4bbbbbbb_oooo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    auto TIp7 = wrapData->TypeInfos[8];
    auto TIp8 = wrapData->TypeInfos[9];
    auto TIp9 = wrapData->TypeInfos[10];
    auto TIp10 = wrapData->TypeInfos[11];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 10) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv10, TIp10, false)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(env, _sv3);
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal struct
    S_oi4i4i4_* pp5 = DataTransfer::GetPointer<S_oi4i4i4_>(env, _sv5);
    S_oi4i4i4_ p5 = pp5 ? *pp5 : S_oi4i4i4_ {};
        
     // LuaValToCSVal struct
    S_u4u4u4u4u4bbbbbbb_* pp6 = DataTransfer::GetPointer<S_u4u4u4u4u4bbbbbbb_>(env, _sv6);
    S_u4u4u4u4u4bbbbbbb_ p6 = pp6 ? *pp6 : S_u4u4u4u4u4bbbbbbb_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
     // LuaValToCSVal o/O
    Il2CppObject* p9 = LuaValToCSRef(TIp9, env _sv9);
        
     // LuaValToCSVal o/O
    Il2CppObject* p10 = LuaValToCSRef(TIp10, env _sv10);
        
    typedef struct S_oooooo_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppObject* p4, struct S_oi4i4i4_ p5, struct S_u4u4u4u4u4bbbbbbb_ p6, Il2CppObject* p7, Il2CppObject* p8, Il2CppObject* p9, Il2CppObject* p10, const void* method);
    struct S_oooooo_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.DSAParameters ExportParameters(Boolean)bool w_S_oooooooi4_tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooi4_tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_oooooooi4_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_oooooooi4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.RSAParameters get_RsaPublicKey()bool w_S_oooooooo_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooo_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oooooooo_ (*FuncToCall)(void*,const void* method);
    struct S_oooooooo_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Security.Cryptography.RSAParameters ExportParameters(Boolean)bool w_S_oooooooo_tb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooooo_tb");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
    typedef struct S_oooooooo_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_oooooooo_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.LowLevel.PlayerLoopSystem GetDefaultPlayerLoop()bool w_S_ooopp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ooopp_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ooopp_ (*FuncToCall)(const void* method);
    struct S_ooopp_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.EventSystems.RaycastResult get_pointerCurrentRaycast()bool w_S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oor4r4i4i4i4i4i4S_r4r4r4_S_r4r4r4_S_r4r4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.HumanDescription get_humanDescription()bool w_S_oor4r4r4r4r4r4r4r4sbbb_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oor4r4r4r4r4r4r4r4sbbb_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_oor4r4r4r4r4r4r4r4sbbb_ (*FuncToCall)(void*,const void* method);
    struct S_oor4r4r4r4r4r4r4r4sbbb_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Animations.ConstraintSource GetSource(Int32)bool w_S_or4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_or4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_or4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_or4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.Search.QueryFilterOperator GetOperator(System.String)bool w_S_osi4o_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_osi4o_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_osi4o_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_osi4o_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.AssetImporters.TextureGenerationOutput GenerateTexture(UnityEditor.AssetImporters.TextureGenerationSettings, Unity.Collections.NativeArray`1[UnityEngine.Color32])bool w_S_osooo_S_sbbooooso_S_Pvi4i4i4S_pi4i4_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_osooo_S_sbbooooso_S_Pvi4i4i4S_pi4i4_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_sbbooooso_* pp1 = DataTransfer::GetPointer<S_sbbooooso_>(env, _sv1);
    S_sbbooooso_ p1 = pp1 ? *pp1 : S_sbbooooso_ {};
        
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp2 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(env, _sv2);
    S_Pvi4i4i4S_pi4i4_i4_ p2 = pp2 ? *pp2 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef struct S_osooo_ (*FuncToCall)(struct S_sbbooooso_ p1, struct S_Pvi4i4i4S_pi4i4_i4_ p2, const void* method);
    struct S_osooo_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.BuildPlayerOptions get_BuildPlayerOptions()bool w_S_ossi4i4i4i4o_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ossi4i4i4i4o_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_ossi4i4i4i4o_ (*FuncToCall)(void*,const void* method);
    struct S_ossi4i4i4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.VFX.VFXBatchedEffectInfo GetBatchedEffectInfo(UnityEngine.VFX.VisualEffectAsset)bool w_S_ou4u4u4u4u4u4u8u8_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_ou4u4u4u4u4u4u8u8_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_ou4u4u4u4u4u4u8u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_ou4u4u4u4u4u4u8u8_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.CullingResults get_cullingResults()bool w_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ (*FuncToCall)(void*,const void* method);
    struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.CullingResults Cull(UnityEngine.Rendering.ScriptableCullingParameters ByRef)bool w_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__tPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__tPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p1 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Experimental.AI.NavMeshWorld GetDefaultWorld()bool w_S_p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_p_ (*FuncToCall)(const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.RuntimeTypeHandle GetTypeHandle(System.Object)bool w_S_p_O(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_O");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_p_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.InteropServices.GCHandle Alloc(System.Object, System.Runtime.InteropServices.GCHandleType)bool w_S_p_Oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_Oi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_p_ (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.RuntimeTypeHandle TargetTypeToken(TypedReference)bool w_S_p_S_S_p_pp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_S_S_p_pp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_S_p_pp_* pp1 = DataTransfer::GetPointer<S_S_p_pp_>(env, _sv1);
    S_S_p_pp_ p1 = pp1 ? *pp1 : S_S_p_pp_ {};
        
    typedef struct S_p_ (*FuncToCall)(struct S_S_p_pp_ p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Runtime.InteropServices.GCHandle op_Explicit(IntPtr)bool w_S_p_p(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_p");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(env, _sv1);        
        
    typedef struct S_p_ (*FuncToCall)(void* p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Profiling.Stats.Counter GetCounter(System.String)bool w_S_p_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_p_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.RuntimeTypeHandle get_TypeHandle()bool w_S_p_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_p_ (*FuncToCall)(void*,const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.RuntimeFieldHandle ResolveFieldHandle(Int32)bool w_S_p_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_p_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.RuntimeTypeHandle ResolveTypeHandle(Int32, System.RuntimeTypeHandle[], System.RuntimeTypeHandle[])bool w_S_p_ti4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_ti4oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_p_ (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.IO.LowLevel.Unsafe.ReadHandle ReadDeferred(Unity.IO.LowLevel.Unsafe.FileHandle ByRef, Unity.IO.LowLevel.Unsafe.ReadCommandArray*, Unity.Jobs.JobHandle)bool w_S_pi4_PS_pi4_PS_PS_Pvi8i8_i4_S_u8i4i4p_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_PS_pi4_PS_PS_Pvi8i8_i4_S_u8i4i4p_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!!true) return false;                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4_* p1 = DataTransfer::GetPointer<S_pi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal Pstruct
    S_PS_Pvi8i8_i4_* p2 = DataTransfer::GetPointer<S_PS_Pvi8i8_i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_PS_Pvi8i8_i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
     // LuaValToCSVal struct
    S_u8i4i4p_* pp3 = DataTransfer::GetPointer<S_u8i4i4p_>(env, _sv3);
    S_u8i4i4p_ p3 = pp3 ? *pp3 : S_u8i4i4p_ {};
        
    typedef struct S_pi4_ (*FuncToCall)(void* p1, void* p2, struct S_u8i4i4p_ p3, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.IO.LowLevel.Unsafe.ReadHandle Read(Unity.IO.LowLevel.Unsafe.FileHandle ByRef, Unity.IO.LowLevel.Unsafe.ReadCommandArray)bool w_S_pi4_PS_pi4_S_PS_Pvi8i8_i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_PS_pi4_S_PS_Pvi8i8_i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!!true) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal Pstruct
    S_pi4_* p1 = DataTransfer::GetPointer<S_pi4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_pi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
     // LuaValToCSVal struct
    S_PS_Pvi8i8_i4_* pp2 = DataTransfer::GetPointer<S_PS_Pvi8i8_i4_>(env, _sv2);
    S_PS_Pvi8i8_i4_ p2 = pp2 ? *pp2 : S_PS_Pvi8i8_i4_ {};
        
    typedef struct S_pi4_ (*FuncToCall)(void* p1, struct S_PS_Pvi8i8_i4_ p2, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// TypeCollection GetTypesWithAttribute(System.Type)bool w_S_pi4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest], Boolean)bool w_S_pi4_oDi4DoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oDi4DoDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, void* p2, void* p3, void* p4, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.ComputeBuffer, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])bool w_S_pi4_oDo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oDo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.ComputeBuffer, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])bool w_S_pi4_oi4i4Do(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4Do");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, void* p4, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, UnityEngine.TextureFormat, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest], Boolean)bool w_S_pi4_oi4i4DoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4DoDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, void* p4, void* p5, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest], Boolean)bool w_S_pi4_oi4i4i4i4i4i4i4DoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4i4i4i4i4i4DoDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 10) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    void* p9 = nullptr;        
        
 // LuaValToCSVal P any
    void* p10 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, void* p9, void* p10, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.TextureFormat, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest], Boolean)bool w_S_pi4_oi4i4i4i4i4i4i4i4DoDb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_oi4i4i4i4i4i4i4i4DoDb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp10 = wrapData->TypeInfos[3];
    auto TIp11 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    pesapi_value_sv11 = pesapi_get_arg(info, 11);
    if (checkLuaArgument) {
        if (lua_args_len != 11) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv6)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv7)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv8)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv9)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(env, _sv6);        
        
 // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(env, _sv8);        
        
 // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(env, _sv9);        
        
 // LuaValToCSVal P any
    void* p10 = nullptr;        
        
 // LuaValToCSVal P any
    void* p11 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, void* p10, void* p11, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.IO.LowLevel.Unsafe.FileHandle OpenFileAsync(System.String)bool w_S_pi4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_pi4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.IO.LowLevel.Unsafe.ReadHandle Read(System.String, Unity.IO.LowLevel.Unsafe.ReadCommand*, UInt32, System.String, UInt64, Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem)bool w_S_pi4_sPS_Pvi8i8_u4DsDu8Di4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_sPS_Pvi8i8_u4DsDu8Di4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!converter::Converter<uint32_t>::accept(env, _sv3)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_Pvi8i8_* p2 = DataTransfer::GetPointer<S_Pvi8i8_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_Pvi8i8_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
 // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppString* p1, void* p2, uint32_t p3, void* p4, void* p5, void* p6, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.IO.LowLevel.Unsafe.ReadHandle GetFileInfo(System.String, Unity.IO.LowLevel.Unsafe.FileInfoResult*)bool w_S_pi4_sPS_i8i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4_sPS_i8i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal Pstruct
    S_i8i4_* p2 = DataTransfer::GetPointer<S_i8i4_>(env, pesapi_unboxing(env, _sv2)); // valuetype ref
    S_i8i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
    }
        
    typedef struct S_pi4_ (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    struct S_pi4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle Create()bool w_S_pi4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_pi4i4_ (*FuncToCall)(const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence(UnityEngine.Rendering.SynchronisationStage)bool w_S_pi4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_pi4i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GraphicsFence CreateGraphicsFence(UnityEngine.Rendering.GraphicsFenceType, UnityEngine.Rendering.SynchronisationStageFlags)bool w_S_pi4i4_i4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_pi4i4_ (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence()bool w_S_pi4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_pi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence(UnityEngine.Rendering.SynchronisationStage)bool w_S_pi4i4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_pi4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.GraphicsFence CreateGraphicsFence(UnityEngine.Rendering.GraphicsFenceType, UnityEngine.Rendering.SynchronisationStageFlags)bool w_S_pi4i4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_pi4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.PlayableGraph Create()bool w_S_pu4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_pu4_ (*FuncToCall)(const void* method);
    struct S_pu4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.PlayableGraph Create(System.String)bool w_S_pu4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_pu4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_pu4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Playables.PlayableGraph get_playableGraph()bool w_S_pu4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_pu4_ (*FuncToCall)(void*,const void* method);
    struct S_pu4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererList CreateRendererList(UnityEngine.Rendering.RendererListParams ByRef)bool w_S_pu4u4u4_tPS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_tPS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___* p1 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__S_S_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_i4i4_S_i4_i4i4i4i4i4S_i4_i4i4i4i4i4i4i4_S_S_i4i4_i4u4i4S_i2i2_S_i2i2__S_i4_bN_bS_Pvi4i4i4S_pi4i4_i4__N_bS_Pvi4i4i4S_pi4i4_i4___ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererList CreateShadowRendererList(UnityEngine.Rendering.ShadowDrawingSettings ByRef)bool w_S_pu4u4u4_tPS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_tPS_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
     // LuaValToCSVal Pstruct
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_* p1 = DataTransfer::GetPointer<S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_>(env, pesapi_unboxing(env, _sv1)); // valuetype ref
    S_S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__i4i4S_i4S_u1_S_r4r4r4r4_r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4__i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
    }
        
    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,void* p1, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererList CreateRendererList(UnityEngine.Rendering.RendererUtils.RendererListDesc)bool w_S_pu4u4u4_tS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_tS_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_* pp1 = DataTransfer::GetPointer<S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_>(env, _sv1);
    S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_ p1 = pp1 ? *pp1 : S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_ {};
        
    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,struct S_i4i4S_i4i4_N_bS_S_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_S_u1u1u1u1u1u1u1u1_u1u1i2_S_i4i4r4u1u1u1u1_S_u1i1_S_u1u1u1u1u1u1u1u1u1u1u1u1_i4i4__oobboS_i4_bi4u4i4i4S_pPS_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_i4S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4i4i4_PS_S_S_r4r4r4_S_r4r4r4__S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4i4i4i4i4_i4i4i4_S_pi4i4__oS_i4_o_ p1, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererList CreateSkyboxRendererList(UnityEngine.Camera)bool w_S_pu4u4u4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererList CreateSkyboxRendererList(UnityEngine.Camera, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)bool w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rendering.RendererList CreateSkyboxRendererList(UnityEngine.Camera, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)bool w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_pu4u4u4_toS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv5);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_pu4u4u4_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p5, const void* method);
    struct S_pu4u4u4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Length Auto()bool w_S_r4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4i4_ (*FuncToCall)(const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.StyleFloat op_Implicit(UnityEngine.UIElements.StyleKeyword)bool w_S_r4i4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Angle Degrees(Single)bool w_S_r4i4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4i4_ (*FuncToCall)(float p1, const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.UIElements.Length get_x()bool w_S_r4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditorInternal.AnimationKeyTime Frame(Int32, Single)bool w_S_r4i4r4_i4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4r4_i4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4i4r4_ (*FuncToCall)(int32_t p1, float p2, const void* method);
    struct S_r4i4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditorInternal.AnimationKeyTime Time(Single, Single)bool w_S_r4i4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4i4r4_ (*FuncToCall)(float p1, float p2, const void* method);
    struct S_r4i4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditorInternal.AnimationKeyTime get_time()bool w_S_r4i4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4i4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4i4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4i4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEditor.ObjectReferenceKeyframe ToObjectReferenceKeyframe()bool w_S_r4o_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4o_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4o_ (*FuncToCall)(void*,const void* method);
    struct S_r4o_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 get_zero()bool w_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector2Int)bool w_S_r4r4_S_i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Perpendicular(UnityEngine.Vector2)bool w_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Scale(UnityEngine.Vector2, UnityEngine.Vector2)bool w_S_r4r4_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single)bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p3 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, void* p3, float p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single)bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p3 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, void* p3, float p4, float p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single, Single)bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4_* p3 = DataTransfer::GetPointer<S_r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, void* p3, float p4, float p5, float p6, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector2 Clamp(System.Numerics.Vector2, System.Numerics.Vector2, System.Numerics.Vector2)bool w_S_r4r4_S_r4r4_S_r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Lerp(UnityEngine.Vector2, UnityEngine.Vector2, Single)bool w_S_r4r4_S_r4r4_S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector2 Transform(System.Numerics.Vector2, System.Numerics.Quaternion)bool w_S_r4r4_S_r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector2 Transform(System.Numerics.Vector2, System.Numerics.Matrix3x2)bool w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector2 Transform(System.Numerics.Vector2, System.Numerics.Matrix4x4)bool w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUILayoutOption[])bool w_S_r4r4_S_r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, void* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, Boolean, Boolean, UnityEngine.GUILayoutOption[])bool w_S_r4r4_S_r4r4_bbVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_bbVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, bool p2, bool p3, void* p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, Boolean, Boolean, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4_S_r4r4_bbooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_bbooVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    void* p6 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, bool p2, bool p3, Il2CppObject* p4, Il2CppObject* p5, void* p6, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, Boolean, Boolean, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4_S_r4r4_bboooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_bboooVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv2)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    void* p7 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, bool p2, bool p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, void* p7, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUIStyle)bool w_S_r4r4_S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4_S_r4r4_oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, void* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 PixelAdjustPoint(UnityEngine.Vector2, UnityEngine.Transform, UnityEngine.Canvas)bool w_S_r4r4_S_r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Vector2, UnityEngine.GUIStyle, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4_S_r4r4_ooVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_ooVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 ClampMagnitude(UnityEngine.Vector2, Single)bool w_S_r4r4_S_r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector3)bool w_S_r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector4)bool w_S_r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 NormalizedToPoint(UnityEngine.Rect, UnityEngine.Vector2)bool w_S_r4r4_S_r4r4r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect)bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect, Boolean, Boolean)bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4r4r4_ p3, bool p4, bool p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect, Boolean, Boolean, UnityEngine.GUIStyle, UnityEngine.GUIStyle)bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bboo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_bboo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4r4r4_ p3, bool p4, bool p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 BeginScrollView(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Rect, UnityEngine.GUIStyle, UnityEngine.GUIStyle)bool w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4r4r4_ p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Vector2Field(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector2)bool w_S_r4r4_S_r4r4r4r4_oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4_ p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Vector2Field(UnityEngine.Rect, System.String, UnityEngine.Vector2)bool w_S_r4r4_S_r4r4r4r4_sS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_sS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_r4r4_ p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetTextAnchorPivot(UnityEngine.TextAnchor)bool w_S_r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetMinSize(UnityEngine.Sprite)bool w_S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 ScreenToPanel(UnityEngine.UIElements.IPanel, UnityEngine.Vector2)bool w_S_r4r4_oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Vector2Field(UnityEngine.GUIContent, UnityEngine.Vector2, UnityEngine.GUILayoutOption[])bool w_S_r4r4_oS_r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, void* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 WorldToScreenPoint(UnityEngine.Camera, UnityEngine.Vector3)bool w_S_r4r4_oS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 CameraTransformWorldToPanel(UnityEngine.UIElements.IPanel, UnityEngine.Vector3, UnityEngine.Camera)bool w_S_r4r4_oS_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, Il2CppObject* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 op_Multiply(Single, UnityEngine.Vector2)bool w_S_r4r4_r4S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r4S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(float p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 Vector2Field(System.String, UnityEngine.Vector2, UnityEngine.GUILayoutOption[])bool w_S_r4r4_sS_r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_sS_r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4_ p2, void* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 get_curvature()bool w_S_r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 CalcScreenSize(UnityEngine.Vector2)bool w_S_r4r4_tS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 WorldToScreenPoint(UnityEngine.Vector3)bool w_S_r4r4_tS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetCursorPixelPosition(UnityEngine.Rect, UnityEngine.GUIContent, Int32)bool w_S_r4r4_tS_r4r4r4r4_oi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4r4r4_oi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetPropertyRangeLimits(Int32)bool w_S_r4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetShapeVertex(Int32, Int32)bool w_S_r4r4_ti4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 CalcSize(UnityEngine.GUIContent)bool w_S_r4r4_to(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_to");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 ChangeCoordinatesTo(UnityEngine.UIElements.VisualElement, UnityEngine.UIElements.VisualElement, UnityEngine.Vector2)bool w_S_r4r4_toS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_toS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 ComputeWindFactor(TreeEditor.TreeNode, Single)bool w_S_r4r4_tor4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tor4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, float p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetPoint(Single)bool w_S_r4r4_tr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,float p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetTextureOffset(System.String)bool w_S_r4r4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 GetTextureScale(System.String, Boolean ByRef, Boolean ByRef)bool w_S_r4r4_tsPbPb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tsPbPb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector2 MeasureTextSize(System.String, Single, MeasureMode, Single, MeasureMode)bool w_S_r4r4_tsr4i4r4i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tsr4i4r4i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p1, float p2, int32_t p3, float p4, int32_t p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.JointMotor get_motor()bool w_S_r4r4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 get_shadowCascade4Split()bool w_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector3Int)bool w_S_r4r4r4_S_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_i4i4i4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 PositionHandle(PositionHandleIds, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_S_r4r4r4_S_i4i4i4i4i4i4i4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_i4i4i4i4i4i4i4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_i4i4i4i4i4i4i4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector2)bool w_S_r4r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 RelativeMouseAt(UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Snap(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.SnapAxis)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_Du1(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, float p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
    }
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, void* p3, float p4, float p5, float p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ClosestPtSegmentRay(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Ray, Single ByRef, Single ByRef, UnityEngine.Vector3 ByRef)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__Pr4Pr4PS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_S_r4r4r4_S_r4r4r4__Pr4Pr4PS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!!true) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp3 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(env, _sv3);
    S_S_r4r4r4_S_r4r4r4__ p3 = pp3 ? *pp3 : S_S_r4r4r4_S_r4r4r4__ {};
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
 // LuaValToCSVal P any
    void* p5 = nullptr;        
        
     // LuaValToCSVal Pstruct
    S_r4r4r4_* p6 = DataTransfer::GetPointer<S_r4r4r4_>(env, pesapi_unboxing(env, _sv6)); // valuetype ref
    S_r4r4r4_ up6;
    if (!p6) {
        memset(&up6, 0, sizeof(p6));
    }
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_S_r4r4r4_S_r4r4r4__ p3, void* p4, void* p5, void* p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ProjectPointLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, struct S_r4r4_ p7, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2, Boolean)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
     // LuaValToCSVal struct
    S_r4r4_* pp7 = DataTransfer::GetPointer<S_r4r4_>(env, _sv7);
    S_r4r4_ p7 = pp7 ? *pp7 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(env, _sv8);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, struct S_r4r4_ p7, bool p8, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, float p7, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single, Boolean)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!converter::Converter<bool>::accept(env, _sv8)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
 // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(env, _sv8);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, float p7, bool p8, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ClosestPointToArc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ScaleHandle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 DoScaleHandle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slerp(UnityEngine.Vector3, UnityEngine.Vector3, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider(UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, Il2CppObject* p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 DoPositionHandle(UnityEngine.Vector3, UnityEngine.Quaternion)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 FreeMoveHandle(UnityEngine.Vector3, UnityEngine.Quaternion, Single, UnityEngine.Vector3, CapFunction)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector3 Transform(System.Numerics.Vector3, System.Numerics.Matrix4x4)bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ClosestPoint(UnityEngine.Vector3, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion)bool w_S_r4r4r4_S_r4r4r4_oS_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_oS_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single)bool w_S_r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 FreeMoveHandle(UnityEngine.Vector3, Single, UnityEngine.Vector3, CapFunction)bool w_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, float p2, struct S_r4r4r4_ p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ToEulerAngles(UnityEngine.Quaternion)bool w_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 op_Multiply(UnityEngine.Quaternion, UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Vector3Field(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4r4_oS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_oS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Vector3Field(UnityEngine.Rect, System.String, UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4r4_sS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_sS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 PerspectiveClipToWorld(UnityEngine.Matrix4x4, UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 ClosestPointToPolyLine(UnityEngine.Vector3[])bool w_S_r4r4r4_VS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_VS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetLocalPosition(UnityEngine.XR.XRNode)bool w_S_r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Swizzle(CellSwizzle, UnityEngine.Vector3)bool w_S_r4r4r4_i4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];
    auto TIp9 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv6);
    S_r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
     // LuaValToCSVal struct
    S_r4r4_* pp9 = DataTransfer::GetPointer<S_r4r4_>(env, _sv9);
    S_r4r4_ p9 = pp9 ? *pp9 : S_r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, struct S_r4r4r4_ p6, float p7, Il2CppObject* p8, struct S_r4r4_ p9, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2, Boolean)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];
    auto TIp9 = wrapData->TypeInfos[8];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    pesapi_value_sv10 = pesapi_get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 10) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, true)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv9, TIp9, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv10)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv6);
    S_r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p8 = LuaValToCSRef(TIp8, env _sv8);
        
     // LuaValToCSVal struct
    S_r4r4_* pp9 = DataTransfer::GetPointer<S_r4r4_>(env, _sv9);
    S_r4r4_ p9 = pp9 ? *pp9 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(env, _sv10);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, struct S_r4r4r4_ p6, float p7, Il2CppObject* p8, struct S_r4r4_ p9, bool p10, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 8) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal struct
    S_r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4_>(env, _sv8);
    S_r4r4_ p8 = pp8 ? *pp8 : S_r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, float p6, Il2CppObject* p7, struct S_r4r4_ p8, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider2D(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, UnityEngine.Vector2, Boolean)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4oS_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    pesapi_value_sv8 = pesapi_get_arg(info, 8);
    pesapi_value_sv9 = pesapi_get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 9) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv8, TIp8, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv9)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
     // LuaValToCSVal struct
    S_r4r4_* pp8 = DataTransfer::GetPointer<S_r4r4_>(env, _sv8);
    S_r4r4_ p8 = pp8 ? *pp8 : S_r4r4_ {};
        
 // LuaValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(env, _sv9);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, struct S_r4r4r4_ p5, float p6, Il2CppObject* p7, struct S_r4r4_ p8, bool p9, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider(Int32, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;                if (!converter::Converter<float>::accept(env, _sv7)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
 // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(env, _sv7);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, float p7, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Slider(Int32, UnityEngine.Vector3, UnityEngine.Vector3, Single, CapFunction, Single)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_r4or4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4_r4or4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, Il2CppObject* p5, float p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 FreeMoveHandle(Int32, UnityEngine.Vector3, UnityEngine.Quaternion, Single, UnityEngine.Vector3, CapFunction)bool w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_S_r4r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv6, TIp6, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValToCSRef(TIp6, env _sv6);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, struct S_r4r4r4_ p5, Il2CppObject* p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 FreeMoveHandle(Int32, UnityEngine.Vector3, Single, UnityEngine.Vector3, CapFunction)bool w_S_r4r4r4_i4S_r4r4r4_r4S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_i4S_r4r4r4_r4S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(int32_t p1, struct S_r4r4r4_ p2, float p3, struct S_r4r4r4_ p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetInspectorRotation(UnityEngine.Transform)bool w_S_r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 WorldToGUIPointWithDepth(UnityEngine.Camera, UnityEngine.Vector3)bool w_S_r4r4r4_oS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Vector3Field(UnityEngine.GUIContent, UnityEngine.Vector3, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4_oS_r4r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValToCSRef(TIp1, env _sv1);
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, void* p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetVector3(Single)bool w_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(float p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3)bool w_S_r4r4r4_r4S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetTrackerPosition(System.String)bool w_S_r4r4r4_s(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetVector3(System.String, UnityEngine.Vector3)bool w_S_r4r4r4_sS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_sS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Vector3Field(System.String, UnityEngine.Vector3, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4_sS_r4r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_sS_r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, void* p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 get_position()bool w_S_r4r4r4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetCellCenterLocal(UnityEngine.Vector3Int)bool w_S_r4r4r4_tS_i4i4i4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4_>(env, _sv1);
    S_i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3)bool w_S_r4r4r4_tS_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 Add(UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_r4r4r4_tS_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3, MonoOrStereoscopicEye)bool w_S_r4r4r4_tS_r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetPosition(UnityEngine.Animations.AnimationStream)bool w_S_r4r4r4_tS_u4pppppp_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_u4pppppp_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_u4pppppp_* pp1 = DataTransfer::GetPointer<S_u4pppppp_>(env, _sv1);
    S_u4pppppp_ p1 = pp1 ? *pp1 : S_u4pppppp_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_u4pppppp_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetIKPosition(UnityEngine.AvatarIKGoal)bool w_S_r4r4r4_ti4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetPoint(Single)bool w_S_r4r4r4_tr4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetInterpolatedNormal(Single, Single)bool w_S_r4r4r4_tr4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 TransformDirection(Single, Single, Single)bool w_S_r4r4r4_tr4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<float>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
 // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p1, float p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetVector(System.String)bool w_S_r4r4r4_ts(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<Il2CppString*>::accept(env, _sv1)) return false;            }
     // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(env, _sv1);
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector3 GetVertexPositionByIndex(UInt32)bool w_S_r4r4r4_tu4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tu4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<uint32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// PlaybackState GetPlaybackState()bool w_S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.JointDrive get_xDrive()bool w_S_r4r4r4i4_t(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 get_defaultTextureHDRDecodeValues()bool w_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    

    if (checkLuaArgument) {
        if (lua_args_len < 1) return false;
            }

    typedef struct S_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion RotationHandle(RotationHandleIds, UnityEngine.Quaternion, UnityEngine.Vector3)bool w_S_r4r4r4r4_S_i4i4i4i4i4_S_r4r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_i4i4i4i4i4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4_>(env, _sv1);
    S_i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_i4i4i4i4i4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color op_Implicit(UnityEngine.Color32)bool w_S_r4r4r4r4_S_i4u1u1u1u1_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_i4u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_i4u1u1u1u1_>(env, _sv1);
    S_i4u1u1u1u1_ p1 = pp1 ? *pp1 : S_i4u1u1u1u1_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_i4u1u1u1u1_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector2)bool w_S_r4r4r4r4_S_r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector4 Transform(System.Numerics.Vector2, System.Numerics.Quaternion)bool w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector4 Transform(System.Numerics.Vector2, System.Numerics.Matrix4x4)bool w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion LookRotation(UnityEngine.Vector3)bool w_S_r4r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion FromToRotation(UnityEngine.Vector3, UnityEngine.Vector3)bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector4 Transform(System.Numerics.Vector3, System.Numerics.Quaternion)bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector4 Transform(System.Numerics.Vector3, System.Numerics.Matrix4x4)bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect WorldPointToSizedRect(UnityEngine.Vector3, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_S_r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion AxisAngle(UnityEngine.Vector3, Single)bool w_S_r4r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 op_Implicit(UnityEngine.Color)bool w_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect AlignRectToDevice(UnityEngine.Rect, Int32 ByRef, Int32 ByRef)bool w_S_r4r4r4r4_S_r4r4r4r4_Pi4Pi4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_Pi4Pi4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, void* p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetDropDownRect(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Vector2, UnityEditor.ContainerWindow)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetDropDownRect(UnityEngine.Rect, UnityEngine.Vector2, UnityEngine.Vector2, UnityEditor.ContainerWindow, UnityEditor.PopupLocation[])bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4_S_r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv5, TIp5, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
     // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValToCSRef(TIp5, env _sv5);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion DoRotationHandle(UnityEngine.Quaternion, UnityEngine.Vector3)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion Disc(UnityEngine.Quaternion, UnityEngine.Vector3, UnityEngine.Vector3, Single, Boolean, Single)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_r4br4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!converter::Converter<float>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, bool p5, float p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion FreeRotateHandle(UnityEngine.Quaternion, UnityEngine.Vector3, Single)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color op_Addition(UnityEngine.Color, UnityEngine.Color)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion GetSquadIntermediate(UnityEngine.Quaternion, UnityEngine.Quaternion, UnityEngine.Quaternion)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 TextureScaleOffsetProperty(UnityEngine.Rect, UnityEngine.Vector4, Boolean)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_b(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, bool p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color Lerp(UnityEngine.Color, UnityEngine.Color, Single)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// System.Numerics.Vector4 Transform(System.Numerics.Vector4, System.Numerics.Matrix4x4)bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect RectField(UnityEngine.Rect, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_S_r4r4r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!!true) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, void* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, Int32, UnityEngine.GUIContent)bool w_S_r4r4r4r4_S_r4r4r4r4_i4o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_i4o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, Int32, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_S_r4r4r4r4_i4oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_i4oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<int32_t>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv4, TIp4, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
     // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValToCSRef(TIp4, env _sv4);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, UnityEngine.GUIContent)bool w_S_r4r4r4r4_S_r4r4r4r4_o(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 Vector4Field(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Vector4)bool w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean)bool w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbb(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbb");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 6) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, bool p4, bool p5, bool p6, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color ColorField(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.Color, Boolean, Boolean, Boolean, UnityEditor.ColorPickerHDRConfig)bool w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbbo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oS_r4r4r4r4_bbbo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    pesapi_value_sv6 = pesapi_get_arg(info, 6);
    pesapi_value_sv7 = pesapi_get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 7) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;                if (!converter::Converter<bool>::accept(env, _sv4)) return false;                if (!converter::Converter<bool>::accept(env, _sv5)) return false;                if (!converter::Converter<bool>::accept(env, _sv6)) return false;                if (!DataTransfer::IsAssignable(env, _sv7, TIp7, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(env, _sv5);        
        
 // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(env, _sv6);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValToCSRef(TIp7, env _sv7);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, bool p4, bool p5, bool p6, Il2CppObject* p7, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5, p6, p7,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect PrefixLabel(UnityEngine.Rect, UnityEngine.GUIContent, UnityEngine.GUIStyle)bool w_S_r4r4r4r4_S_r4r4r4r4_oo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_oo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, false)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValToCSRef(TIp2, env _sv2);
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Color op_Multiply(UnityEngine.Color, Single)bool w_S_r4r4r4r4_S_r4r4r4r4_r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect Inflate(UnityEngine.Rect, Single, Single, Single, Single)bool w_S_r4r4r4r4_S_r4r4r4r4_r4r4r4r4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    pesapi_value_sv5 = pesapi_get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 5) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!converter::Converter<float>::accept(env, _sv3)) return false;                if (!converter::Converter<float>::accept(env, _sv4)) return false;                if (!converter::Converter<float>::accept(env, _sv5)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(env, _sv3);        
        
 // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(env, _sv4);        
        
 // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(env, _sv5);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, float p3, float p4, float p5, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4, p5,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 Vector4Field(UnityEngine.Rect, System.String, UnityEngine.Vector4)bool w_S_r4r4r4r4_S_r4r4r4r4_sS_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_sS_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!converter::Converter<Il2CppString*>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
     // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(env, _sv2);
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, Il2CppString* p2, struct S_r4r4r4r4_ p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Quaternion QuaternionFromMatrix(UnityEngine.Matrix4x4)bool w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Vector4)bool w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!DataTransfer::IsAssignable(env, _sv1, TIp1, true)) return false;                if (!DataTransfer::IsAssignable(env, _sv2, TIp2, true)) return false;            }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect BeginHorizontal(UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!!true) return false;            }
 // LuaValToCSVal P any
    void* p1 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetControlRect(Boolean, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_bVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_bVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 2) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    void* p2 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p1, void* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetControlRect(Boolean, Single, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_br4Vo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_br4Vo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 3) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
 // LuaValToCSVal P any
    void* p3 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p1, float p2, void* p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Rect GetControlRect(Boolean, Single, UnityEngine.GUIStyle, UnityEngine.GUILayoutOption[])bool w_S_r4r4r4r4_br4oVo(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_br4oVo");
    
    auto TIret = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    pesapi_value_sv2 = pesapi_get_arg(info, 2);
    pesapi_value_sv3 = pesapi_get_arg(info, 3);
    pesapi_value_sv4 = pesapi_get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 4) return false;
                if (!converter::Converter<bool>::accept(env, _sv1)) return false;                if (!converter::Converter<float>::accept(env, _sv2)) return false;                if (!DataTransfer::IsAssignable(env, _sv3, TIp3, false)) return false;                if (!!true) return false;            }
 // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(env, _sv1);        
        
 // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(env, _sv2);        
        
     // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValToCSRef(TIp3, env _sv3);
        
 // LuaValToCSVal P any
    void* p4 = nullptr;        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(bool p1, float p2, Il2CppObject* p3, void* p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1, p2, p3, p4,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
// UnityEngine.Vector4 GetGlobalVector(Int32)bool w_S_r4r4r4r4_i4(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[1];    
    int lua_args_len = pesapi_get_args_len(info);
    
    pesapi_value_sv1 = pesapi_get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 1) return false;
                if (!converter::Converter<int32_t>::accept(env, _sv1)) return false;            }
 // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(env, _sv1);        
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p1,  method);
    

        pesapi_add_return(info, DataTransfer::CopyValueType(env, ret, TIret));        return true;
}
}

