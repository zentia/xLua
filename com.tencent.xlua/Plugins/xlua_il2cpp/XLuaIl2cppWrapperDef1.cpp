// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// System.IO.FileStream Open(System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare) declare in System.IO.FileInfo
bool w_oti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes, System.Reflection.BindingFlags, System.Reflection.MemberFilter, System.Object) declare in System.Type
bool w_oti4i4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4oO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Int64) declare in System.Text.StringBuilder
bool w_oti4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Char[]) declare in System.Text.StringBuilder
bool w_oti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[System.Int32] AddBind(ResData.ActorAbilitySymmetryType, System.Action`1[System.Int32], Boolean) declare in BindableDict`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_oti4oDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[System.Int32] AddBind2Target(ResData.ActorAbilitySymmetryType, System.Action`1[System.Int32], System.Object, Boolean) declare in BindableDict`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_oti4oODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Char[], Int32, Int32) declare in System.Text.StringBuilder
bool w_oti4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Reflection.CallingConventions, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_oti4oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_oti4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Single) declare in System.Text.StringBuilder
bool w_oti4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Double) declare in System.Text.StringBuilder
bool w_oti4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4r8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, double p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.String) declare in System.Text.StringBuilder
bool w_oti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.String, Int32) declare in System.Text.StringBuilder
bool w_oti4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4si4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Byte) declare in System.Text.StringBuilder
bool w_oti4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, UInt16) declare in System.Text.StringBuilder
bool w_oti4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Player GetPlayerByCampIndex(Int32, UInt32) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_oti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.GameWatchModeFactory InitCreators(Assets.Scripts.GameLogic.ObMode, UInt32, UInt32) declare in Assets.Scripts.GameSystem.GameWatchManager
bool w_oti4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, UInt64) declare in System.Text.StringBuilder
bool w_oti4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[System.Int64] GetUnreadyDependencies(Int64) declare in Assets.Scripts.Resource.Package.QtsPackageManager
bool w_oti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Component GetOrAddComponent(UnityEngine.Component, System.Type) declare in ExtComponent
bool w_oto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oto");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setOnUpdate(System.Action`2[System.Single,System.Object], System.Object) declare in LTDescr
bool w_otoDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoDO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IPooledMonoBehaviour GetCachedMonobehaviourByType(System.Type, Boolean) declare in Assets.Scripts.Framework.AssetService.ActorAsset
bool w_otoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// NOAH.VFX.VFXEffectHub PlayVFX(NOAH.VFX.EffectPlayParam, Int32) declare in Timi.TimiUserInterfaceEffects
bool w_otoDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type[] FindInterfaces(System.Reflection.TypeFilter, System.Object) declare in System.Type
bool w_otoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[System.Int32] AddBind2Target(System.Action`1[System.Int32], System.Object, Boolean) declare in BindableObject`1[System.Int32]
bool w_otoODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector2], UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTweenExt
bool w_otoS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4_ p2, struct S_r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector3], UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTweenExt
bool w_otoS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[UnityEngine.Color], UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTweenExt
bool w_otoS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Component GetComponentInChildren(System.Type, Boolean) declare in UnityEngine.Component
bool w_otob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char[], Int32) declare in System.String
bool w_otoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char[], Int32, System.StringSplitOptions) declare in System.String
bool w_otoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Material GetCustomMatWithDic(System.Collections.Generic.Dictionary`2[System.Int32,UnityEngine.Material], UnityEngine.Material, Boolean) declare in UnityEngine.UI.Image
bool w_otoob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UIWidgets.ListViewItem BindUIPrefab2Component(UnityEngine.GameObject, UIPrefab2D, Int32, System.String) declare in UIWidgets.EasyListView
bool w_otooi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otooi4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanMove(UnityEngine.GameObject, UnityEngine.Vector3[], Single) declare in LeanTweenExt
bool w_otor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otor4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[System.Single], Single, Single, Single) declare in LeanTweenExt
bool w_otor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otor4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, float p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object) declare in System.Text.StringBuilder
bool w_otosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otosOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otosOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object[]) declare in System.Text.StringBuilder
bool w_otosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.GameLogic.Project8Equipment+EquipRecommendInfo] GetConfigThenRecommendHeroForEquipList(UInt32[], UInt32) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_otou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otou4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// ResData.HighLightShowDataBin GetTriggerHighLightShowCfg(Assets.Scripts.GameLogic.Project8PlayerInstance, UInt32, UInt32) declare in Assets.Scripts.GameLogic.PlayerBattleBroadcast
bool w_otou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otou4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setDelay(Single) declare in LTDescr
bool w_otr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanDelayedCall(UnityEngine.GameObject, Single, System.Action`1[System.Object]) declare in LeanTweenExt
bool w_otr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,float p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanAlpha(UnityEngine.GameObject, Single, Single) declare in LeanTweenExt
bool w_otr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,float p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, Single, Single, Single) declare in LeanTweenExt
bool w_otr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,float p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Double) declare in System.Text.StringBuilder
bool w_otr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,double p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Transform FuzzyFind(UnityEngine.Transform, System.String) declare in ExtRectTransform
bool w_ots(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ots");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass GetOrCreateLuaChild(System.String, System.Object, Boolean, UnityEngine.Transform) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_otsDODbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDODbDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
                // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Transform FindChildWithSplit(UnityEngine.Transform, System.String, Boolean) declare in ExtRectTransform
bool w_otsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.WZArtistSceneAsset LoadWZArtistSceneAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.Object, System.String, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DODsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DODsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3); // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppObject* p3, Il2CppString* p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.TextureAsset LoadTextureAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.UIAsset LoadUIAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, Int32, UnityEngine.Transform) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1Di4Do");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
                // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.ActorAsset LoadActorAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppString* p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset LoadInstantiateAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, System.Object) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DsDi4DO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DsDi4DO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppString* p3, int32_t p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.ParticleAsset LoadParticleAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, UnityEngine.Transform) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DsDi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DsDi4Do");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppString* p3, int32_t p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// NOAH.VFX.VFXEffectHub PlayVFXEvent(System.String, Int32) declare in Timi.TimiUserInterfaceEffects
bool w_otsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GatherTag(System.String, System.String) declare in UnityEngine.Shader
bool w_otsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Coroutine StartCoroutine(System.String, System.Object) declare in UnityEngine.MonoBehaviour
bool w_otsO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.String, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otsOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.String, System.Object, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otsOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(System.String, System.Object[]) declare in System.Text.StringBuilder
bool w_otsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(System.String, System.String[]) declare in System.Text.StringBuilder
bool w_otsVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileInfo CopyTo(System.String, Boolean) declare in System.IO.FileInfo
bool w_otsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset GetPooledGameObj(System.String, Boolean, SceneObjType, UnityEngine.Vector3, UnityEngine.Quaternion) declare in SceneMgr
bool w_otsbi4S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsbi4S_r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.BaseAsset GetPooledGameObjLOD(System.String, Boolean, SceneObjType, UnityEngine.Vector3, UnityEngine.Quaternion, Assets.Scripts.Framework.AssetService.LifeType, System.String, System.String) declare in SceneMgr
bool w_otsbi4S_r4r4r4_S_r4r4r4r4_i1DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsbi4S_r4r4r4_S_r4r4r4r4_i1DsDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;
        if (lua_args_len > 7 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    int8_t p5 = converter::Converter<int8_t>::toCpp(apis, env, _sv5);
            // LuaValToCSVal string with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 6);    // LuaValToCSVal string with default
    Il2CppString* p7 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 7);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, int8_t p6, Il2CppString* p7, Il2CppString* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.BaseAsset GetPooledGameObjLOD(System.String, Boolean, SceneObjType, UnityEngine.Vector3, Assets.Scripts.Framework.AssetService.LifeType, System.String) declare in SceneMgr
bool w_otsbi4S_r4r4r4_i1Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsbi4S_r4r4r4_i1Ds");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
            // LuaValToCSVal string with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 5);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, struct S_r4r4r4_ p4, int8_t p5, Il2CppString* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.UIHPBarAsset LoadUIHPBarAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, Assets.Scripts.Framework.AssetService.UI3DAssetParam) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsi1S_S_r4r4r4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi1S_S_r4r4r4_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_S_r4r4r4_o_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_o_>(apis, env, _sv2);
    S_S_r4r4r4_o_ p2 = pp2 ? *pp2 : S_S_r4r4r4_o_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, struct S_S_r4r4r4_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] GetMember(System.String, System.Reflection.BindingFlags) declare in System.Type
bool w_otsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(System.String, Int32, System.StringSplitOptions) declare in System.String
bool w_otsi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] GetMember(System.String, System.Reflection.MemberTypes, System.Reflection.BindingFlags) declare in System.Type
bool w_otsi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Reflection.BindingFlags, System.Reflection.Binder, System.Reflection.CallingConventions, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4i4oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4i4oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4i4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4i4ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Type[]) declare in System.Type
bool w_otsi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Reflection.CallingConventions, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.PropertyInfo GetProperty(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4oooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Type[]) declare in System.Type
bool w_otso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass LoadLuaChildPrefab(System.String, UnityEngine.Transform, System.Object, Boolean, System.Nullable`1[UnityEngine.Vector3]) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otsoDODbDN_bS_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDODbDN_bS_r4r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal valuetype with default
    N_bS_r4r4r4__ p4 = OptionalParameter<N_bS_r4r4r4__>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, struct N_bS_r4r4r4__ p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass AsyncLoadLuaChildPrefab(System.String, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UILuaPrefabClass], System.Nullable`1[UnityEngine.Vector3]) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otsoDODbDoDN_bS_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDODbDoDN_bS_r4r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);    // LuaValToCSVal valuetype with default
    N_bS_r4r4r4__ p5 = OptionalParameter<N_bS_r4r4r4__>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, struct N_bS_r4r4r4__ p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// TimelineRuntime.Timeline PlayTimelineWithMultiActor(System.String, System.Collections.Generic.Dictionary`2[System.String,System.Collections.Generic.List`1[UnityEngine.Transform]], UnityEngine.GameObject) declare in TimelineRuntime.TimelineService
bool w_otsoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// TimelineRuntime.Timeline PlayTimeline(System.String, System.Collections.Generic.Dictionary`2[System.String,UnityEngine.GameObject], TimelineRuntime.TimelineHandler, UnityEngine.GameObject) declare in TimelineRuntime.TimelineService
bool w_otsoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte[] PictureCombine(System.String, UnityEngine.Texture2D, UnityEngine.Texture2D, enCombinePosition, Boolean, Boolean, Int32) declare in Assets.Scripts.GameSystem.ShareCaptureSys
bool w_otsooi4bbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsooi4bbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
         // LuaValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, bool p5, bool p6, int32_t p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.PropertyInfo GetProperty(System.String, System.Type, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AnimationState CrossFadeQueued(System.String, Single) declare in UnityEngine.Animation
bool w_otsr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AnimationState CrossFadeQueued(System.String, Single, UnityEngine.QueueMode) declare in UnityEngine.Animation
bool w_otsr4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsr4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AnimationState CrossFadeQueued(System.String, Single, UnityEngine.QueueMode, UnityEngine.PlayMode) declare in UnityEngine.Animation
bool w_otsr4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsr4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, float p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileInfo Replace(System.String, System.String) declare in System.IO.FileInfo
bool w_otss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileInfo Replace(System.String, System.String, Boolean) declare in System.IO.FileInfo
bool w_otssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otssb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Replace(System.String, System.String, Int32, Int32) declare in System.Text.StringBuilder
bool w_otssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otssi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte[] PictureCombineFromPath(System.String, System.String, System.String, enCombinePosition, Boolean, Boolean, Boolean, Int32) declare in Assets.Scripts.GameSystem.ShareCaptureSys
bool w_otsssi4bbDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsssi4bbDbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6))
            return false;
        if (lua_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
         // LuaValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 6);
             // LuaValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 7);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, bool p5, bool p6, bool p7, int32_t p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Byte) declare in System.Text.StringBuilder
bool w_otu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(UInt16) declare in System.Text.StringBuilder
bool w_otu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint16_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.GameLogic.Project8EquipPropItemData] GetEquipPropItemDataListById(UInt16, UInt32) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_otu2Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu2Du4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    uint32_t p1 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,uint16_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GameObject GetAuctionItemUIGo(UInt32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_otu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SkillHurtInfoParam[] GetActorDamagePropertyArray(UInt32, Int32) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_otu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// WaitCheckSeqDone WaitForCanWearEquipItems(UInt32, System.Collections.Generic.List`1[Assets.Scripts.UI.InTheGame.Common.UIEquipCommonItem+EquipWithActor]) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_otu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset CreateUnityObject(UInt32, System.String, System.String, Boolean, Boolean, UInt32) declare in UnityObjMgr
bool w_otu4ssbbu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4ssbbu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, Il2CppString* p2, Il2CppString* p3, bool p4, bool p5, uint32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setId(UInt32, UInt32) declare in LTDescr
bool w_otu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// WaitCheckSeqDone WaitForCanTakeOffEquip(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_otu4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// WaitCheckSeqDone WaitForCanWearEquip(UInt32, UInt32, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_otu4u4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4DbDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.UI.InGameCommon.UIPropData+HeroPropPanelItemData] GetHeroPropList(UInt32, UInt32, Boolean, Int32, Int32, UInt32[]) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_otu4u4bi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4bi4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, int32_t p4, int32_t p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameSystem.FloatRunInfo GetFloatRunInfo(UInt32, UInt32, Assets.Scripts.GameSystem.FLOAT_TYPE, Int32) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_otu4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator UpgradeEquip(UInt32, UInt32, UInt32, UInt32) declare in Assets.Scripts.GameSystem.UIComponentEquip
bool w_otu4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(UInt64) declare in System.Text.StringBuilder
bool w_otu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,uint64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Project8PlayerInstance GetPlayerInstance(UInt32) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[SGW+SkillHurtInfoParam] NeedCalculateValue(UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ou4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// ResData.ResLordSkillDataBin GetSkill(UInt32, UInt32) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_ou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// ResData.ResLordSkillDataBin GetSkill(UInt32, UInt32, UInt32) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_ou4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AkChannelConfig GetSpeakerConfiguration(UInt64) declare in AkSoundEngine
bool w_ou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IntPtr SGameGetExtraCrashLoggerExport() declare in SGamePInvoke
bool w_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_p");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);
	int r = apis->create_binary(env, ret, 0);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IntPtr op_Explicit(CurlUnity.CurlEasy) declare in CurlUnity.CurlEasy
bool w_po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_po");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef void* (*FuncToCall)(Il2CppObject* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = apis->create_binary(env, ret, 0);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IntPtr GetNativeDepthBufferPtr() declare in UnityEngine.RenderTexture
bool w_pt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pt");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = apis->create_binary(env, ret, 0);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single get_time() declare in UnityEngine.Time
bool w_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.Object) declare in System.Convert
bool w_r4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.Object, System.IFormatProvider) declare in System.Convert
bool w_r4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.Decimal) declare in System.Convert
bool w_r4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef float (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetParticleCurveMax(MinMaxCurve) declare in Assets.Scripts.Framework.UI.TimiEffectLoader
bool w_r4S_i4r4oor4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4r4oor4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4r4oor4r4_* pp0 = DataTransfer::GetPointer<S_i4r4oor4r4_>(apis, env, _sv0);
    S_i4r4oor4r4_ p0 = pp0 ? *pp0 : S_i4r4oor4r4_ {};
        
    typedef float (*FuncToCall)(struct S_i4r4oor4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SqrMagnitude(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Dot(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_r4S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Magnitude(UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_r4S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Magnitude(UnityEngine.Vector4) declare in UnityEngine.Vector4
bool w_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Dot(UnityEngine.Quaternion, UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_r4S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetActorHudHeight(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_r4S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef float (*FuncToCall)(struct S_u4o_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.DateTime) declare in System.Convert
bool w_r4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef float (*FuncToCall)(struct S_u8_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Min(Single[]) declare in UnityEngine.Mathf
bool w_r4Vr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Vr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<float>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef float (*FuncToCall)(Il2CppArray* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Boolean) declare in System.Convert
bool w_r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(bool p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Char) declare in System.Convert
bool w_r4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(Il2CppChar p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(SByte) declare in System.Convert
bool w_r4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(int8_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Int16) declare in System.Convert
bool w_r4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(int16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetStreamProgressForLevel(Int32) declare in UnityEngine.Application
bool w_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Int64) declare in System.Convert
bool w_r4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(int64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single RecordLayoutHeight(UnityEngine.MonoBehaviour) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single tweenOnCurve(LTDescr, Single) declare in LeanTween
bool w_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef float (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ValidtionVal(Single) declare in com.pixui.PxMisc
bool w_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single FocalLengthToFieldOfView(Single, Single) declare in UnityEngine.Camera
bool w_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef float (*FuncToCall)(float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef float (*FuncToCall)(float p1, float p2, float* p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef float (*FuncToCall)(float p1, float p2, float* p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single, Single, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
        
    typedef float (*FuncToCall)(float p1, float p2, float* p3, float p4, float p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeOutQuadOpt(Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeInBack(Single, Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeInElastic(Single, Single, Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4Dr4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single TweenLerp(Single, Single, Single, LeanTweenType) declare in LeanTweenExt
bool w_r4r4r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, int32_t p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeInOutQuadOpt2(Single, Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Double) declare in System.Convert
bool w_r4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(double p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetStreamProgressForLevel(System.String) declare in UnityEngine.Application
bool w_r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef float (*FuncToCall)(Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetTextCalculateHeight(System.String, Boolean, Single, Int32, Single) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_r4sbr4Di4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sbr4Di4Dr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef float (*FuncToCall)(Il2CppString* p1, bool p2, float p3, int32_t p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetTextCalculateWidth(System.String, ShrinkText) declare in ShrinkText
bool w_r4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef float (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetTextCalculateHeight(System.String, ShrinkText, Single) declare in ShrinkText
bool w_r4sor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sor4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef float (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetFloat(System.String, Single) declare in UnityEngine.PlayerPrefs
bool w_r4sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef float (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetWidth(UnityEngine.RectTransform) declare in ExtRectTransform
bool w_r4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SqrDistance(UnityEngine.Vector3) declare in UnityEngine.Bounds
bool w_r4tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ShowPhaseChange(Boolean, Int32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_r4tbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tbDi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef float (*FuncToCall)(void*,bool p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single get_Item(Int32) declare in UnityEngine.Quaternion
bool w_r4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(void*,int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetEffectValue(ResData.RES_RELATION_ID, Int32) declare in Assets.Scripts.GameLogic.PlayerRelation
bool w_r4ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef float (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SetAnimation(Int32, System.String, Boolean) declare in UnityEngine.UnitySkeletonGraphic
bool w_r4ti4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4sb");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef float (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single AverageFloat(FingerPropertyGetterDelegate`1) declare in FingerList
bool w_r4to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4to");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetLength(UnityEngine.RectTransform, Boolean) declare in UIWidgets.EasyLayout
bool w_r4toDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4toDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SetSkeletonDataAsset(UnityEngine.UnitySkeletonDataAsset, System.String, Boolean) declare in UIWidgets.UISpine
bool w_r4tosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tosb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetRealOffsetValue(Single, Single) declare in Moba_Camera
bool w_r4tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef float (*FuncToCall)(void*,float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetAnimationLength(System.String) declare in Assets.Scripts.Framework.AssetService.ActorAsset
bool w_r4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef float (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ExtCrossFade(UnityEngine.Animation, System.String, Single, Single, Single) declare in ExtAnimation
bool w_r4tsr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsr4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetActorHudHeight(UInt32) declare in Assets.Scripts.GameLogic.ActorManager
bool w_r4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(void*,uint32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Byte) declare in System.Convert
bool w_r4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(uint8_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(UInt16) declare in System.Convert
bool w_r4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(uint16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(UInt32) declare in System.Convert
bool w_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(uint32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(UInt64) declare in System.Convert
bool w_r4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef float (*FuncToCall)(uint64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double get_timeAsDouble() declare in UnityEngine.Time
bool w_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.Object) declare in System.Convert
bool w_r8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef double (*FuncToCall)(Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.Object, System.IFormatProvider) declare in System.Convert
bool w_r8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef double (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.Decimal) declare in System.Convert
bool w_r8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef double (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.DateTime) declare in System.Convert
bool w_r8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef double (*FuncToCall)(struct S_u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Boolean) declare in System.Convert
bool w_r8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(bool p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Char) declare in System.Convert
bool w_r8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(Il2CppChar p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(SByte) declare in System.Convert
bool w_r8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(int8_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Int16) declare in System.Convert
bool w_r8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(int16_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Int32) declare in System.Convert
bool w_r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Int64) declare in System.Convert
bool w_r8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(int64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Single) declare in System.Convert
bool w_r8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(float p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Double) declare in System.Convert
bool w_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.String) declare in System.Convert
bool w_r8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef double (*FuncToCall)(Il2CppString* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.String, System.IFormatProvider) declare in System.Convert
bool w_r8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef double (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToOADate() declare in System.DateTime
bool w_r8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Byte) declare in System.Convert
bool w_r8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(uint8_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(UInt16) declare in System.Convert
bool w_r8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(uint16_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(UInt32) declare in System.Convert
bool w_r8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(uint32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(UInt64) declare in System.Convert
bool w_r8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef double (*FuncToCall)(uint64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String get_buildGUID() declare in UnityEngine.Application
bool w_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppString* (*FuncToCall)(const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String AddGoldCoinInBattle(ResData.CountableAssetType, Int32) declare in CheatCommandBattleEntry
bool w_sDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sDi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String AddLordSkillExpInBattle(UInt32) declare in CheatCommandBattleEntry
bool w_sDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sDu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    uint32_t p0 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Object) declare in System.Convert
bool w_sO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object, System.Object) declare in System.String
bool w_sOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object, System.Object, System.Object) declare in System.String
bool w_sOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object, System.Object, System.Object, System.Object, ...) declare in System.String
bool w_sOOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Object, System.IFormatProvider) declare in System.Convert
bool w_sOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String deserialize_string(Byte* ByRef) declare in SGW
bool w_sPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
 
    // LuaValToCSVal P not primitive
    uint8_t** p0 = nullptr;

    typedef Il2CppString* (*FuncToCall)(uint8_t** p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret0 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(System.ReadOnlySpan`1[System.Byte], System.Base64FormattingOptions) declare in System.Convert
bool w_sS_S_p_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_sS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Decimal) declare in System.Convert
bool w_sS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Decimal, System.IFormatProvider) declare in System.Convert
bool w_sS_i4i4i4i4u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToHtmlStringRGB(UnityEngine.Color) declare in UnityEngine.ColorUtility
bool w_sS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.DateTime) declare in System.Convert
bool w_sS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.DateTime, System.IFormatProvider) declare in System.Convert
bool w_sS_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object[]) declare in System.String
bool w_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

    }
    // LuaValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.String[]) declare in System.String
bool w_sVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
     // LuaValToCSVal string params
    Il2CppArray* p0 = Params<void*>::PackString(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Boolean) declare in System.Convert
bool w_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Boolean, System.IFormatProvider) declare in System.Convert
bool w_sbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sbo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetCachePath(Boolean, System.String) declare in MultifunctionRawImage
bool w_sbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sbs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(bool p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Char) declare in System.Convert
bool w_sc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(Char, System.Object[]) declare in System.String
bool w_scVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
            // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(Char, System.String[]) declare in System.String
bool w_scVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
             // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Char, System.IFormatProvider) declare in System.Convert
bool w_sco(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sco");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(Char, System.String[], Int32, Int32) declare in System.String
bool w_scoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(SByte) declare in System.Convert
bool w_si1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(int8_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(SByte, System.IFormatProvider) declare in System.Convert
bool w_si1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si1o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int8_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int16) declare in System.Convert
bool w_si2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(int16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int16, Int32) declare in System.Convert
bool w_si2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int16_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int16, System.IFormatProvider) declare in System.Convert
bool w_si2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int16_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String LayerToName(Int32) declare in UnityEngine.LayerMask
bool w_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SelectedIndexToKey(Int32, Int32) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_si4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetWindowsDeviceName(Int32, UInt32 ByRef) declare in AkSoundEngine
bool w_si4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4Pu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef Il2CppString* (*FuncToCall)(int32_t p1, uint32_t* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetWindowsDeviceName(Int32, UInt32 ByRef, AkAudioDeviceState) declare in AkSoundEngine
bool w_si4Pu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4Pu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, uint32_t* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Project8ClearEquip(Int32, Boolean) declare in CheatCommandBattleEntry
bool w_si4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFractionString(Int32, Int32) declare in Localize
bool w_si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetRelationEffect(Int32, Int32, Boolean) declare in Assets.Scripts.GameSystem.UIRelation
bool w_si4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SpawnProject8Hero(Int32, Int32, Int32) declare in CheatCommandBattleEntry
bool w_si4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SpawnProject8Enemy(Int32, Int32, Int32, Int32) declare in CheatCommandBattleEntry
bool w_si4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String PickCard(Int32, OSProto.CardPileType, System.String) declare in CheatCommandBattleEntry
bool w_si4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int32, System.IFormatProvider) declare in System.Convert
bool w_si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int64) declare in VersionInfo
bool w_si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(int64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int64, Int32) declare in System.Convert
bool w_si8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int64_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int64, System.IFormatProvider) declare in System.Convert
bool w_si8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(int64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String DateTimeFormat(Int64, System.String) declare in Utility
bool w_si8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(int64_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetPathMethod(System.Type) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_so");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetNodePath(UnityEngine.Transform, Int32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_soDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetName(System.Type, System.Object) declare in System.Enum
bool w_soO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.Type, System.Object, System.String) declare in System.Enum
bool w_soOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soOs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetAnimNameByIndex(UnityEngine.Animation, Int32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(Byte[], Int32, Int32) declare in System.Convert
bool w_soi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(Byte[], Int32, Int32, System.Base64FormattingOptions) declare in System.Convert
bool w_soi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetCurPlayingAnimationName(UnityEngine.Animation, UnityEngine.Animator) declare in LuaCallCSharpInteraction
bool w_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetGoFullPathRelatively(UnityEngine.GameObject, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_sos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object) declare in System.String
bool w_sosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object) declare in System.String
bool w_sosOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object, System.Object) declare in System.String
bool w_sosOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object[]) declare in System.String
bool w_sosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String StringFromIntPtrString(IntPtr) declare in AkSoundEngine
bool w_sp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sp");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Single) declare in System.Convert
bool w_sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(float p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Single, System.IFormatProvider) declare in System.Convert
bool w_sr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(float p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Double) declare in System.Convert
bool w_sr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(double p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Double, System.IFormatProvider) declare in System.Convert
bool w_sr8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr8o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(double p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetHashPath(System.String) declare in com.pixui.PxMisc
bool w_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetDirectory(System.String, Boolean) declare in CFileManager
bool w_ssDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFullPathInResources(System.String, System.String) declare in CFileManager
bool w_ssDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.String, System.Object) declare in System.String
bool w_ssO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.String, System.Object, System.Object) declare in System.String
bool w_ssOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.String, System.Object, System.Object, System.Object) declare in System.String
bool w_ssOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetString(System.String, System.Object[]) declare in Localize
bool w_ssVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.String, System.String[]) declare in System.String
bool w_ssVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFixedPlayerName(System.String, Int32) declare in Assets.Scripts.GameSystem.Project8UIPlayerRank
bool w_ssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.String, System.IFormatProvider) declare in System.Convert
bool w_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.String, System.String[], Int32, Int32) declare in System.String
bool w_ssoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceCalculateValue(System.String, Int32[], UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssou4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssou4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetCombineStr(System.String, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceDescWithParams(System.String, System.String, System.String, UInt32, UInt32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_sssDsDu4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssDsDu4Du4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, uint32_t p4, uint32_t p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator) declare in System.Text.RegularExpressions.Regex
bool w_ssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions) declare in System.Text.RegularExpressions.Regex
bool w_sssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_sssoi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
             // LuaValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, struct S_i8_ p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.String, System.String, System.String) declare in System.String
bool w_ssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions) declare in System.Text.RegularExpressions.Regex
bool w_ssssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_ssssi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
             // LuaValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, struct S_i8_ p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.String, System.String, System.String, System.String) declare in System.String
bool w_sssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String FormatOpt(System.String, System.String, System.String, System.String, System.String) declare in StringHelper
bool w_ssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String FormatOpt(System.String, System.String, System.String, System.String, System.String, System.String) declare in StringHelper
bool w_sssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);    // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String FormatOpt(System.String, System.String, System.String, System.String, System.String, System.String, System.String) declare in StringHelper
bool w_ssssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);    // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);    // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, Il2CppString* p7, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceOutSkillDesc(System.String, UInt32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceSkillLevelUpTips(System.String, UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceInSkillDesc(System.String, UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceRelativeDesc(System.String, UInt32, UInt32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Ptr2Str(IntPtr) declare in com.pixui.PxMisc
bool w_st(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_st");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppString* (*FuncToCall)(void*,const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetLordIconPath(LordIconType) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_stDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetBattleArtPrefabName(Int32, Int32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_stDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Available(System.String) declare in BoxSDK.BoxSDKService
bool w_stDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetEnumName(System.Object) declare in System.Type
bool w_stO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Trim(Char[]) declare in System.String
bool w_stVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stVc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Trim(Char) declare in System.String
bool w_stc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(Char, Char) declare in System.String
bool w_stcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stcc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetSpinePath(Int32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_sti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String PadLeft(Int32, Char) declare in System.String
bool w_sti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4c");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetBattlePrefab(Int32, ModelLevelDefine) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_sti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetHeroPropValueStr(Int32, Int32, UInt32, Boolean) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_sti4i4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4u4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, uint32_t p3, bool p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Insert(Int32, System.String) declare in System.String
bool w_sti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetHangPointRelativePath(OSProto.HangUIType, UInt32) declare in Assets.Scripts.GameSystem.UIComponentArtEffect
bool w_sti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetRelativePath(UnityEngine.Transform, UnityEngine.Transform) declare in ExtTransform
bool w_sto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sto");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetOutputText(System.String) declare in ShrinkText
bool w_sts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sts");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Get(System.String, System.String) declare in Assets.Scripts.Update.GCloudConfig+KeyValueConfig
bool w_stsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String TranslateLodFileName(System.String, Effect.EffectLoadErrorCode ByRef, DepDisconnectedAssetInfoRuntimeData ByRef) declare in Effect.EffectLODAdaptor
bool w_stsPi4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsPi4Po");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t* p2, Il2CppObject** p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetVideoKeyHash(System.String, System.String ByRef) declare in BoxSDK.BoxSDKService
bool w_stsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsPs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString** p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTag(System.String, Boolean) declare in UnityEngine.Material
bool w_stsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTag(System.String, Boolean, System.String) declare in UnityEngine.Shader
bool w_stsbDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsbDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTag(System.String, Boolean, System.String) declare in UnityEngine.Material
bool w_stsbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsbs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetPathWithLodPostfix(System.String, Int32, Boolean) declare in SceneMgr
bool w_stsi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetProject8DynamicMatPath(System.String, ResData.PLAYMOD_TYPE, UInt32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_stsi4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, uint32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.String, System.IFormatProvider) declare in UnityEngine.Quaternion
bool w_stso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stsoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String) declare in System.String
bool w_stss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_stssbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssbo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.StringComparison) declare in System.String
bool w_stssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, Int32, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetProject8ExtraClipsFilePath(UInt32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_stu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetSkillDesc(UInt32, Int32) declare in Assets.Scripts.GameLogic.SeasonData
bool w_stu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Byte) declare in System.Convert
bool w_su1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(uint8_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Byte, Int32) declare in System.Convert
bool w_su1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint8_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Byte, System.IFormatProvider) declare in System.Convert
bool w_su1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint8_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt16) declare in System.Convert
bool w_su2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(uint16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt16, System.IFormatProvider) declare in System.Convert
bool w_su2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su2o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint16_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetInt2String(UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SetHP(UInt32, Int32) declare in CheatCommandBattleEntry
bool w_su4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Project8TestPlayerAIBpTest(UInt32, Int32, Int32) declare in CheatCommandBattleEntry
bool w_su4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt32, System.IFormatProvider) declare in System.Convert
bool w_su4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetLordBattleArtPrefabName(UInt32, UInt32) declare in Assets.Scripts.GameLogic.OSGBattleLoader
bool w_su4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SpawnProject8Equip(UInt32, UInt32, Boolean) declare in CheatCommandBattleEntry
bool w_su4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4u4Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, uint32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt64) declare in System.Convert
bool w_su8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppString* (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt64, System.IFormatProvider) declare in System.Convert
bool w_su8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppString* (*FuncToCall)(uint64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetUtcToLocalTimeStringFormat(UInt64, System.String) declare in Utility
bool w_su8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(uint64_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte get_AK_INTERLEAVED() declare in AkSoundEngine
bool w_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint8_t (*FuncToCall)(const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.Object) declare in System.Convert
bool w_u1O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u1Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.Decimal) declare in System.Convert
bool w_u1S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.DateTime) declare in System.Convert
bool w_u1S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Boolean) declare in System.Convert
bool w_u1b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(bool p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Char) declare in System.Convert
bool w_u1c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(SByte) declare in System.Convert
bool w_u1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(int8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Int16) declare in System.Convert
bool w_u1i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(int16_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Int32) declare in System.Convert
bool w_u1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Int64) declare in System.Convert
bool w_u1i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(int64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Single) declare in System.Convert
bool w_u1r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(float p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Double) declare in System.Convert
bool w_u1r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(double p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.String) declare in System.Convert
bool w_u1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.String, Int32) declare in System.Convert
bool w_u1si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.String, System.IFormatProvider) declare in System.Convert
bool w_u1so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte GetPhaseType() declare in Assets.Scripts.GameLogic.Project8RoundStateFlow
bool w_u1t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint8_t (*FuncToCall)(void*,const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Byte) declare in System.Convert
bool w_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(uint8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(UInt16) declare in System.Convert
bool w_u1u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(uint16_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(UInt32) declare in System.Convert
bool w_u1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(uint32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ChannelBitToIndex(UInt32, UInt32) declare in AkSoundEngine
bool w_u1u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef uint8_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(UInt64) declare in System.Convert
bool w_u1u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t (*FuncToCall)(uint64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 get_AK_INT() declare in AkSoundEngine
bool w_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint16_t (*FuncToCall)(const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.Object) declare in System.Convert
bool w_u2O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u2Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.Decimal) declare in System.Convert
bool w_u2S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.DateTime) declare in System.Convert
bool w_u2S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Boolean) declare in System.Convert
bool w_u2b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(bool p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Char) declare in System.Convert
bool w_u2c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(SByte) declare in System.Convert
bool w_u2i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(int8_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Int16) declare in System.Convert
bool w_u2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(int16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Int32) declare in System.Convert
bool w_u2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Int64) declare in System.Convert
bool w_u2i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(int64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Single) declare in System.Convert
bool w_u2r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(float p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Double) declare in System.Convert
bool w_u2r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(double p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.String) declare in System.Convert
bool w_u2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.String, Int32) declare in System.Convert
bool w_u2si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.String, System.IFormatProvider) declare in System.Convert
bool w_u2so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Byte) declare in System.Convert
bool w_u2u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(uint8_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(UInt16) declare in System.Convert
bool w_u2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(uint16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(UInt32) declare in System.Convert
bool w_u2u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(uint32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(UInt64) declare in System.Convert
bool w_u2u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef uint16_t (*FuncToCall)(uint64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetCurUnixTimestamp() declare in Utility
bool w_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint32_t (*FuncToCall)(const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.Object) declare in System.Convert
bool w_u4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.Decimal) declare in System.Convert
bool w_u4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetPlayerId(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_u4S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_u4o_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUtcSeconds(System.DateTime) declare in Utility
bool w_u4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Boolean) declare in System.Convert
bool w_u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(bool p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Char) declare in System.Convert
bool w_u4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(SByte) declare in System.Convert
bool w_u4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(int8_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Int16) declare in System.Convert
bool w_u4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(int16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Int32) declare in System.Convert
bool w_u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ConvertToUnixTimestamp(Int32, Int32, Int32, Int32, Int32, Int32) declare in Utility
bool w_u4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef uint32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 StdChannelIndexToDisplayIndex(AkChannelOrdering, UInt32, UInt32) declare in AkSoundEngine
bool w_u4i4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef uint32_t (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Int64) declare in System.Convert
bool w_u4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(int64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetCanvasLayerAndOrder(UIPrefab2D) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 DynamicSequenceOpen(UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4ou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 DynamicSequenceOpen(UnityEngine.GameObject, UInt32, EventCallback, System.Object, AkDynamicSequenceType) declare in AkSoundEngine
bool w_u4ou4oOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ou4oOi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 OSG_PopOutputBuffer(IntPtr, Int32) declare in SGamePInvoke
bool w_u4pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Single) declare in System.Convert
bool w_u4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(float p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Double) declare in System.Convert
bool w_u4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(double p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.String) declare in System.Convert
bool w_u4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.String, Int32) declare in System.Convert
bool w_u4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.String, System.IFormatProvider) declare in System.Convert
bool w_u4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ReadFile(System.String, Byte[], UInt32) declare in CFileManager
bool w_u4sou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4sou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4sou4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4sou4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
                
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CompressFile(System.String, System.String, Byte[], UInt32) declare in CFileManager
bool w_u4ssou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ssou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, uint32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64) declare in AkSoundEngine
bool w_u4su8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4su8u4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8u4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4su8u4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8u4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4su8u4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8u4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
                
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
        
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 get_SvrFrameDelta() declare in Assets.Scripts.Framework.FrameSynchr
bool w_u4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetRepickCardCost(Boolean) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_u4tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tDb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef uint32_t (*FuncToCall)(void*,bool p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroObjId(Int32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_u4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetOnFightHeroId(Int32, Int32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_u4ti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4Di4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetBattleHeroByCoord(Int32, Int32, UInt32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_u4ti4i4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4i4Du4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddNotice(Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeStyle, System.String, System.String, Boolean, Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeType, Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeEnergy) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4ti4sDsDbDi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4sDsDbDi4Do");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5);
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, Il2CppString* p3, bool p4, int32_t p5, Il2CppObject* p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayHeroActSound(System.String) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayBattleSound2D(System.String, Int32) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsDo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayLogicSound(System.String, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], UnityEngine.GameObject, Boolean, Int32) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsS_u4o_obDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsS_u4o_obDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
         // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, struct S_u4o_ p2, Il2CppObject* p3, bool p4, int32_t p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayBattleSound(System.String, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], UnityEngine.GameObject, Boolean, Boolean, Int32) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsS_u4o_obbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsS_u4o_obbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
         // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, struct S_u4o_ p2, Il2CppObject* p3, bool p4, bool p5, int32_t p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, Boolean, UInt32, EventCallback, System.Object) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsobu4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsobu4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, bool p3, uint32_t p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UInt32, EventCallback, System.Object) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsu4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsu4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetAuctionItemUniqueId(UInt32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_u4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroObjId(UInt32, Int32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_u4tu4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4Di4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 Play(UInt32, System.Collections.Generic.Dictionary`2[System.UInt32,System.Int32], Int32) declare in Assets.Scripts.Sound.PlayBroadcastManager
bool w_u4tu4DoDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4DoDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroObjId(UInt32, VInt2) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_u4tu4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, struct S_i4i4_ p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CanWearEquipItems(UInt32, UInt32[]) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_u4tu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddWinnerNotice(UInt32, System.String, Boolean) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4tu4sDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4sDb");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1); // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, Il2CppString* p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CombineEquipment(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameSystem.Project8EquipmentRecipe
bool w_u4tu4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CanTakeOffEquip(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_u4tu4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CanWearEquip(UInt32, UInt32, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_u4tu4u4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4bb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, bool p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddHighlightNotice(UInt32, UInt32, Boolean, UInt32, Boolean) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4tu4u4bu4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4bu4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
         // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, uint32_t p4, bool p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetPlayerObjId(UInt64) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_u4tu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(void*,uint64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Byte) declare in System.Convert
bool w_u4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(uint8_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(UInt16) declare in System.Convert
bool w_u4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(uint16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(UInt32) declare in System.Convert
bool w_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroCfgId(UInt32, UInt32) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_u4u4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4Du4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    uint32_t p1 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_u4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ResolveDialogueEvent(UInt32, UInt32[], UInt32) declare in AkSoundEngine
bool w_u4u4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4u4ou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4u4ou4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4u4ou4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
                
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ResolveDialogueEvent(UInt32, UInt32[], UInt32, UInt32) declare in AkSoundEngine
bool w_u4u4ou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, uint32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64) declare in AkSoundEngine
bool w_u4u4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4u4u8u4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8u4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4u4u8u4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8u4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4u4u8u4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8u4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
                
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);
        
    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(UInt64) declare in System.Convert
bool w_u4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef uint32_t (*FuncToCall)(uint64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 NowMilliseconds() declare in GCloud.GMall.TimeHelper
bool w_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint64_t (*FuncToCall)(const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.Object) declare in System.Convert
bool w_u8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetStringId(Byte*, Int32) declare in SGW
bool w_u8Pu1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8Pu1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(uint8_t* p1, int32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.Decimal) declare in System.Convert
bool w_u8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.DateTime) declare in System.Convert
bool w_u8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Boolean) declare in System.Convert
bool w_u8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(bool p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Char) declare in System.Convert
bool w_u8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(SByte) declare in System.Convert
bool w_u8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(int8_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Int16) declare in System.Convert
bool w_u8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(int16_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Int32) declare in System.Convert
bool w_u8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 CalcActorSkinHashCode(ResData.ActorType, Int32, UInt32) declare in Assets.Scripts.GameLogic.DataCenter.ActorMeta
bool w_u8i4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4i4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef uint64_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Int64) declare in System.Convert
bool w_u8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(int64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetAkGameObjectID(UnityEngine.GameObject) declare in AkSoundEngine
bool w_u8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Single) declare in System.Convert
bool w_u8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(float p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Double) declare in System.Convert
bool w_u8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(double p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.String) declare in System.Convert
bool w_u8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.String, Int32) declare in System.Convert
bool w_u8si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.String, System.IFormatProvider) declare in System.Convert
bool w_u8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetOutputID(System.String, UInt32) declare in AkSoundEngine
bool w_u8su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8su4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 get_sceneCullingMask() declare in UnityEngine.GameObject
bool w_u8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetUInt64(System.String, UInt64) declare in Assets.Scripts.Update.GCloudConfig+KeyValueConfig
bool w_u8tsDu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tsDu8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    uint64_t p1 = OptionalParameter<uint64_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint64_t (*FuncToCall)(void*,Il2CppString* p1, uint64_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetPlayerUid(UInt32) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_u8tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(void*,uint32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetHeroWearScore(UInt32, UInt32) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_u8tu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Byte) declare in System.Convert
bool w_u8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(uint8_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(UInt16) declare in System.Convert
bool w_u8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(uint16_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(UInt32) declare in System.Convert
bool w_u8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(uint32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetOutputID(UInt32, UInt32) declare in AkSoundEngine
bool w_u8u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef uint64_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(UInt64) declare in System.Convert
bool w_u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef uint64_t (*FuncToCall)(uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Quit() declare in UnityEngine.Application
bool w_v(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_v");

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);
    return true;
}
// Void UnloadUnusedAssets(Boolean) declare in CResourceManager
bool w_vDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void MarkMainFunctionExecute(Int32) declare in GCloud.GPM.GPMAgent
bool w_vDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void LoginWithConfirmCode(Int32, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vDi4DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDi4DsDs");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
                // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void LoginUI(System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDs");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);
    typedef void (*FuncToCall)(Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void TakeSnapshot(System.String, System.String) declare in Assets.Scripts.Framework.PerfUtils
bool w_vDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDsDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Logout(System.String, System.String, Boolean) declare in GCloud.MSDK.MSDKLogin
bool w_vDsDsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDsDsDb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1); // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void TakeSnapshotNativeAllocation(System.String, System.String, System.Action) declare in Assets.Scripts.Framework.PerfUtils
bool w_vDsDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDsDsDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Clear(System.Object) declare in EventRouter
bool w_vO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void OnActorEnterView(ActorRecoverData ByRef) declare in SGC
bool w_vPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p0 = DataTransfer::GetPointer<S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayBattleSound(SoundParams ByRef) declare in SGC
bool w_vPS_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_* p0 = DataTransfer::GetPointer<S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayUIParticle(AgeUIParticleInfo ByRef) declare in SGC
bool w_vPS_i4S_u8_r4S_r4r4r4_r4u4S_u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4S_u8_r4S_r4r4r4_r4u4S_u8__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4S_u8_r4S_r4r4r4_r4u4S_u8__* p0 = DataTransfer::GetPointer<S_i4S_u8_r4S_r4r4r4_r4u4S_u8__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4S_u8_r4S_r4r4r4_r4u4S_u8__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_i4S_u8_r4S_r4r4r4_r4u4S_u8__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAgeChangeMaterial(MaterialChangeData ByRef) declare in SGC
bool w_vPS_i4u4u4S_oS_u8_oor4_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4u4S_oS_u8_oor4_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4u4u4S_oS_u8_oor4_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4__* p0 = DataTransfer::GetPointer<S_i4u4u4S_oS_u8_oor4_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4u4S_oS_u8_oor4_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_i4u4u4S_oS_u8_oor4_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetupClientInner(StartClientParam ByRef) declare in SGW
bool w_vPS_i4u4u4i4i4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4u4i4i4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4u4u4i4i4o_* p0 = DataTransfer::GetPointer<S_i4u4u4i4i4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4u4i4i4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_i4u4u4i4i4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfSetPathVisibilityProcess(SetPathVisibilityParam ByRef) declare in SGC
bool w_vPS_oS_u8_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oS_u8_u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oS_u8_u1_* p0 = DataTransfer::GetPointer<S_oS_u8_u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oS_u8_u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oS_u8_u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetRecommendEquipDatas(RecommendEquipDatas ByRef) declare in SGW
bool w_vPS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_o_* p0 = DataTransfer::GetPointer<S_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8RoundStatisticInfo(Project8RoundStatisticInfoList ByRef) declare in SGC
bool w_vPS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oo_* p0 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8AuctionUnlockChange(Project8AuctionUnlockChange ByRef) declare in SGC
bool w_vPS_oooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oooo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oooo_* p0 = DataTransfer::GetPointer<S_oooo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oooo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oooo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfCSRecoverBegin(CSRecoverEndInfo ByRef) declare in SGC
bool w_vPS_oou1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oou1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oou1_* p0 = DataTransfer::GetPointer<S_oou1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oou1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oou1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Vector3
bool w_vPS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4_* p1, struct S_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Vector3
bool w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4_* p1, struct S_r4r4r4_* p2, struct S_r4r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void CalculateProjectionMatrixFromPhysicalProperties(UnityEngine.Matrix4x4 ByRef, Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, GateFitParameters) declare in UnityEngine.Camera
bool w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 7) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
            // LuaValToCSVal valuetype with default
    S_i4r4_ p6 = OptionalParameter<S_i4r4_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef void (*FuncToCall)(struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1, float p2, struct S_r4r4_ p3, struct S_r4r4_ p4, float p5, float p6, struct S_i4r4_ p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfEventTriggerLogInfo(EventTriggerLogInfo ByRef) declare in SGC
bool w_vPS_si8ou1oss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_si8ou1oss_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_si8ou1oss_* p0 = DataTransfer::GetPointer<S_si8ou1oss_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_si8ou1oss_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_si8ou1oss_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8ShowBubble(Project8ShowBubbleParams ByRef) declare in SGC
bool w_vPS_so_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_so_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_so_* p0 = DataTransfer::GetPointer<S_so_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_so_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_so_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef) declare in UnityEngine.Shader
bool w_vPS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_su4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean) declare in UnityEngine.Shader
bool w_vPS_su4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(struct S_su4_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void InitUnityAppData(UnityAppData ByRef) declare in SGW
bool w_vPS_u1S_u8_S_u8_S_u8_u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u1S_u8_S_u8_S_u8_u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1S_u8_S_u8_S_u8_u4u1_* p0 = DataTransfer::GetPointer<S_u1S_u8_S_u8_S_u8_u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1S_u8_S_u8_S_u8_u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u1S_u8_S_u8_S_u8_u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8RefreshAllAuctionItems(Project8AllAuctionItems ByRef) declare in SGC
bool w_vPS_u1o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u1o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1o_* p0 = DataTransfer::GetPointer<S_u1o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u1o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ActivateFormationRecord(FormationRecordInitParam ByRef) declare in SGW
bool w_vPS_u1u8i4su1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u1u8i4su1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u8i4su1_* p0 = DataTransfer::GetPointer<S_u1u8i4su1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u8i4su1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u1u8i4su1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfLoadUnityObjSetTransform(LoadUnityObject ByRef) declare in SGC
bool w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__* p0 = DataTransfer::GetPointer<S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfCreateUnityObj(CreateUnityObject ByRef) declare in SGC
bool w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_* p0 = DataTransfer::GetPointer<S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerRecover(PlayerRecoverInfo ByRef) declare in SGC
bool w_vPS_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__* p0 = DataTransfer::GetPointer<S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfStopAnimClip(ActorAnimClipStopParam ByRef) declare in SGC
bool w_vPS_u4S_u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8__* p0 = DataTransfer::GetPointer<S_u4S_u8__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayAnimClip(ActorAnimClipPlayParam ByRef) declare in SGC
bool w_vPS_u4S_u8_r4i4u1u1r4u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8_r4i4u1u1r4u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8_r4i4u1u1r4u1u1u1_* p0 = DataTransfer::GetPointer<S_u4S_u8_r4i4u1u1r4u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8_r4i4u1u1r4u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8_r4i4u1u1r4u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfLoadFloatTip(LordFloatTipData ByRef) declare in SGC
bool w_vPS_u4S_u8_u4u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8_u4u4u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8_u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4S_u8_u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8_u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8_u4u4u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerOverheadUseEnergy(PlayerOverheadUseEnergyInfo ByRef) declare in SGC
bool w_vPS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4_* p0 = DataTransfer::GetPointer<S_u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerPopulationChange(PlayerPopulationChangeInfo ByRef) declare in SGC
bool w_vPS_u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4i4_* p0 = DataTransfer::GetPointer<S_u4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerGoldChange(PlayerGoldChangeInfo ByRef) declare in SGC
bool w_vPS_u4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4i4i4_* p0 = DataTransfer::GetPointer<S_u4i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfOSHPlayerEnergyChange(OSHPlayerEnergyChangeInfo ByRef) declare in SGC
bool w_vPS_u4i4u1u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4u1u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4u1u4_* p0 = DataTransfer::GetPointer<S_u4i4u1u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4u1u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4u1u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfCreatePlayerInstance(PlayerInstanceInfo ByRef) declare in SGC
bool w_vPS_u4i4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4u4u4_* p0 = DataTransfer::GetPointer<S_u4i4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void DestroyDynamicComponent(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_vPS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8BossHpAwardAllItems(Project8BossAwardResult ByRef) declare in SGC
bool w_vPS_u4oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4oo_* p0 = DataTransfer::GetPointer<S_u4oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4oo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8AuctionUpdateJoinerList(Project8AuctionJoinerList ByRef) declare in SGC
bool w_vPS_u4ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4ooo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4ooo_* p0 = DataTransfer::GetPointer<S_u4ooo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4ooo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4ooo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8NSelectInfos(Project8NSelectOneInfos ByRef, Boolean) declare in SGC
bool w_vPS_u4u1o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u1o_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u1o_* p0 = DataTransfer::GetPointer<S_u4u1o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u1o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(struct S_u4u1o_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAGEPlayLordAudioProcess(PlayLordAudioParam ByRef) declare in SGC
bool w_vPS_u4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u1u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u1u1u1u1_* p0 = DataTransfer::GetPointer<S_u4u1u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u1u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u1u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAgePlayAnimTick(ActorAnimTickPlayParam ByRef) declare in SGC
bool w_vPS_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_* p0 = DataTransfer::GetPointer<S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfShieldChange(stShowActorShieldData ByRef) declare in SGC
bool w_vPS_u4u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4_* p0 = DataTransfer::GetPointer<S_u4u4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorDamage(stShowActorDamageData ByRef) declare in SGC
bool w_vPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorLevelGradientChange(ActorLevelGradientData ByRef) declare in SGC
bool w_vPS_u4u4i4i4i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4i4i4i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4i4i4i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfInitCollision(InitDebugCollision ByRef) declare in SGC
bool w_vPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p0 = DataTransfer::GetPointer<S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerExtraPublicInfo(stPlayerExtraPublicInfo ByRef) declare in SGC
bool w_vPS_u4u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1_* p0 = DataTransfer::GetPointer<S_u4u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEquipGroupInfoChanged(ActorEquipGroupInfo ByRef) declare in SGC
bool w_vPS_u4u4u1u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u1u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1u4_* p0 = DataTransfer::GetPointer<S_u4u4u1u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u1u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void MoveBeamDurationEnter(MoveBeamDurationInfo ByRef) declare in SGC
bool w_vPS_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_* p0 = DataTransfer::GetPointer<S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAgePlayAnimDurEnter(ActorAnimDuraPlayParam ByRef) declare in SGC
bool w_vPS_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1_* p0 = DataTransfer::GetPointer<S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfSendInteractLikeBoo(ChatLikeBooInfo ByRef) declare in SGC
bool w_vPS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfSendInteractTips(ChatInteractInfo ByRef) declare in SGC
bool w_vPS_u4u4u4i4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4i4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4i4u4o_* p0 = DataTransfer::GetPointer<S_u4u4u4i4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4i4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4i4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfHuanHuaLingPaiRandom(HuanHuaLingPaiRandomData ByRef) declare in SGC
bool w_vPS_u4u4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4o_* p0 = DataTransfer::GetPointer<S_u4u4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfUseLordEmoji(LordEmojiInfo ByRef) declare in SGC
bool w_vPS_u4u4u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorDead(ActorDeadInfo ByRef) declare in SGC
bool w_vPS_u4u4u4u4u1i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4u4u1i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u1i4u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u1i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u1i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4u4u1i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfBattleBroadcast(Project8BattleBroadcast ByRef) declare in SGC
bool w_vPS_u4u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void CalcResolutionAdaptTotalPixels(Int32 ByRef, Int32 ByRef) declare in SystemSetting
bool w_vPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(int32_t* p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Add(Assets.Scripts.GameLogic.SceneTriggerType ByRef, Assets.Scripts.GameLogic.SceneTriggerType[]) declare in Assets.Scripts.GameLogic.SceneInteractcs
bool w_vPi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ResetInactiveRenderChildren(System.Collections.Generic.List`1[UnityEngine.GameObject] ByRef) declare in Utility
bool w_vPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     // LuaValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ret
    Il2CppObject** p0 = &up0;
        
    typedef void (*FuncToCall)(Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = CSRefToLuaValue(apis, env, TIp0, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8EquipChangedAll(Byte*) declare in SGW
bool w_vPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;

    typedef void (*FuncToCall)(uint8_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ReportFrameFPSData(Byte*, Int32) declare in SGC
bool w_vPu1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(uint8_t* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void AddStringFragment(Byte*, UInt32) declare in SGW
bool w_vPu1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(uint8_t* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void AK_SPEAKER_SETUP_FIX_LEFT_TO_CENTER(UInt32 ByRef) declare in AkSoundEngine
bool w_vPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    uint32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;

    typedef void (*FuncToCall)(uint32_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = converter::Converter<uint32_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnCameraLockOffsetChange(VInt3) declare in SGW
bool w_vS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
        
    typedef void (*FuncToCall)(struct S_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void set_compositionCursorPos(UnityEngine.Vector2) declare in UnityEngine.Input
bool w_vS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void Lobby_Move(UnityEngine.Vector3) declare in SGW
bool w_vS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void drawBezierPath(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Transform) declare in LeanTween
bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_Dr4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_Dr4Do");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5);
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void RGBToHSV(UnityEngine.Color, Single ByRef, Single ByRef, Single ByRef) declare in UnityEngine.Color
bool w_vS_r4r4r4r4_Pr4Pr4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_Pr4Pr4Pr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
     
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, float* p2, float* p3, float* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ChangeUICameraMask(Assets.Scripts.GameSystem.CullData) declare in LuaCallCSharpInteraction
bool w_vS_u4bbbi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u4bbbi4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4bbbi4_* pp0 = DataTransfer::GetPointer<S_u4bbbi4_>(apis, env, _sv0);
    S_u4bbbi4_ p0 = pp0 ? *pp0 : S_u4bbbi4_ {};
        
    typedef void (*FuncToCall)(struct S_u4bbbi4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void NtfAGEProject8ModifyBoxHelperOpenTips(StringId) declare in SGC
bool w_vS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u8_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef void (*FuncToCall)(struct S_u8_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void OnBluePrintBroadCastEventRouterEvent(StringId, BroadCastEventRouterParam ByRef) declare in SGC
bool w_vS_u8_PS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u8_PS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
             
    // LuaValToCSVal Pstruct
    S_o_* p1 = DataTransfer::GetPointer<S_o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(struct S_u8_ p1, struct S_o_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayLevelSound(StringId, UInt32) declare in SGC
bool w_vS_u8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u8_u4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(struct S_u8_ p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void set_runInBackground(Boolean) declare in UnityEngine.Application
bool w_vb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void NtfAgeDebugInfo(Boolean, StringId) declare in SGC
bool w_vbS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbS_u8_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef void (*FuncToCall)(bool p1, struct S_u8_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void ForceFightOver(Boolean, Boolean, Boolean) declare in SGW
bool w_vbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbbb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetAnimCullTotalSwitch(Boolean, Int32) declare in UnityEngine.Animation
bool w_vbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void GetPooledObjectMemInfo(Boolean, MemoryObjectInfoTypeDelegate) declare in SGWRequest
bool w_vbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbo");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void NtfRecordData(Boolean, UInt64, Int32) declare in SGC
bool w_vbu8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbu8i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(bool p1, uint64_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Quit(Int32) declare in UnityEngine.Application
bool w_vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void GetCSharpPreLoadInfo(Int32, Boolean) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Db");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void BeginFlow(Int32, Int32, System.String) declare in Assets.Plugins.Common.CNS.CNSService
bool w_vi4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Di4Ds");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostNetworkLatency(Int32, System.String, System.String) declare in GCloud.GPM.GPMAgent
bool w_vi4DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4DsDs");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void dispatchEvent(Int32, System.Object) declare in LeanTween
bool w_vi4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4O");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void NtfProject8UpgradeNumOffsetChange(Int32, Project8UpgradeNumOffset ByRef) declare in SGC
bool w_vi4PS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4PS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_oo_* p1 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oo_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(int32_t p1, struct S_oo_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void CalcResolutionAdaptTotalPixels(RenderResolutionDefine, Int32 ByRef, Int32 ByRef) declare in SystemSetting
bool w_vi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Pi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(int32_t p1, int32_t* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetGlobalVector(Int32, UnityEngine.Vector4) declare in UnityEngine.Shader
bool w_vi4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetGlobalMatrix(Int32, UnityEngine.Matrix4x4) declare in UnityEngine.Shader
bool w_vi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void cancel(Int32, Boolean) declare in LeanTween
bool w_vi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetStackTraceLogType(UnityEngine.LogType, UnityEngine.StackTraceLogType) declare in UnityEngine.Application
bool w_vi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetResolution(Int32, Int32, Boolean) declare in UnityEngine.Screen
bool w_vi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Collect(Int32, System.GCCollectionMode, Boolean, Boolean) declare in System.GC
bool w_vi4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4bb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetResolution(Int32, Int32, Boolean, Int32) declare in UnityEngine.Screen
bool w_vi4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4bi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void ReqJoinPasswordRoom(Int32, Int32, Int32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, UnityEngine.RefreshRate) declare in UnityEngine.Screen
bool w_vi4i4i4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4S_u4u4_");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv3);
    S_u4u4_ p3 = pp3 ? *pp3 : S_u4u4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, struct S_u4u4_ p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, Int32) declare in UnityEngine.Screen
bool w_vi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void NtfUpdateRoundState(Int32, Int32, Int32, Int32, Int32) declare in SGC
bool w_vi4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void NtfSpecialRelationTipsMechanism(ResData.RES_RELATION_ID, Int32, Int32, Int32, Int32, Boolean) declare in SGC
bool w_vi4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void GetCardSourceInfoArray(Int32, Int32, CardSourceInfoArrayTypeDelegate) declare in SGWRequest
bool w_vi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4o");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void CollectTouchData(Int32, Int32, System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32]) declare in com.tencent.mna.MNA
bool w_vi4i4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4oooo");
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SyncCoreThreadAffinity(Int32, Int64) declare in SGC
bool w_vi4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void addListener(Int32, System.Action`1[LTEvent]) declare in LeanTween
bool w_vi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4o");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetGlobalTexture(Int32, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.Shader
bool w_vi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGlobalConstantBuffer(Int32, UnityEngine.ComputeBuffer, Int32, Int32) declare in UnityEngine.Shader
bool w_vi4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4i4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetGlobalFloat(Int32, Single) declare in UnityEngine.Shader
bool w_vi4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PostEvent(Int32, System.String) declare in GCloud.GPM.GPMAgent
bool w_vi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4s");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PrintLog(CSLogSeverity, System.String, System.Object[]) declare in CrashSightAgent
bool w_vi4sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sVO");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetNoticeRed(Int32, System.String, Boolean) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_vi4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sb");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void ReleaseData(Int32, System.String, Int32, com.pixui.NativeBuffer ByRef) declare in com.pixui.PxContext
bool w_vi4si4PS_pi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4si4PS_pi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_pi4_* p3 = DataTransfer::GetPointer<S_pi4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_pi4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, int32_t p3, struct S_pi4_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void LocalOutput(AkMonitorErrorCode, System.String, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_vi4si4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4si4u4o");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, int32_t p3, uint32_t p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void LuaDoLog(Type, System.String, System.String) declare in Assets.Plugins.Common.Log
bool w_vi4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4ss");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetUserName(Int32, System.String, System.String, System.String) declare in com.tencent.mna.MNA
bool w_vi4sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sss");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void ReportException(Int32, System.String, System.String, System.String, System.Collections.Generic.Dictionary`2[System.String,System.String]) declare in CrashSightAgent
bool w_vi4ssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4ssso");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void ReportException(Int32, System.String, System.String, System.String, System.Collections.Generic.Dictionary`2[System.String,System.String], Int32) declare in CrashSightAgent
bool w_vi4sssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sssoi4");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void PreLoadLordAge(Int32, LordAgePreLoadType, Int32, Int32) declare in Assets.Scripts.GameLogic.Project8PreLoadConfigService
bool w_vi4u1i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u1i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, uint8_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void RecordRoundTLog(OSProto.PVPRoundHUDOPType, UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vi4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void NtfAgeTriggerParticleLeave(Int32, UInt32, Boolean) declare in SGC
bool w_vi4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void ExecuteActionOnPlayingID(AkActionOnEventType, UInt32, Int32) declare in AkSoundEngine
bool w_vi4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void NtfChangeActorMesh(Int32, UInt32, Int32, Boolean, Boolean, Int32) declare in SGC
bool w_vi4u4i4bbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4i4bbi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, bool p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void ExecuteActionOnPlayingID(AkActionOnEventType, UInt32, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_vi4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void NtfAgeTriggerParticleEnter(Int32, UInt32, UInt32, AgeTriggerParticleInfo ByRef) declare in SGC
bool w_vi4u4u4PS_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4u4PS_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4_* p3 = DataTransfer::GetPointer<S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, struct S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EquipBackpackCmd(Assets.Scripts.GameLogic.EquipOpType, UInt32, UInt32, UInt32) declare in Assets.Scripts.GameLogic.EquipCmd
bool w_vi4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4u4u4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void NtfSpecialRelationTipsTeamOfStar(ResData.RES_RELATION_ID, UInt32, UInt32, UInt32, Boolean, UInt32) declare in SGC
bool w_vi4u4u4u4bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4u4u4bu4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, bool p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetDownloadProgress(Int32, UInt64, UInt64) declare in com.tencent.mna.MNA
bool w_vi4u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u8u8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(int32_t p1, uint64_t p2, uint64_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void GetSnakeTraceBufferByLua(Int32, UInt64, UInt64, System.String) declare in Assets.Scripts.Framework.SynchrReport
bool w_vi4u8u8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u8u8s");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(int32_t p1, uint64_t p2, uint64_t p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetCoreThreadAffinity(Int64) declare in SGW
bool w_vi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void SetAIBotThreadAffinity(Int64, Int64) declare in SGW
bool w_vi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi8i8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void QueryPreciseKartin(Int64, Int64, System.String) declare in com.tencent.mna.MNA
bool w_vi8i8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi8i8s");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(int64_t p1, int64_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetBuildTags(System.String[]) declare in UnityEngine.Application
bool w_vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vo");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void SetUITookitEventSystemOverride(UnityEngine.EventSystems.EventSystem, Boolean, Boolean) declare in UnityEngine.EventSystems.EventSystem
bool w_voDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voDbDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void KeepInScreen(UnityEngine.RectTransform, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetOptions(System.Type, System.Object) declare in com.pixui.PxMisc
bool w_voO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void serialize_array_FormationChessInfo(FormationChessInfo[], Byte* ByRef) declare in SGW
bool w_voPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         
    // LuaValToCSVal P not primitive
    uint8_t** p1 = nullptr;

    typedef void (*FuncToCall)(Il2CppObject* p1, uint8_t** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ActivateRenderers(UnityEngine.GameObject, System.Collections.Generic.List`1[UnityEngine.GameObject] ByRef, UnityEngine.Renderer[]) declare in Utility
bool w_voPoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voPoo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject** p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ChangeVecParameters(CMTweener, UnityEngine.Vector2, UnityEngine.Vector2) declare in LuaCallCSharpInteraction
bool w_voS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4_S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetIndicatorStraight(UnityEngine.LineRenderer, UnityEngine.Vector3, UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetIndicatorPos(UnityEngine.LineRenderer, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single, IndicatorShape) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voS_r4r4r4_S_r4r4r4_Dr4Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4_S_r4r4r4_Dr4Dr4Di4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, float p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetMatColor(UnityEngine.GameObject, UnityEngine.Color, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voS_r4r4r4r4_Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4r4_Ds");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
            // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetModelAlbedoColorAndMaskScale(UnityEngine.Transform, UnityEngine.Color, Single) declare in LuaCallCSharpInteraction
bool w_voS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void cancel(UnityEngine.GameObject, Boolean) declare in LeanTween
bool w_vob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vob");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetVisibleByLayer(UnityEngine.GameObject, Boolean, Boolean) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vobb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void cancel(LTRect, Int32) declare in LeanTween
bool w_voi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void cancel(UnityEngine.GameObject, Int32, Boolean) declare in LeanTween
bool w_voi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void GetOSOBattleInfo(Assets.Scripts.GameLogic.Project8PlayerInstance, Int32, ResData.OSOLevelType ByRef, Boolean ByRef) declare in Assets.Scripts.UI.InTheGame.OSOSettle.UIOSOSettle
bool w_voi4Pi4Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4Pi4Pb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
     
    // LuaValToCSVal P primitive
    bool up3 = false;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv3);
    bool* p3 = &up3;

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t* p3, bool* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<bool>::toScript(apis, env, *p3);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void FlipLayoutOnAxis(UnityEngine.RectTransform, Int32, Boolean, Boolean) declare in UnityEngine.RectTransformUtility
bool w_voi4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4bb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Reverse(System.Array, Int32, Int32) declare in System.Array
bool w_voi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetLayerRecursively(UnityEngine.GameObject, Int32, Int32, Boolean) declare in ExtGameObject
bool w_voi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Sort(System.Array, Int32, Int32, System.Collections.IComparer) declare in System.Array
bool w_voi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void addListener(UnityEngine.GameObject, Int32, System.Action`1[LTEvent]) declare in LeanTween
bool w_voi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Copy(System.Array, Int32, System.Array, Int32, Int32) declare in System.Array
bool w_voi4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4oi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void SetGameObjLayerRecursively(UnityEngine.GameObject, Int32, System.String) declare in ExtGameObject
bool w_voi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4s");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Copy(System.Array, Int64, System.Array, Int64, Int64) declare in System.Array
bool w_voi8oi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi8oi8i8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, int64_t p2, Il2CppObject* p3, int64_t p4, int64_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void Sort(System.Array, System.Collections.IComparer) declare in System.Array
bool w_voo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Execute(System.Collections.Generic.List`1[UIEventDelegate], LuaUIPointerEventData, Int32) declare in UIEventDelegate
bool w_vooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
         // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void KeepNodeScale(UnityEngine.RectTransform, UnityEngine.RectTransform, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vooDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
         // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Copy(System.Array, System.Array, Int32) declare in System.Array
bool w_vooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Sort(System.Array, System.Array, Int32, Int32) declare in System.Array
bool w_vooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Sort(System.Array, System.Array, Int32, Int32, System.Collections.IComparer) declare in System.Array
bool w_vooi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void Copy(System.Array, System.Array, Int64) declare in System.Array
bool w_vooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Sort(System.Array, System.Array, System.Collections.IComparer) declare in System.Array
bool w_vooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void NtfPlayerHeadUrl(UInt64[], System.String[], Int32[], Int32[], UInt64[], UInt64[], UInt64[]) declare in LuaCallCSharpInteraction
bool w_vooooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooooooo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[], System.Reflection.AssemblyName, System.Reflection.Emit.CustomAttributeBuilder[], System.String) declare in System.Text.RegularExpressions.Regex
bool w_vooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooos");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void AutoComputeHeight(UnityEngine.Component, UnityEngine.UI.ScrollRect, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voor4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void GetTotalMtl(UnityEngine.Transform, System.Collections.Generic.List`1[UnityEngine.Renderer], System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voos");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Destroy(UnityEngine.Object, Single) declare in UnityEngine.Object
bool w_vor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void GetImageContentSize(Assets.Scripts.GameNotice.ImageContent, Single, UnityEngine.Vector2 ByRef) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_vor4PS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4PS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
        
    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, struct S_r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GetHorizonSpace(UnityEngine.RectTransform, Single, Single ByRef, Single ByRef) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vor4Pr4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4Pr4Pr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
     
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, float* p3, float* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetRendererFloatStandState(UnityEngine.GameObject, Single, Single, Single) declare in Utility
bool w_vor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4r4r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void CreateGameObjectPath(UnityEngine.Transform, System.String) declare in ExtTransform
bool w_vos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vos");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetRendererFloatPropertyState(UnityEngine.GameObject, System.String, Single) declare in Utility
bool w_vosr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vosr4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void AddEquipmentFromSceneAward(Assets.Scripts.GameLogic.Project8SceneAwardBoxItem, UInt32) declare in Assets.Scripts.GameLogic.EquipCmd
bool w_vou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vou4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PreGameObjectAPICall(UnityEngine.GameObject, UInt64) declare in AkSoundEngine
bool w_vou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vou8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppObject* p1, uint64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void CopyMemory(IntPtr, IntPtr, Int32) declare in SGamePInvoke
bool w_vppi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vppi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void set_fixedDeltaTime(Single) declare in UnityEngine.Time
bool w_vr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(float p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void ChangeSpeed(Single, Assets.Scripts.GameLogic.BattleTimeScaleType) declare in Assets.Scripts.GameLogic.ReplayUtil
bool w_vr4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vr4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PostCoordinates(Single, Single, Single, Single, Single, Single) declare in GCloud.GPM.GPMAgent
bool w_vr4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vr4r4r4r4r4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, float p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void ExternalEval(System.String) declare in UnityEngine.Application
bool w_vs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vs");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef void (*FuncToCall)(Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void PreloadSceneVFX(System.String, SceneLevelDefine) declare in Preload.Preloader
bool w_vsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SendLuaEvent(System.String, XLua.LuaTable) declare in Utility
bool w_vsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void ShowSystemTips(System.String, System.String, Int32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsDsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDsDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void CheckUniversalLink(System.String, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDsDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Login(System.String, System.String, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vsDsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDsDsDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void serialize_string(System.String, Byte* ByRef) declare in SGW
bool w_vsPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); 
    // LuaValToCSVal P not primitive
    uint8_t** p1 = nullptr;

    typedef void (*FuncToCall)(Il2CppString* p1, uint8_t** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void StringToUTF8Bytes(System.String, Byte[] ByRef) declare in StringHelper
bool w_vsPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetGlobalVector(System.String, UnityEngine.Vector4) declare in UnityEngine.Shader
bool w_vsS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetGlobalMatrix(System.String, UnityEngine.Matrix4x4) declare in UnityEngine.Shader
bool w_vsS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetCreationTime(System.String, System.DateTime) declare in System.IO.File
bool w_vsS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_u8_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_u8_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SendEventRouter(System.String, Bytes) declare in SGC
bool w_vsS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_u8u8_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_u8u8_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void ExternalCall(System.String, System.Object[]) declare in UnityEngine.Application
bool w_vsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsVO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Delete(System.String, Boolean) declare in System.IO.Directory
bool w_vsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetVisible(System.String, Boolean, XLua.LuaTable) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32) declare in com.tencent.mna.MNA
bool w_vsbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32, Boolean) declare in com.tencent.mna.MNA
bool w_vsbi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32, Boolean, Boolean, ReportChannelType) declare in com.tencent.mna.MNA
bool w_vsbi4bbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4bbi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, bool p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32, Boolean, Boolean, ReportChannelType, System.String) declare in com.tencent.mna.MNA
bool w_vsbi4bbi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4bbi4s");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
            // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, bool p4, bool p5, int32_t p6, Il2CppString* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void CaptureScreenshot(System.String, Int32) declare in UnityEngine.Application
bool w_vsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PingGateway(System.String, Int32, Int32, Int32, Boolean) declare in com.tencent.mna.MNA
bool w_vsi4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostStepEvent(System.String, Int32, Int32, Int32, System.String, System.String, Boolean, Boolean) declare in GCloud.GPM.GPMAgent
bool w_vsi4i4i4ssbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4i4ssbb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
            // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);    // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);        
    // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
        
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, Il2CppString* p5, Il2CppString* p6, bool p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void StartSpeed(System.String, Int32, Int32, System.String, Int32, Int32, Int32, System.String, Int32) declare in com.tencent.mna.MNA
bool w_vsi4i4si4i4i4sDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4si4i4i4sDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (true) {
        if (lua_args_len < 8 || lua_args_len > 9) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7))
            return false;
        if (lua_args_len > 8 && !converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
            // LuaValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7); // LuaValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 8);
            
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, int32_t p6, int32_t p7, Il2CppString* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void StartSpeed(System.String, Int32, Int32, System.String, Int32, Int32, System.String, Int32) declare in com.tencent.mna.MNA
bool w_vsi4i4si4i4sDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4si4i4sDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (true) {
        if (lua_args_len < 7 || lua_args_len > 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;
        if (lua_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
            // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6); // LuaValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 7);
            
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, int32_t p6, Il2CppString* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void EndSpeed(System.String, Int32, System.String) declare in com.tencent.mna.MNA
bool w_vsi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4s");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGameIpWithLocalIp(System.String, Int32, System.String, Int32) declare in com.tencent.mna.MNA
bool w_vsi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4si4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetLong(System.String, Int64) declare in PlayerPrefsX
bool w_vsi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppString* p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void LoadCDNTextureAsync(System.String, Assets.Scripts.Framework.AssetService.IAssetLoadCallback) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vso");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void LogCustomException(System.String, System.Exception, System.String) declare in Assets.Plugins.Common.Log
bool w_vsoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGlobalTexture(System.String, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.Shader
bool w_vsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGlobalConstantBuffer(System.String, UnityEngine.ComputeBuffer, Int32, Int32) declare in UnityEngine.Shader
bool w_vsoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void WriteAllLines(System.String, System.String[], System.Text.Encoding) declare in System.IO.File
bool w_vsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetFloat(System.String, Single) declare in UnityEngine.PlayerPrefs
bool w_vsr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Copy(System.String, System.String) declare in System.IO.File
bool w_vss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vss");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SendUpdateUI(System.String, System.String, XLua.LuaTable) declare in Utility
bool w_vssDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void CanBind(System.String, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vssDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void DebugLog(System.String, System.String, System.Object[]) declare in CrashSightAgent
bool w_vssVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssVO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Copy(System.String, System.String, Boolean) declare in System.IO.File
bool w_vssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostValueI(System.String, System.String, Int32, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssi4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void PostValueI(System.String, System.String, Int32, Int32, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssi4i4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
         // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void GetIpGroupDelays(System.String, System.String, Int32, Int32, Int32) declare in com.tencent.mna.MNA
bool w_vssi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostValueI(System.String, System.String, Int32, Int32, Int32, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssi4i4i4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4i4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
         // LuaValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void Ping(System.String, System.String, Int32, Int32, Int32, Boolean) declare in com.tencent.mna.MNA
bool w_vssi4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void WriteAllText(System.String, System.String, System.Text.Encoding) declare in System.IO.File
bool w_vsso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsso");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void DecompressFile(System.String, System.String, Byte[], UInt32, UInt32) declare in CFileManager
bool w_vssou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssou4u4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, uint32_t p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostValueF(System.String, System.String, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void PostValueF(System.String, System.String, Single, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4r4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4r4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
         // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostValueF(System.String, System.String, Single, Single, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4r4r4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4r4r4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
         // LuaValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, float p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void PostValueCoordinate(System.String, System.String, Single, Single, Single, Single, Single, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4r4r4r4r4r4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4r4r4r4r4r4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (true) {
        if (lua_args_len < 8 || lua_args_len > 9) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7))
            return false;
        if (lua_args_len > 8 && !converter::Converter<uint32_t>::accept(apis, env, _sv8))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
         // LuaValToCSVal primitive with default
    uint32_t p8 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 8);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, float p5, float p6, float p7, float p8, uint32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void Replace(System.String, System.String, System.String) declare in System.IO.File
bool w_vsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsss");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostValueS(System.String, System.String, System.String, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vsssDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsssDu4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2); // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Replace(System.String, System.String, System.String, Boolean) declare in System.IO.File
bool w_vsssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsssb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void ConfigDefault(System.String, System.String, System.String, Int64) declare in CrashSightAgent
bool w_vsssi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsssi8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void EncryptFile(System.String, System.String, System.String, System.String, Byte[], UInt32) declare in CFileManager
bool w_vssssou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssssou4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void RecordRoundTLog(System.String, UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsu4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void RecordRoundTLog(System.String, UInt32, UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsu4u4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(Il2CppString* p1, uint32_t p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Init() declare in DataService
bool w_vt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vt");

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void (*FuncToCall)(void*,const void* method);
    ((FuncToCall)methodPointer)(self,  method);
    return true;
}
// Void ResetBattleGridAll(System.Object) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Create(System.Object, UIPrefabBase, UnityEngine.Transform, System.Object, Boolean, System.Nullable`1[UnityEngine.Vector3]) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtDODoDoDODbDN_bS_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDODoDoDODbDN_bS_r4r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 6) 
            return false;

        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3); // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal valuetype with default
    N_bS_r4r4r4__ p5 = OptionalParameter<N_bS_r4r4r4__>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, struct N_bS_r4r4r4__ p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void LoadAllNested(Boolean) declare in UIPrefabBase
bool w_vtDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ForceMeshUpdate(Boolean, Boolean) declare in TMPro.TextMeshPro
bool w_vtDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDbDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void FastPlay(Int32) declare in NOAH.VFX.VFXEffectPlayer
bool w_vtDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void .ctor(Int32, Int32) declare in Timi.TimiMenuIndex
bool w_vtDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDi4Di4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Reset(UnityEngine.Transform, UnityEngine.Transform) declare in ExtTransform
bool w_vtDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDo");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Play(OnCompleted, System.Action`1[CMTweener], Int32, Single, Boolean) declare in CMTweener
bool w_vtDoDoDi4Dr4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDoDoDi4Dr4Db");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 5) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, int32_t p3, float p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void EnableClickLock(Single) declare in Timi.TimiButton
bool w_vtDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void InitCameraOffsetParam(Single, Single, Single, Single) declare in Moba_Camera
bool w_vtDr4Dr4Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDr4Dr4Dr4Dr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 4) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
 // LuaValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,float p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void EndSpeed(System.String) declare in GSDKsys
bool w_vtDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDs");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);
    typedef void (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Play(System.String, Boolean, Single) declare in SceneTagComponent
bool w_vtDsDbDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDsDbDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,Il2CppString* p1, bool p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void FirePlugin(System.String, Int32) declare in BoxSDK.BoxSDKService
bool w_vtDsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDsDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayReverse(System.String, Single) declare in SceneTagComponent
bool w_vtDsDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDsDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppString* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayEnterAuctionBroadcast(UInt32) declare in Assets.Scripts.GameLogic.Project8BattleAudio
bool w_vtDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDu4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    uint32_t p0 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ChangeMsgParent(System.Object) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetSelectByValue(System.Object, Boolean) declare in Timi.TimiDropDown
bool w_vtODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtODb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void DeleteTarget(System.Object, System.Object) declare in EventProxy
bool w_vtOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, System.Object, System.Object[]) declare in System.Reflection.PropertyInfo
bool w_vtOOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOOo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetValue(System.Object, Int32[]) declare in System.Array
bool w_vtOVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOVi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;
        if(lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int64[]) declare in System.Array
bool w_vtOVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOVi8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;
        if(lua_args_len > 1 && !converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int64_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int32) declare in System.Array
bool w_vtOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int32, Int32) declare in System.Array
bool w_vtOi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetValue(System.Object, Int32, Int32, Int32) declare in System.Array
bool w_vtOi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetValue(System.Object, Int64) declare in System.Array
bool w_vtOi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int64, Int64) declare in System.Array
bool w_vtOi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi8i8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetValue(System.Object, Int64, Int64, Int64) declare in System.Array
bool w_vtOi8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi8i8i8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int64_t p2, int64_t p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Yield(System.Object, System.Action) declare in Assets.Scripts.Framework.Lua.CoroutineRunner
bool w_vtOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ListenKeyDown(System.Object, System.Collections.Generic.HashSet`1[UnityEngine.KeyCode], KeyboardAction) declare in Assets.Scripts.Framework.InputModule
bool w_vtOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOoo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void AsyncCreate(System.Object, UIPrefabBase, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UIPrefabBaseClass], System.Nullable`1[UnityEngine.Vector3]) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtOooOboDN_bS_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOooOboDN_bS_r4r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (lua_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
            // LuaValToCSVal valuetype with default
    N_bS_r4r4r4__ p6 = OptionalParameter<N_bS_r4r4r4__>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, Il2CppObject* p6, struct N_bS_r4r4r4__ p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void deserialize(Byte* ByRef) declare in SGW+Project8RoundStatisticInfo
bool w_vtPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
 
    // LuaValToCSVal P not primitive
    uint8_t** p0 = nullptr;

    typedef void (*FuncToCall)(void*,uint8_t** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GetTransfrom(Project8FreeCameraParam ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, UnityEngine.Vector3 ByRef) declare in Assets.Scripts.GameLogic.Project8FreeCamera
bool w_vtPS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_r4r4r4_PS_r4r4r4r4_PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p0 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p1, struct S_r4r4r4_* p2, struct S_r4r4r4r4_* p3, struct S_r4r4r4_* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }
                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EnableKeyword(UnityEngine.Rendering.LocalKeyword ByRef) declare in UnityEngine.Material
bool w_vtPS_S_p_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_p_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_p_su4_* p0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_p_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_p_su4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetKeyword(UnityEngine.Rendering.LocalKeyword ByRef, Boolean) declare in UnityEngine.Material
bool w_vtPS_S_p_su4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_p_su4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_p_su4_* p0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_p_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_S_p_su4_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayFadeIn(RectRtRecord ByRef, CMTweener, Single) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_DoDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_DoDr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p1, Il2CppObject* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayLerpFrom(RectRtRecord ByRef, System.Action`1[CMTweener], Single, CMTweener, Boolean) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_or4DoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_or4DoDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 5) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
            // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3); // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p1, Il2CppObject* p2, float p3, Il2CppObject* p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorBuffChange(Assets.Scripts.GameLogic.BuffChangeEventParam ByRef) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtPS_S_u4o_i4S_u4o__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4o_i4S_u4o__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4o_i4S_u4o__* p0 = DataTransfer::GetPointer<S_S_u4o_i4S_u4o__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4o_i4S_u4o__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_u4o_i4S_u4o__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnPlayerSkillTimer(Assets.Scripts.GameLogic.SkillTimerEvtParam ByRef) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtPS_S_u4o_u4i4u8i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4o_u4i4u8i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4o_u4i4u8i4i4i4_* p0 = DataTransfer::GetPointer<S_S_u4o_u4i4u8i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4o_u4i4u8i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_u4o_u4i4u8i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEnterView(ActorRecoverData ByRef) declare in Assets.Scripts.GameLogic.ActorManager
bool w_vtPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p0 = DataTransfer::GetPointer<S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Min(VInt2 ByRef) declare in VInt2
bool w_vtPS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4_* p0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnPlayerCampSwitch(Assets.Scripts.GameLogic.GameCommonEventParam ByRef) declare in Assets.Scripts.GameLogic.ActorManager
bool w_vtPS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetCameraCircleLerpParam(VInt3 ByRef, VInt3 ByRef, VInt3 ByRef, Int32, Int32, Int32, Int32, Int32, Int32) declare in Moba_Camera
bool w_vtPS_i4i4i4_PS_i4i4i4_PS_i4i4i4_i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4i4_PS_i4i4i4_PS_i4i4i4_i4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4_* p1, struct S_i4i4i4_* p2, struct S_i4i4i4_* p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnPlayerRandomHp(PlayerRandomHpData ByRef) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtPS_i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void RefreshCounter(SkillCounterChange ByRef) declare in Assets.Scripts.GameLogic.BuffLinkerComponent
bool w_vtPS_i4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4u4_* p0 = DataTransfer::GetPointer<S_i4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetAllPlayersTeamId(AllPlayersTeamIdInfo ByRef) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_vtPS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_o_* p0 = DataTransfer::GetPointer<S_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetRoundInfo(Project8RoundStatisticInfo ByRef) declare in Assets.Scripts.GameSystem.RoundStatisticData
bool w_vtPS_oi4i4i4u4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_oi4i4i4u4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oi4i4i4u4u4o_* p0 = DataTransfer::GetPointer<S_oi4i4i4u4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oi4i4i4u4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_oi4i4i4u4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEquipGridsChangeAll(stAllEquipInfo ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_vtPS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oo_* p0 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_oo_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void UpdateCameraMovement(UnityEngine.Vector2 ByRef) declare in CameraSystem
bool w_vtPS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4_* p0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetStartLocation(UnityEngine.Vector3 ByRef) declare in Moba_Camera
bool w_vtPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Teleport(UnityEngine.Vector3 ByRef, VInt3 ByRef, UnityEngine.Quaternion ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_r4r4r4_PS_i4i4i4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4r4_PS_i4i4i4_PS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_* p1, struct S_i4i4i4_* p2, struct S_r4r4r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GetPositionAndRotation(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef) declare in UnityEngine.Transform
bool w_vtPS_r4r4r4_PS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4r4_PS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_* p1, struct S_r4r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ToAxisAngle(UnityEngine.Vector3 ByRef, Single ByRef) declare in UnityEngine.Quaternion
bool w_vtPS_r4r4r4_Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4r4_Pr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_* p1, float* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtPS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_su4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtPS_su4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_su4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_su4_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetGoldInfo(stGoldDetailInfo ByRef) declare in Assets.Scripts.GameSystem.PlayerStatisticData
bool w_vtPS_u1u1u1u1u1u1ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u1u1u1u1u1u1ooo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u1u1u1u1u1ooo_* p0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1ooo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u1u1u1u1u1ooo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1ooo_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEquipGridChange(stEquipChangeInfo ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_vtPS_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__* p0 = DataTransfer::GetPointer<S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void AddBuff(BuffChangeParam ByRef) declare in Assets.Scripts.GameLogic.BuffLinkerComponent
bool w_vtPS_u1u4u4i4i4i4u4u4u1u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u1u4u4i4i4i4u4u4u1u4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u4u4i4i4i4u4u4u1u4i4_* p0 = DataTransfer::GetPointer<S_u1u4u4i4i4i4u4u4u1u4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u4u4i4i4i4u4u4u1u4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u1u4u4i4i4i4u4u4u1u4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void UpdatePosition(DisplayInfoData ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p0 = DataTransfer::GetPointer<S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void RefreshAllActorPositionByMovementDataCache(DisplayInfoData*, UInt32) declare in Assets.Scripts.GameLogic.ActorManager
bool w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p0 = DataTransfer::GetPointer<S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnNewInstance(PlayerInstanceInfo ByRef) declare in Assets.Scripts.GameLogic.Project8Logic
bool w_vtPS_u4i4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4i4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4u4u4_* p0 = DataTransfer::GetPointer<S_u4i4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4i4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnEquipRecommendRet(EquipRecommendRet ByRef) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_vtPS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef, Assets.Scripts.GameLogic.BuffChangeType, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BuffLinker]) declare in Assets.Scripts.GameLogic.BuffChangeEventParam
bool w_vtPS_u4o_i4S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4o_i4S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_u4o_* pp2 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv2);
    S_u4o_ p2 = pp2 ? *pp2 : S_u4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4o_* p1, int32_t p2, struct S_u4o_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetPlayerTeamId(PlayerTeamIdInfo ByRef) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_vtPS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4_* p0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorShieldChange(stShowActorShieldData ByRef) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vtPS_u4u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4_* p0 = DataTransfer::GetPointer<S_u4u4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorDamage(stShowActorDamageData ByRef) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vtPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorLevelGradientChange(ActorLevelGradientData ByRef) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vtPS_u4u4i4i4i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4i4i4i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4i4i4i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void CreateDebugCollision(InitDebugCollision ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p0 = DataTransfer::GetPointer<S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetEquipGroupInfo(ActorEquipGroupInfo ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_vtPS_u4u4u1u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u1u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1u4_* p0 = DataTransfer::GetPointer<S_u4u4u1u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u1u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NotifyHuanHuaLingPaiData(HuanHuaLingPaiRandomData ByRef) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_vtPS_u4u4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4o_* p0 = DataTransfer::GetPointer<S_u4u4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetMetaData(SpawnActorData ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnEquipItemChanged(stEquipItem ByRef) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_vtPS_u4u4u4u4u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void UpdateSkillContext(Project8CastLordSkillContext ByRef, UInt32) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_vtPS_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void DumpCommonMemoryStatCb(CommonMemoryStat ByRef, UInt32) declare in Assets.Scripts.GameSystem.LogicComponentPerformance
bool w_vtPS_u4u4u4u4u4u4u4u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u4u4u4u4_u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u4u4u4u4_* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(Char*) declare in System.String
bool w_vtPc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    Il2CppChar up0 = 0x0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;

    typedef void (*FuncToCall)(void*,Il2CppChar* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = converter::Converter<Il2CppChar>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(Char*, Int32, Int32) declare in System.String
bool w_vtPci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPci4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    Il2CppChar up0 = 0x0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,Il2CppChar* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int ret0 = converter::Converter<Il2CppChar>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(SByte*) declare in System.String
bool w_vtPi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;

    typedef void (*FuncToCall)(void*,int8_t* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(SByte*, Int32, Int32) declare in System.String
bool w_vtPi1i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi1i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int8_t* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(SByte*, Int32, Int32, System.Text.Encoding) declare in System.String
bool w_vtPi1i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi1i4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int8_t* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void FlipCoord(Int32 ByRef, Int32 ByRef) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(void*,int32_t* p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void InitLevelContext(Assets.Scripts.GameLogic.CLevelContext ByRef) declare in Assets.Scripts.GameLogic.BattleLogic
bool w_vtPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     // LuaValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ret
    Il2CppObject** p0 = &up0;
        
    typedef void (*FuncToCall)(void*,Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = CSRefToLuaValue(apis, env, TIp0, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ToAngleAxis(Single ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Quaternion
bool w_vtPr4PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr4PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    float up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(void*,float* p1, struct S_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int ret0 = converter::Converter<float>::toScript(apis, env, *p0);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Tween(Single ByRef, Single, Project8FreeCameraParam ByRef, Project8FreeCameraParam ByRef, Project8FreeCameraParam ByRef) declare in Assets.Scripts.GameLogic.Project8FreeCamera
bool w_vtPr4r4PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr4r4PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
     
    // LuaValToCSVal P primitive
    float up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p2 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
             
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p3 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
             
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p4 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
        
    typedef void (*FuncToCall)(void*,float* p1, float p2, struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p3, struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p4, struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int ret0 = converter::Converter<float>::toScript(apis, env, *p0);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }
                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }
                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetPositions(Unity.Collections.NativeSlice`1[UnityEngine.Vector3]) declare in UnityEngine.LineRenderer
bool w_vtS_Pu1i4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pu1i4i4i4i4S_pi4i4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pu1i4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_Pu1i4i4i4i4S_pi4i4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetPositions(Unity.Collections.NativeArray`1[UnityEngine.Vector3]) declare in UnityEngine.LineRenderer
bool w_vtS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void TransformDirections(System.Span`1[UnityEngine.Vector3]) declare in UnityEngine.Transform
bool w_vtS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void TransformDirections(System.ReadOnlySpan`1[UnityEngine.Vector3], System.Span`1[UnityEngine.Vector3]) declare in UnityEngine.Transform
bool w_vtS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_p_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValueDirect(TypedReference, System.Object) declare in System.Reflection.FieldInfo
bool w_vtS_S_p_pp_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_pp_O");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_S_p_pp_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetTRS(UnityEngine.RectTransform, com.pixui.PxTRS) declare in com.pixui.PxMisc
bool w_vtS_S_r4r4_r4S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4_r4S_r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_r4r4_r4S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_r4S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_r4S_r4r4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_r4r4_r4S_r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_localBounds(UnityEngine.Bounds) declare in UnityEngine.Animation
bool w_vtS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
        
    typedef void (*FuncToCall)(void*,struct S__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void WaitOnGPUFence(UnityEngine.Rendering.GPUFence, UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS__i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S__* pp0 = DataTransfer::GetPointer<S__>(apis, env, _sv0);
    S__ p0 = pp0 ? *pp0 : S__ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S__ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void set_scene(UnityEngine.SceneManagement.Scene) declare in UnityEngine.Camera
bool w_vtS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void NBResetCardDragCoord(VInt2) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void NBResetDragCoord(VInt2, VInt2, Boolean, Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtS_i4i4_S_i4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_S_i4i4_bb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, struct S_i4i4_ p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void NBSetSceneTipGridFeetFlags(VInt2, Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtS_i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void NBSetDragEquipHeroFeetFlags(VInt2, Boolean, Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtS_i4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_bb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void AddGrid(VInt2, UnityEngine.GameObject) declare in Assets.Scripts.GameLogic.Project8BattleField
bool w_vtS_i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayMoveEffect(VInt3) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void DrawOcclusionMesh(UnityEngine.RectInt) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_bakingOutput(UnityEngine.LightBakingOutput) declare in UnityEngine.Light
bool w_vtS_i4i4i4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4b_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4b_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4b_>(apis, env, _sv0);
    S_i4i4i4i4b_ p0 = pp0 ? *pp0 : S_i4i4i4i4b_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_descriptor(UnityEngine.RenderTextureDescriptor) declare in UnityEngine.RenderTexture
bool w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void IncrementUpdateCount(UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ConvertTexture(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, struct S_r4r4_ p3, struct S_r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_S_r4r4_S_r4r4_i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, struct S_r4r4_ p3, struct S_r4r4_ p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, Il2CppObject* p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_S_i4i4i4pi4i4i4_oi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, struct S_i4i4i4pi4i4i4_ p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ConvertTexture(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4S_i4i4i4pi4i4i4_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv2);
    S_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, struct S_i4i4i4pi4i4i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4S_i4i4i4pi4i4i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4S_i4i4i4pi4i4i4_i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv3);
    S_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, struct S_i4i4i4pi4i4i4_ p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32, Int32, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_i4i4i4i4i4i4S_i4i4i4pi4i4i4_i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_i4i4i4i4i4i4S_i4i4i4pi4i4i4_i4i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp7 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    int _sv10 = apis->get_arg(info, 10);
    int _sv11 = apis->get_arg(info, 11);
    if (checkLuaArgument) {
        if (lua_args_len != 12) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv10))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv11))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp7 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv7);
    S_i4i4i4pi4i4i4_ p7 = pp7 ? *pp7 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
                
    // LuaValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(apis, env, _sv10);
                
    // LuaValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(apis, env, _sv11);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, struct S_i4i4i4pi4i4i4_ p8, int32_t p9, int32_t p10, int32_t p11, int32_t p12, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);
    return true;
}
// Void ProcessVTFeedback(UnityEngine.Rendering.RenderTargetIdentifier, IntPtr, Int32, Int32, Int32, Int32, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_i4i4i4pi4i4i4_pi4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4pi4i4i4_pi4i4i4i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv0);
    S_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4pi4i4i4_ p1, void* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void set_startColor(MinMaxGradient) declare in UnityEngine.ParticleSystem+MainModule
bool w_vtS_i4ooS_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4ooS_r4r4r4r4_S_r4r4r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4ooS_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4ooS_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_i4ooS_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_i4ooS_r4r4r4r4_S_r4r4r4r4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4ooS_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetTargetBuffers(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer) declare in UnityEngine.Camera
bool w_vtS_i4p_S_i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_S_i4p_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
             // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4p_ p1, struct S_i4p_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void set_startDelay(MinMaxCurve) declare in UnityEngine.ParticleSystem+MainModule
bool w_vtS_i4r4oor4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4r4oor4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4r4oor4r4_* pp0 = DataTransfer::GetPointer<S_i4r4oor4r4_>(apis, env, _sv0);
    S_i4r4oor4r4_ p0 = pp0 ? *pp0 : S_i4r4oor4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4r4oor4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ChangeHudInfo(HPInfoRecord) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtS_i4u8r4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4u8r4b_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4u8r4b_* pp0 = DataTransfer::GetPointer<S_i4u8r4b_>(apis, env, _sv0);
    S_i4u8r4b_ p0 = pp0 ? *pp0 : S_i4u8r4b_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4u8r4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetBinding) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4pi4i4i4_ooi4i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4pi4i4i4_ooi4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetBinding, Int32, UnityEngine.CubemapFace, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oS_i4i4i4pi4i4i4_ooi4i4i4_i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_* pp0 = DataTransfer::GetPointer<S_oS_i4i4i4pi4i4i4_ooi4i4i4_>(apis, env, _sv0);
    S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p0 = pp0 ? *pp0 : S_oS_i4i4i4pi4i4i4_ooi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_oS_i4i4i4pi4i4i4_ooi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Pay(Assets.Scripts.SDK.PayParam) declare in Assets.Scripts.SDK.PayService
bool w_vtS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_o_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetUpgradeHeroNumOffset(Project8UpgradeNumOffset) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_vtS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oo_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};
        
    typedef void (*FuncToCall)(void*,struct S_oo_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void RecoverBeginNtf(CSRecoverEndInfo) declare in Assets.Scripts.Framework.CSRecoverSys
bool w_vtS_oou1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oou1_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_oou1_* pp0 = DataTransfer::GetPointer<S_oou1_>(apis, env, _sv0);
    S_oou1_ p0 = pp0 ? *pp0 : S_oou1_ {};
        
    typedef void (*FuncToCall)(void*,struct S_oou1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void BeginSample(Unity.Profiling.ProfilerMarker) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_p_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
        
    typedef void (*FuncToCall)(void*,struct S_p_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_pi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pi4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_pi4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence, UnityEngine.Rendering.SynchronisationStage) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_pi4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pi4i4_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_pi4i4_* pp0 = DataTransfer::GetPointer<S_pi4i4_>(apis, env, _sv0);
    S_pi4i4_ p0 = pp0 ? *pp0 : S_pi4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_pi4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void DrawRendererList(UnityEngine.Rendering.RendererList) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_pu4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_pu4u4u4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_pu4u4u4_* pp0 = DataTransfer::GetPointer<S_pu4u4u4_>(apis, env, _sv0);
    S_pu4u4u4_ p0 = pp0 ? *pp0 : S_pu4u4u4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_pu4u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetSize(UnityEngine.RectTransform, UnityEngine.Vector2) declare in Timi.TimiExtension
bool w_vtS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void UpdateCameraRelativeDisplacement(UnityEngine.Vector2, Boolean) declare in Moba_Camera
bool w_vtS_r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetContentRollManully(UnityEngine.Vector2, Single) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtS_r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Dr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void GetGenerationSettings(UnityEngine.Vector2, UnityEngine.TextGenerationSettings ByRef) declare in UnityEngine.UI.Text
bool w_vtS_r4r4_PS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_PS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p1 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetRect(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Vector2) declare in com.pixui.PxMisc
bool w_vtS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetVirtualActorScreenPosition(UnityEngine.Vector2, UnityEngine.Vector3) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetTRS(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Vector3, UnityEngine.Vector3) declare in com.pixui.PxMisc
bool w_vtS_r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void UpdateDragSaleArea(UnityEngine.Vector2, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_r4r4_S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_u4o_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_u4o_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void UpdateCameraOffset(UnityEngine.Vector2, Single) declare in Moba_Camera
bool w_vtS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetTRS(UnityEngine.RectTransform, UnityEngine.Vector2, Single, UnityEngine.Vector2) declare in com.pixui.PxMisc
bool w_vtS_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetScale(UnityEngine.RectTransform, UnityEngine.Vector3) declare in com.pixui.PxMisc
bool w_vtS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetAbsoluteLockLocation(UnityEngine.Vector3, Boolean) declare in Moba_Camera
bool w_vtS_r4r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void TweenDeltaOffset(UnityEngine.Vector3, Single) declare in Assets.Scripts.GameLogic.Project8FreeCamera
bool w_vtS_r4r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_Dr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void LookAt(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ShowAndSetFieldTransform(UnityEngine.Vector3, Boolean, Boolean, Boolean) declare in Assets.Scripts.GameLogic.Project8ArtField
bool w_vtS_r4r4r4_bbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_bbDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetFieldTransform(UnityEngine.Vector3, Boolean, Int32, Boolean) declare in Assets.Scripts.GameLogic.Project8BaseArtField
bool w_vtS_r4r4r4_bi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_bi4Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Translate(UnityEngine.Vector3, UnityEngine.Space) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Translate(UnityEngine.Vector3, UnityEngine.Transform) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Rotate(UnityEngine.Vector3, Single) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void AttachMeshObject(UnityEngine.Vector3, UInt32) declare in Assets.Scripts.GameLogic.ActorMeshComponent
bool w_vtS_r4r4r4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_u4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetColor(UnityEngine.UI.Graphic, UnityEngine.Color) declare in ExtImage
bool w_vtS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetGradualL2R(UnityEngine.Color, UnityEngine.Color) declare in MultifunctionImage
bool w_vtS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetClipRect(UnityEngine.Rect, Boolean) declare in Timi.TimiText
bool w_vtS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void CrossFadeColor(UnityEngine.Color, Single, Boolean, Boolean) declare in UnityEngine.UI.Graphic
bool w_vtS_r4r4r4r4_r4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4bb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void CrossFadeColor(UnityEngine.Color, Single, Boolean, Boolean, Boolean) declare in UnityEngine.UI.Graphic
bool w_vtS_r4r4r4r4_r4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4bbb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void CalculateFrustumCorners(UnityEngine.Rect, Single, MonoOrStereoscopicEye, UnityEngine.Vector3[]) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4_r4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void ChangeEnergyColor(UnityEngine.Color, UInt64) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtS_r4r4r4r4_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_u8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, uint64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetMatrix(UnityEngine.RectTransform, com.pixui.NativeMatrix) declare in com.pixui.PxMisc
bool w_vtS_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_cullingMatrix(UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetStereoViewMatrices(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32, UnityEngine.MaterialPropertyBlock) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32, UnityEngine.MaterialPropertyBlock) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, int32_t p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void InitPay(Assets.Scripts.SDK.PayInitParam) declare in Assets.Scripts.SDK.PayService
bool w_vtS_ssso_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_ssso_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_ssso_* pp0 = DataTransfer::GetPointer<S_ssso_>(apis, env, _sv0);
    S_ssso_ p0 = pp0 ? *pp0 : S_ssso_ {};
        
    typedef void (*FuncToCall)(void*,struct S_ssso_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ChangeCustomCoin(CustomCoinChangeParam) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_vtS_u1i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u1i4i4_* pp0 = DataTransfer::GetPointer<S_u1i4i4_>(apis, env, _sv0);
    S_u1i4i4_ p0 = pp0 ? *pp0 : S_u1i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u1i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void OnAddLordOrMirrorActor(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_vtS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4o_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetFocusActor(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], Boolean, UInt32, UInt32) declare in CameraSystem
bool w_vtS_u4o_DbDu4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4o_DbDu4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,struct S_u4o_ p1, bool p2, uint32_t p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void ShowSellArea(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], Boolean) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_u4o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4o_b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_u4o_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void OnActorHemophagia(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], Int32) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vtS_u4o_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4o_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_u4o_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetData(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BaseCard], UInt32, eSelectMode) declare in Assets.Scripts.UI.CardComponent.Item.UICardItemShowData
bool w_vtS_u4o_u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4o_u4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,struct S_u4o_ p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void set_infos(Project8NSelectOneInfos) declare in Assets.Scripts.GameLogic.PlayerNSelectOne
bool w_vtS_u4u1o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u1o_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u1o_* pp0 = DataTransfer::GetPointer<S_u4u1o_>(apis, env, _sv0);
    S_u4u1o_ p0 = pp0 ? *pp0 : S_u4u1o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u1o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetInfos(Project8NSelectOneInfos, Boolean) declare in Assets.Scripts.GameLogic.PlayerNSelectOne
bool w_vtS_u4u1o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u1o_b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u1o_* pp0 = DataTransfer::GetPointer<S_u4u1o_>(apis, env, _sv0);
    S_u4u1o_ p0 = pp0 ? *pp0 : S_u4u1o_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,struct S_u4u1o_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void AGEPlayLordAudio(PlayLordAudioParam) declare in Assets.Scripts.GameLogic.Project8BattleAudio
bool w_vtS_u4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u1u1u1u1_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u4u1u1u1u1_>(apis, env, _sv0);
    S_u4u1u1u1u1_ p0 = pp0 ? *pp0 : S_u4u1u1u1u1_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Sync(PlayerMetaDynamic) declare in Assets.Scripts.GameLogic.Player+PlayerMetaData
bool w_vtS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv0);
    S_u4u4_ p0 = pp0 ? *pp0 : S_u4u4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_PublicExtraInfo(stPlayerExtraPublicInfo) declare in Assets.Scripts.GameLogic.Project8PlayerInstance
bool w_vtS_u4u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u1_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u4u1_* pp0 = DataTransfer::GetPointer<S_u4u4u1_>(apis, env, _sv0);
    S_u4u4u1_ p0 = pp0 ? *pp0 : S_u4u4u1_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void OnSetChatLikeBoo1(ChatLikeBooInfo) declare in Assets.Scripts.GameSystem.Project8UIPlayerRank
bool w_vtS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u4u4_* pp0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, _sv0);
    S_u4u4u4_ p0 = pp0 ? *pp0 : S_u4u4u4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void OnSetChatInteractTips(ChatInteractInfo) declare in Assets.Scripts.GameSystem.Project8UIPlayerRank
bool w_vtS_u4u4u4i4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4i4u4o_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u4u4i4u4o_* pp0 = DataTransfer::GetPointer<S_u4u4u4i4u4o_>(apis, env, _sv0);
    S_u4u4u4i4u4o_ p0 = pp0 ? *pp0 : S_u4u4u4i4u4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4i4u4o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void UpdateSkillContext(Project8CastLordSkillContext) declare in Assets.Scripts.UI.InGameCommon.UILordSkillDataItem
bool w_vtS_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_* pp0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_>(apis, env, _sv0);
    S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ p0 = pp0 ? *pp0 : S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void LuaTrigger(System.Object[]) declare in EventProxyBase
bool w_vtVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtVO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

    }
    // LuaValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetActive(UnityEngine.Component, Boolean) declare in com.pixui.PxMisc
bool w_vtb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(void*,bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetRaycastState(Boolean, Boolean) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ShowOrHideCardDetailTypeSelect(Boolean, Boolean, XLua.LuaTable) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtbDbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbDbDo");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(void*,bool p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetCampCareerEffectVisible(Boolean, ResData.RES_RELATION_ID) declare in Assets.Scripts.GameLogic.ActorExtraDataLinkerComponent
bool w_vtbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbDi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void AddFlagsToAlternative(Boolean, OSProto.GridDisplayType[]) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_vtbVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbVi4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef void (*FuncToCall)(void*,bool p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetGameObjVisible(UnityEngine.GameObject, Boolean, Boolean) declare in ExtGameObject
bool w_vtbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ClearRenderTarget(Boolean, Boolean, UnityEngine.Color) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtbbS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbS_r4r4r4r4_");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,bool p1, bool p2, struct S_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void ClearRenderTarget(Boolean, Boolean, UnityEngine.Color, Single) declare in UnityEngine.Rendering.CommandBuffer
bool w_vtbbS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbS_r4r4r4r4_r4");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,bool p1, bool p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void NBSetDragHeroFeetFlags(Boolean, Boolean, Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetBackpackListVisible(Boolean, Boolean, UnityEngine.RectTransform) declare in Assets.Scripts.UI.InTheGame.Standard.UIEquip
bool w_vtbbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbo");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,bool p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetCurrencyVisible(Boolean, Boolean, UInt32) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtbbu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbbu4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,bool p1, bool p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetVisible(Boolean, Assets.Scripts.GameLogic.HudVisibleMask) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void AddFlagsToAlternative(Boolean, Int32, OSProto.GridDisplayType[]) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_vtbi4Vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4Vi4");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        if(lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p2 = Params<int32_t>::PackPrimitive(apis, env, info, TIp2, lua_args_len, 2);

    typedef void (*FuncToCall)(void*,bool p1, int32_t p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void PlayUsingEffect(Boolean, Int32, System.Action) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtbi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbi4o");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,bool p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void OnDestroy(Boolean, System.Collections.Generic.Dictionary`2[System.String,CResource]) declare in Assets.Scripts.Framework.AssetService.InstantiatableAsset
bool w_vtbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbo");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,bool p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ChangeCamera(Boolean, Single) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtbr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,bool p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void NBPlayAnim(Boolean, System.String) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbs");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(void*,bool p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetActorRelativeEffectVisible(Boolean, UInt32, ResData.RES_RELATION_ID) declare in Assets.Scripts.GameSystem.UIRelation
bool w_vtbu4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbu4Di4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,bool p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void DepositHandCards(Boolean, UInt32, Int32, UInt32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vtbu4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtbu4i4u4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,bool p1, uint32_t p2, int32_t p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void set_asteriskChar(Char) declare in UnityEngine.UI.InputField
bool w_vtc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtc");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void .ctor(Char, Int32) declare in System.String
bool w_vtci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtci4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetSimilarSpriteByIndex(Timi.TimiImage, Int32) declare in ExtImage
bool w_vti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(void*,int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void LeanCancel(UnityEngine.GameObject, Int32, Boolean) declare in LeanTweenExt
bool w_vti4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Db");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetSelect(Int32, Boolean, Boolean) declare in UIWidgets.CMTabGroup
bool w_vti4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4DbDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,int32_t p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void UnLoadBanks(Assets.Scripts.Sound.enBankType, Boolean, System.String[]) declare in Assets.Scripts.Sound.CSoundManager
bool w_vti4DbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4DbDo");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(void*,int32_t p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetAutoAdjustType(RawImageAutoAdjustType, RawimageAdjustByComponentType) declare in MultifunctionRawImage
bool w_vti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Di4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ScrollTo(Int32, Single) declare in UnityEngine.UI.ScrollView
bool w_vti4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Dr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Reset(GCloud.ConnectorErrorCode, System.String) declare in GCloud.ConnectorResult
bool w_vti4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Ds");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ShowOperationTips(OperationResult, UInt32) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vti4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Du4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    uint32_t p1 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void AddFlagsToBattle(BattleFieldArea, System.Object, OSProto.GridDisplayType[]) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_vti4OVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4OVi4");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p2 = Params<int32_t>::PackPrimitive(apis, env, info, TIp2, lua_args_len, 2);

    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void GetLordHurtNum(Int32, Int32 ByRef, Int32 ByRef) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_vti4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Pi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(void*,int32_t p1, int32_t* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void CopyTo(Int32, System.Span`1[System.Char], Int32) declare in System.Text.StringBuilder
bool w_vti4S_S_p_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_S_p_i4_i4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_S_p_i4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void GetTemporaryRT(Int32, UnityEngine.RenderTextureDescriptor) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void GetTemporaryRT(Int32, UnityEngine.RenderTextureDescriptor, UnityEngine.FilterMode) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv1);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetRandomWriteTarget(Int32, UnityEngine.Rendering.RenderTargetIdentifier) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4pi4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4pi4i4i4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_i4i4i4pi4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetGlobalTexture(Int32, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_i4i4i4pi4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_i4i4i4pi4i4i4_i4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4i4pi4i4i4_>(apis, env, _sv1);
    S_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : S_i4i4i4pi4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_i4i4i4pi4i4i4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetTextureOffset(Int32, UnityEngine.Vector2) declare in UnityEngine.Material
bool w_vti4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetPosition(Int32, UnityEngine.Vector3) declare in UnityEngine.LineRenderer
bool w_vti4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetMask(TMPro.MaskingTypes, UnityEngine.Vector4) declare in TMPro.TextMeshPro
bool w_vti4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetMask(TMPro.MaskingTypes, UnityEngine.Vector4, Single, Single) declare in TMPro.TextMeshPro
bool w_vti4S_r4r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4_r4r4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4_ p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void ClearRenderTarget(UnityEngine.Rendering.RTClearFlags, UnityEngine.Color, Single, UInt32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4S_r4r4r4r4_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4_r4u4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4_ p2, float p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetStereoProjectionMatrix(StereoscopicEye, UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vti4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void GridBindExchangeActor(OperationResult, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], Boolean) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vti4S_u4o_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u4o_b");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_u4o_ p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetDataForCapture(Int32, stFacade) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vti4S_u4u4u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4S_u4u4u4i4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_u4u4u4i4_* pp1 = DataTransfer::GetPointer<S_u4u4u4i4_>(apis, env, _sv1);
    S_u4u4u4i4_ p1 = pp1 ? *pp1 : S_u4u4u4i4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, struct S_u4u4u4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void CheckTriggerType(Assets.Scripts.GameSystem.Project8NewbieTriggerType, Int32[]) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vti4Vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4Vi4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetStateMask(Assets.Scripts.UI.CardComponent.Item.HandCardStateMask, Boolean) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayHorseRaceLampByTimes(Int32, Boolean, System.Action`1[System.Int32]) declare in ShrinkText
bool w_vti4bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4bo");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void set_Chars(Int32, Char) declare in System.Text.StringBuilder
bool w_vti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4c");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppChar p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ChangeRoundNum(Int32, Int32) declare in Assets.Scripts.GameLogic.Project8RoundStateFlow
bool w_vti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void OnHpChanged(Int32, Int32, Boolean) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vti4i4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4Db");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void CurrentResolutionChangeAction(Int32, Int32, Assets.Scripts.Framework.UI.SafeAreaBoundBox, UnityEngine.ScreenOrientation) declare in Assets.Scripts.Framework.UI.UIPrefabLayerService
bool w_vti4i4S_i4i4i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_i4i4i4i4_i4");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_i4i4i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4i4i4_>(apis, env, _sv2);
    S_i4i4i4i4_ p2 = pp2 ? *pp2 : S_i4i4i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, struct S_i4i4i4i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void ChangeOffsetVector(Assets.Scripts.UI.CardComponent.Item.OffsetType, OffsetReason, UnityEngine.Vector3) declare in Assets.Scripts.UI.CardComponent.Item.UICardItemShowData
bool w_vti4i4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4S_r4r4r4_");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void RemoveFlagsFromBattle(Int32, Int32, Boolean, System.Object, OSProto.GridDisplayType[]) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_vti4i4bOVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4bOVi4");
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        if(lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p4 = Params<int32_t>::PackPrimitive(apis, env, info, TIp4, lua_args_len, 4);

    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, bool p3, Il2CppObject* p4, Il2CppArray* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void AddFlagsToBattle(Int32, Int32, Boolean, System.Object, Boolean, OSProto.GridDisplayType[]) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_vti4i4bObVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4bObVi4");
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        if(lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p5 = Params<int32_t>::PackPrimitive(apis, env, info, TIp5, lua_args_len, 5);

    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, bool p3, Il2CppObject* p4, bool p5, Il2CppArray* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void GetFlagsFromBattle(Int32, Int32, Boolean, System.Collections.Generic.ICollection`1[OSProto.GridDisplayType]) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_vti4i4bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4bo");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, bool p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void OnPartChange(Protobuf.PartOperate, Int32, ResData.ActorAbilitySymmetryType) declare in BindableDict`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_vti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetCameraCenterLerp(Int32, Int32, Int32, Boolean, Int32, Int32) declare in Moba_Camera
bool w_vti4i4i4DbDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4DbDi4Di4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, bool p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetCameraViewportLerp(Int32, Int32, Int32, VInt3 ByRef, VInt3 ByRef, Int32, Int32, System.String) declare in Moba_Camera
bool w_vti4i4i4PS_i4i4i4_PS_i4i4i4_i4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4PS_i4i4i4_PS_i4i4i4_i4i4s");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!apis->is_object(env, _sv4)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p3 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_i4i4i4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p4 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_i4i4i4_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
            // LuaValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7);
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, struct S_i4i4i4_* p4, struct S_i4i4i4_* p5, int32_t p6, int32_t p7, Il2CppString* p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }
                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, ret3);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void UpdateRoundState(Int32, Int32, Int32, Int32, Int32) declare in Assets.Scripts.GameLogic.Project8RoundStateFlow
bool w_vti4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, UnityEngine.RenderTextureMemoryless) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4bi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, UnityEngine.RenderTextureMemoryless, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4bi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4bi4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 10) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, int32_t p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4bb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 10) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean, UnityEngine.RenderTextureMemoryless) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4bi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 10) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    return true;
}
// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean, UnityEngine.RenderTextureMemoryless, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4bi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4bi4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    int _sv10 = apis->get_arg(info, 10);
    if (checkLuaArgument) {
        if (lua_args_len != 11) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv9))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv10))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(apis, env, _sv9);
                
    // LuaValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(apis, env, _sv10);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, int32_t p10, bool p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    return true;
}
// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4i4i4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4i4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 10) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
    return true;
}
// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar) declare in System.DateTime
bool w_vti4i4i4i4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4o");
    auto TIp7 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
            
    // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValueToCSRef(apis, TIp7, env, _sv7);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, Il2CppObject* p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar, System.DateTimeKind) declare in System.DateTime
bool w_vti4i4i4i4i4i4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4i4oi4");
    auto TIp7 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv7, TIp7, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
            
    // LuaValToCSVal o/O
    Il2CppObject* p7 = LuaValueToCSRef(apis, TIp7, env, _sv7);
                
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, Il2CppObject* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void .ctor(Int32, Int32, Int32, Int32, Int32, Int32, System.Globalization.Calendar) declare in System.DateTime
bool w_vti4i4i4i4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4i4i4i4o");
    auto TIp6 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void .ctor(Int32, Int32, Int32, System.Globalization.Calendar) declare in System.DateTime
bool w_vti4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4o");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void .ctor(GCloud.ConnectorErrorCode, Int32, Int32, System.String) declare in GCloud.ConnectorResult
bool w_vti4i4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4i4s");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Sort(Int32, Int32, System.Collections.Generic.IComparer`1[UIEventDelegate]) declare in System.Collections.Generic.List`1[UIEventDelegate]
bool w_vti4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4o");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetCameraTimeLerpParam2(Int32, Int32, Single, Single, UnityEngine.Vector3, UnityEngine.Vector3) declare in Moba_Camera
bool w_vti4i4r4r4S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4r4r4S_r4r4r4_S_r4r4r4_");
    auto TIp4 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
             // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, float p3, float p4, struct S_r4r4r4_ p5, struct S_r4r4r4_ p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetCameraTimeLerpParam(Int32, Int32, Single, Single, Single, Single, Single, Single) declare in Moba_Camera
bool w_vti4i4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4r4r4r4r4r4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
        
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, float p3, float p4, float p5, float p6, float p7, float p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void .ctor(GCloud.ConnectorErrorCode, Int32, System.String) declare in GCloud.ConnectorResult
bool w_vti4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4s");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void CreateNumFloatText(Int32, Assets.Scripts.GameSystem.FLOAT_TYPE, UInt32, UnityEngine.Vector3, Boolean, UInt32, Int32) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vti4i4u4S_r4r4r4_DbDu4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4i4u4S_r4r4r4_DbDu4Di4");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
             // LuaValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, uint32_t p3, struct S_r4r4r4_ p4, bool p5, uint32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void AddCommandBuffer(UnityEngine.Rendering.CameraEvent, UnityEngine.Rendering.CommandBuffer) declare in UnityEngine.Camera
bool w_vti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4o");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetRandomWriteTarget(Int32, UnityEngine.ComputeBuffer, Boolean) declare in UnityEngine.Rendering.CommandBuffer
bool w_vti4ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ob");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void LoadAsyn(Int32, Assets.Scripts.Framework.AssetService.IAssetLoadCallback, Assets.Scripts.Framework.AssetService.AssetType, System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, Int32, Int32, System.Object, System.Object) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_vti4oi1si1DsDi4Di4Di4DODO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi1si1DsDi4Di4Di4DODO");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    int _sv10 = apis->get_arg(info, 10);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 11) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (lua_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (lua_args_len > 8 && !converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
            // LuaValToCSVal string with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 5); // LuaValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 6);
             // LuaValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 7);
             // LuaValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 8);
                // LuaValToCSVal ref with default
    Il2CppObject* p9 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 9, TIp9);    // LuaValToCSVal ref with default
    Il2CppObject* p10 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 10, TIp10);
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int8_t p3, Il2CppString* p4, int8_t p5, Il2CppString* p6, int32_t p7, int32_t p8, int32_t p9, Il2CppObject* p10, Il2CppObject* p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    return true;
}
// Void AddLoad(Int32, Assets.Scripts.Framework.AssetService.IAssetLoadCallback, Assets.Scripts.Framework.AssetService.AssetType, System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, Int32, Int32, System.Object, System.Object) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_vti4oi1si1si4i4Di4DODO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi1si1si4i4Di4DODO");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    int _sv10 = apis->get_arg(info, 10);
    if (true) {
        if (lua_args_len < 8 || lua_args_len > 11) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (lua_args_len > 8 && !converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
            // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);        
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
         // LuaValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 8);
                // LuaValToCSVal ref with default
    Il2CppObject* p9 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 9, TIp9);    // LuaValToCSVal ref with default
    Il2CppObject* p10 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 10, TIp10);
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int8_t p3, Il2CppString* p4, int8_t p5, Il2CppString* p6, int32_t p7, int32_t p8, int32_t p9, Il2CppObject* p10, Il2CppObject* p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);
    return true;
}
// Void AddCommandBufferAsync(UnityEngine.Rendering.CameraEvent, UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.ComputeQueueType) declare in UnityEngine.Camera
bool w_vti4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void CopyTo(Int32, Char[], Int32, Int32) declare in System.String
bool w_vti4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oi4i4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Init(Int32, Timi.TimiMenuOptionData, System.Action`1[Timi.TimiMenuItem]) declare in Timi.TimiMenuItem
bool w_vti4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4oo");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void Open(com.vasd.gamelet.PandoraEnv, System.Action`1[System.String], System.Action`2[UnityEngine.GameObject,System.String], System.Action`2[UnityEngine.GameObject,System.String], System.Action`2[System.String,System.Collections.Generic.Dictionary`2[System.String,System.String]], System.Action`4[System.String,System.String,UnityEngine.GameObject,System.Action`2[System.String,UnityEngine.GameObject]]) declare in PandoraSDK.PandoraSDK
bool w_vti4ooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ooooo");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void RegisterPlayerHang(OSProto.HangUIType, UnityEngine.Transform, UInt32) declare in Assets.Scripts.GameSystem.UIComponentArtEffect
bool w_vti4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4ou4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetSystemSpeed(SystemSpeedType, Single) declare in Assets.Scripts.Framework.FrameSynchr
bool w_vti4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ScrollTo(Int32, Single, Boolean, Single) declare in UIWidgets.EasyListView
bool w_vti4r4DbDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4DbDr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,int32_t p1, float p2, bool p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetInsetAndSizeFromParentEdge(Edge, Single, Single) declare in UnityEngine.RectTransform
bool w_vti4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4r4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef void (*FuncToCall)(void*,int32_t p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetItemTitleTxt(Int32, System.String) declare in Timi.TimiMenu
bool w_vti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4s");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetHeroUpgradeEffectAge(Int32, System.String, System.String, System.String) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_vti4sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4sss");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void OnScheduleHandle(Assets.Scripts.Framework.ScheduleService.ScheduleType, UInt32) declare in Assets.Scripts.Update.UpdateService
bool w_vti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SimpleSetDataWithConfigID(Int32, UInt32, stFacade, Boolean, Boolean, OSProto.SyncDynamicDesc, System.Object[]) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vti4u4S_u4u4u4i4_DbDbDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u4S_u4u4u4i4_DbDbDoDo");
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (lua_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_u4u4u4i4_* pp2 = DataTransfer::GetPointer<S_u4u4u4i4_>(apis, env, _sv2);
    S_u4u4u4i4_ p2 = pp2 ? *pp2 : S_u4u4u4i4_ {};
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5);    // LuaValToCSVal ref with default
    Il2CppObject* p6 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 6, TIp6);
    typedef void (*FuncToCall)(void*,int32_t p1, uint32_t p2, struct S_u4u4u4i4_ p3, bool p4, bool p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void .ctor(Scope, UInt32, Boolean, Boolean, Boolean) declare in Assets.Scripts.GameSystem.CullData
bool w_vti4u4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti4u4bbb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef void (*FuncToCall)(void*,int32_t p1, uint32_t p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void set_rangeStart(Int64) declare in CurlUnity.CurlEasy
bool w_vti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef void (*FuncToCall)(void*,int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Install(Int64, Boolean) declare in Assets.Scripts.Resource.Package.QtsPackageManager
bool w_vti8Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti8Db");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int64_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void .ctor(Int64, System.DateTimeKind) declare in System.DateTime
bool w_vti8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti8i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int64_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void OnInstalled(Int64, System.String) declare in Assets.Scripts.Resource.Package.OnAirCollection
bool w_vti8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti8s");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(void*,int64_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void AddPackage(Int64, UInt64) declare in Assets.Scripts.Resource.Package.OnAirCollection
bool w_vti8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vti8u8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef void (*FuncToCall)(void*,int64_t p1, uint64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
}

