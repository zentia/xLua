// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// LTDescr color(UnityEngine.GameObject, UnityEngine.Color, Single) declare in LeanTween
bool w_ooS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetEnumDescriptions(System.Type, System.String[] ByRef) declare in Assets.Scripts.UI.NewbieUtils
bool w_ooTo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooTo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, void* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int32[]) declare in System.Array
bool w_ooVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooVi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        if(lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int64[]) declare in System.Array
bool w_ooVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooVi8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        if(lua_args_len > 1 && !converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int64_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type MakeGenericSignatureType(System.Type, System.Type[]) declare in System.Type
bool w_ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooVo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if(lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxWindow LoadPageFromData(com.pixui.MountUI, Byte[], System.String) declare in com.pixui.PxContext
bool w_ooas(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooas");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object[] FindObjectsOfType(System.Type, Boolean) declare in UnityEngine.Object
bool w_oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsSortMode) declare in UnityEngine.Object
bool w_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsInactive, UnityEngine.FindObjectsSortMode) declare in UnityEngine.Object
bool w_ooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int32, Int32, Int32) declare in System.Array
bool w_ooi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[System.String] getFileList(System.String[], System.IO.SearchOption, System.String[], System.String) declare in FileUtils
bool w_ooi4oDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4oDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform) declare in UnityEngine.Object
bool w_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator OpenEquipTip(Assets.Scripts.Framework.UI.UIPrefab2DClass, stShowEquipmentInfo, System.Action, Boolean, System.Action`1[PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UIPrefab2DClass]]) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_oooDoDbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooDoDbDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector2], UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTween
bool w_oooS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
     
    // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4_ p3, struct S_r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector3], UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTween
bool w_oooS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr delayedSound(UnityEngine.GameObject, UnityEngine.AudioClip, UnityEngine.Vector3, Single) declare in LeanTween
bool w_oooS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[UnityEngine.Color], UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTween
bool w_oooS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform, Boolean) declare in UnityEngine.Object
bool w_ooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int32[], Int32[]) declare in System.Array
bool w_oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr move(UnityEngine.GameObject, UnityEngine.Vector3[], Single) declare in LeanTween
bool w_ooor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooor4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[System.Single], Single, Single, Single) declare in LeanTween
bool w_ooor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooor4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, float p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Delegate CreateDelegate(System.Type, System.Type, System.String) declare in System.Delegate
bool w_ooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean) declare in System.Delegate
bool w_ooosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooosb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean, Boolean) declare in System.Delegate
bool w_ooosbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooosbb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, bool p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr destroyAfter(LTRect, Single) declare in LeanTween
bool w_oor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr delayedCall(UnityEngine.GameObject, Single, System.Action) declare in LeanTween
bool w_oor4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr alpha(UnityEngine.GameObject, Single, Single) declare in LeanTween
bool w_oor4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, Single, Single, Single) declare in LeanTween
bool w_oor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Sprite LoadSprite(Timi.TimiImage, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_oos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GameObject CreateSceneGroupChildGameobject(UnityEngine.GameObject, System.String, Int32) declare in LuaCallCSharpInteraction
bool w_oosi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oosi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxWindow LoadString(com.pixui.MountUI, System.String, System.String) declare in com.pixui.PxContext
bool w_ooss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Token SetTimer(Single, Int32, System.Action) declare in com.pixui.PxContext
bool w_or4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(float p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Token SetTimer(Single, Int32, System.Action, System.Action) declare in com.pixui.PxContext
bool w_or4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4i4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(float p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr delayedCall(Single, System.Action) declare in LeanTween
bool w_or4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(float p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(Single, Single, Single) declare in LeanTween
bool w_or4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(float p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Shader GetShader(System.String) declare in com.pixui.PxMisc
bool w_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_os");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass CreateLuaPrefabClass(System.String, System.Object) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_osDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass AsyncCreateLuaPrefabClass(System.String, System.Object, System.Action`1[Assets.Scripts.Framework.UI.UILuaPrefabClass]) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_osDODo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDODo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task`1[System.String] ReadAllTextAsync(System.String, System.Threading.CancellationToken) declare in System.IO.File
bool w_osDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal valuetype with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_o_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.CActorInfo GetActorInfo(System.String, Boolean) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_osDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CResource Load(System.String, ResourceLoaderStyle, System.Type, Boolean, BakedResourceType) declare in CResourceManager
bool w_osDi1DoDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDi1DoDbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int8_t p2, Il2CppObject* p3, bool p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2[] GetVector2Array(System.String, UnityEngine.Vector2, Int32) declare in PlayerPrefsX
bool w_osS_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osS_r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3[] GetVector3Array(System.String, UnityEngine.Vector3, Int32) declare in PlayerPrefsX
bool w_osS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osS_r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion[] GetQuaternionArray(System.String, UnityEngine.Quaternion, Int32) declare in PlayerPrefsX
bool w_osS_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osS_r4r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllBytesAsync(System.String, Byte[], System.Threading.CancellationToken) declare in System.IO.File
bool w_osaDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osaDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal valuetype with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromProgID(System.String, Boolean) declare in System.Type
bool w_osb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, Boolean, Boolean) declare in System.Type
bool w_osbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osbb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean[] GetBoolArray(System.String, Boolean, Int32) declare in PlayerPrefsX
bool w_osbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osbi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Security.AccessControl.DirectorySecurity GetAccessControl(System.String, System.Security.AccessControl.AccessControlSections) declare in System.IO.Directory
bool w_osi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Create(System.String, Int32, System.IO.FileOptions) declare in System.IO.File
bool w_osi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Open(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare) declare in System.IO.File
bool w_osi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Create(System.String, Int32, System.IO.FileOptions, System.Security.AccessControl.FileSecurity) declare in System.IO.File
bool w_osi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[System.String] getFileList(System.String, System.IO.SearchOption, System.String[], System.String) declare in FileUtils
bool w_osi4oDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4oDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object[] GetParamsOfGetGlobal(System.String, Int32, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_osi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.DirectoryInfo CreateDirectory(System.String, System.Security.AccessControl.DirectorySecurity) declare in System.IO.Directory
bool w_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task`1[System.String] ReadAllTextAsync(System.String, System.Text.Encoding, System.Threading.CancellationToken) declare in System.IO.File
bool w_osoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal valuetype with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Timi.TimiMenuItem CreateItem(System.String, UnityEngine.Transform, System.Collections.Generic.List`1[Timi.TimiNestedPrefabOverrideProperty]) declare in Timi.TimiMenu
bool w_osoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CResource GetResource(System.String, System.Type, enResourceType, Boolean, enResourceLoadType, ResourceLoaderStyle) declare in CResourceManager
bool w_osoi4DbDi4Di1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoi4DbDi4Di1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int8_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int8_t p5 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, bool p4, int32_t p5, int8_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, System.Func`2[System.Reflection.AssemblyName,System.Reflection.Assembly], System.Func`4[System.Reflection.Assembly,System.String,System.Boolean,System.Type]) declare in System.Type
bool w_osoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllLinesAsync(System.String, System.Collections.Generic.IEnumerable`1[System.String], System.Text.Encoding, System.Threading.CancellationToken) declare in System.IO.File
bool w_osooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osooDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    // LuaValToCSVal valuetype with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, System.Func`2[System.Reflection.AssemblyName,System.Reflection.Assembly], System.Func`4[System.Reflection.Assembly,System.String,System.Boolean,System.Type], Boolean) declare in System.Type
bool w_osoob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, System.Func`2[System.Reflection.AssemblyName,System.Reflection.Assembly], System.Func`4[System.Reflection.Assembly,System.String,System.Boolean,System.Type], Boolean, Boolean) declare in System.Type
bool w_osoobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoobb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator PreInstantiate(System.String, Single) declare in Assets.Scripts.GameLogic.Hud3D
bool w_osr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single[] GetFloatArray(System.String, Single, Int32) declare in PlayerPrefsX
bool w_osr4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osr4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Sprite LoadSpriteImpl(System.String, System.String) declare in ExtImage
bool w_oss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllTextAsync(System.String, System.String, System.Threading.CancellationToken) declare in System.IO.File
bool w_ossDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal valuetype with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromProgID(System.String, System.String, Boolean) declare in System.Type
bool w_ossb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetFiles(System.String, System.String, System.IO.SearchOption) declare in System.IO.Directory
bool w_ossi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.RegularExpressions.Match Match(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_ossi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, struct S_i8_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetFiles(System.String, System.String, System.IO.EnumerationOptions) declare in System.IO.Directory
bool w_osso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllTextAsync(System.String, System.String, System.Text.Encoding, System.Threading.CancellationToken) declare in System.IO.File
bool w_ossoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossoDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    // LuaValToCSVal valuetype with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.ParameterInfo get_ReturnParameter() declare in System.Reflection.MethodInfo
bool w_ot(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ot");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppObject* (*FuncToCall)(void*,const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32[] GetBattleHeroCfgIDs(Boolean) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_otDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.IEnumerable`1[UIAudioElement] GetAudioElements(Boolean[]) declare in Timi.TimiButton
bool w_otDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// OSProto.SyncPlayerAuction Duplicate(System.String, Int32, System.String) declare in OSProto.SyncPlayerAuction
bool w_otDsDi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otDsDi4Ds");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setOnCompleteParam(System.Object) declare in LTDescr
bool w_otO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset CreateGameObject(CreateUnityObject ByRef) declare in UnityObjMgr
bool w_otPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_* p0 = DataTransfer::GetPointer<S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.ActorConfig CreateActor(SpawnActorData ByRef) declare in Assets.Scripts.GameLogic.ActorManager
bool w_otPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Char*, Int32) declare in System.Text.StringBuilder
bool w_otPci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otPci4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    Il2CppChar up0 = 0x0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret0 = converter::Converter<Il2CppChar>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(System.ReadOnlySpan`1[System.Char]) declare in System.Text.StringBuilder
bool w_otS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.ChessAreaInfo GetBattleFieldSlotByCoord(VInt2) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_otS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(System.Decimal) declare in System.Text.StringBuilder
bool w_otS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.SceneInteractcs SceneInteraction(UnityEngine.Vector2) declare in Assets.Scripts.GameLogic.Project8SceneManagement
bool w_otS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTweenExt
bool w_otS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanMove(UnityEngine.GameObject, UnityEngine.Vector2, Single) declare in LeanTweenExt
bool w_otS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setAxis(UnityEngine.Vector3) declare in LTDescr
bool w_otS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTweenExt
bool w_otS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanMove(UnityEngine.GameObject, UnityEngine.Vector3, Single) declare in LeanTweenExt
bool w_otS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanRotateAround(UnityEngine.GameObject, UnityEngine.Vector3, Single, Single) declare in LeanTweenExt
bool w_otS_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setFromColor(UnityEngine.Color) declare in LTDescr
bool w_otS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTweenExt
bool w_otS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator Capture(UnityEngine.Rect, System.Action`1[System.String], System.Action`1[UnityEngine.Texture2D], System.String, Assets.Scripts.GameSystem.CaptureSettings, Boolean) declare in Assets.Scripts.GameSystem.ShareCaptureSys
bool w_otS_r4r4r4r4_oDoDsDS_bbi4bo_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_oDoDsDS_bbi4bo_Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;
        if (lua_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3);    // LuaValToCSVal valuetype with default
    S_bbi4bo_ p4 = OptionalParameter<S_bbi4bo_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppString* p4, struct S_bbi4bo_ p5, bool p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanColor(UnityEngine.GameObject, UnityEngine.Color, Single) declare in LeanTweenExt
bool w_otS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char[]) declare in System.String
bool w_otVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otVc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo MakeGenericMethod(System.Type[]) declare in System.Reflection.MethodInfo
bool w_otVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otVo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if(lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false))
            return false;        
    }
    // LuaValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setHasInitialized(Boolean) declare in LTDescr
bool w_otb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// TimelineRuntime.Timeline PlayAction(Boolean, UnityEngine.GameObject, Assets.Scripts.GameLogic.Project8PlayerInstance) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_otboDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otboDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetDateTimeFormats(Char) declare in System.DateTime
bool w_otc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char, System.StringSplitOptions) declare in System.String
bool w_otcDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(Char, System.Object[]) declare in System.Text.StringBuilder
bool w_otcVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(Char, System.String[]) declare in System.Text.StringBuilder
bool w_otcVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
     // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Replace(Char, Char) declare in System.Text.StringBuilder
bool w_otcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Replace(Char, Char, Int32, Int32) declare in System.Text.StringBuilder
bool w_otcci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcci4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Char, Int32) declare in System.Text.StringBuilder
bool w_otci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otci4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char, Int32, System.StringSplitOptions) declare in System.String
bool w_otci4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otci4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetDateTimeFormats(Char, System.IFormatProvider) declare in System.DateTime
bool w_otco(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otco");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(SByte) declare in System.Text.StringBuilder
bool w_oti1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,int8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.BaseAsset LoadAsset(Assets.Scripts.Framework.AssetService.AssetType, System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, System.Object, Boolean) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_oti1si1sDi4DODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti1si1sDi4DODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3); // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5); // LuaValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int8_t p1, Il2CppString* p2, int8_t p3, Il2CppString* p4, int32_t p5, Il2CppObject* p6, bool p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Int16) declare in System.Text.StringBuilder
bool w_oti2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,int16_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Transform ExtGetChild(UnityEngine.Transform, Int32) declare in ExtTransform
bool w_oti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Project8ArtField GetArtField(Int32, SceneLevelDefine) declare in Assets.Scripts.GameLogic.Project8Logic
bool w_oti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.Object) declare in System.Text.StringBuilder
bool w_oti4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4O");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.ReadOnlySpan`1[System.Char]) declare in System.Text.StringBuilder
bool w_oti4S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.Decimal) declare in System.Text.StringBuilder
bool w_oti4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, struct S_i4i4i4i4u8_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RectTransform CreateItem(Int32, UnityEngine.Vector3) declare in Timi.TimiListView
bool w_oti4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Boolean) declare in System.Text.StringBuilder
bool w_oti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Char) declare in System.Text.StringBuilder
bool w_oti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4c");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppChar p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, SByte) declare in System.Text.StringBuilder
bool w_oti4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Int16) declare in System.Text.StringBuilder
bool w_oti4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[CMTweener+Data] GetRange(Int32, Int32) declare in System.Collections.Generic.List`1[CMTweener+Data]
bool w_oti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Open(System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare) declare in System.IO.FileInfo
bool w_oti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color[] GetPixels(Int32, Int32, Int32, Int32) declare in UnityEngine.Texture2D
bool w_oti4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color[] GetPixels(Int32, Int32, Int32, Int32, Int32) declare in UnityEngine.Texture2D
bool w_oti4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes, System.Reflection.BindingFlags, System.Reflection.MemberFilter, System.Object) declare in System.Type
bool w_oti4i4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4oO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Int64) declare in System.Text.StringBuilder
bool w_oti4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CMTweener GetCmtByEffect(OSProto.InteractiveEffectType, InteractiveLocal) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_oti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[OSProto.SyncPileInfo] AddBind(OSProto.CardPileType, System.Action`1[OSProto.SyncPileInfo], Boolean) declare in BindableDict`2[OSProto.CardPileType,OSProto.SyncPileInfo]
bool w_oti4oDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[OSProto.SyncPileInfo] AddBind2Target(OSProto.CardPileType, System.Action`1[OSProto.SyncPileInfo], System.Object, Boolean) declare in BindableDict`2[OSProto.CardPileType,OSProto.SyncPileInfo]
bool w_oti4oODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
 // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Char[], Int32, Int32) declare in System.Text.StringBuilder
bool w_oti4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Reflection.CallingConventions, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_oti4oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_oti4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Single) declare in System.Text.StringBuilder
bool w_oti4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Double) declare in System.Text.StringBuilder
bool w_oti4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4r8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<double>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, double p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.String) declare in System.Text.StringBuilder
bool w_oti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.String, Int32) declare in System.Text.StringBuilder
bool w_oti4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4si4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Byte) declare in System.Text.StringBuilder
bool w_oti4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, UInt16) declare in System.Text.StringBuilder
bool w_oti4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Player GetPlayerByCampIndex(Int32, UInt32) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_oti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.GameWatchModeFactory InitCreators(Assets.Scripts.GameLogic.ObMode, UInt32, UInt32) declare in Assets.Scripts.GameSystem.GameWatchManager
bool w_oti4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, UInt64) declare in System.Text.StringBuilder
bool w_oti4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4u8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, uint64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[System.Int64] GetUnreadyDependencies(Int64) declare in Assets.Scripts.Resource.Package.QtsPackageManager
bool w_oti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Delegate CreateDelegate(System.Type) declare in System.Reflection.MethodInfo
bool w_oto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oto");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setOnUpdate(System.Action`2[System.Single,System.Object], System.Object) declare in LTDescr
bool w_otoDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoDO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IPooledMonoBehaviour GetCachedMonobehaviourByType(System.Type, Boolean) declare in Assets.Scripts.Framework.AssetService.ActorAsset
bool w_otoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Delegate CreateDelegate(System.Type, System.Object) declare in System.Reflection.MethodInfo
bool w_otoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[System.Collections.Generic.Dictionary`2[OSProto.CardPileType,OSProto.SyncPileInfo]] AddBind2Target(System.Action`1[System.Collections.Generic.Dictionary`2[OSProto.CardPileType,OSProto.SyncPileInfo]], System.Object, Boolean) declare in BindableDict`2[OSProto.CardPileType,OSProto.SyncPileInfo]
bool w_otoODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector2], UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTweenExt
bool w_otoS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4_ p2, struct S_r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector3], UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTweenExt
bool w_otoS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[UnityEngine.Color], UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTweenExt
bool w_otoS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Component GetComponentInChildren(System.Type, Boolean) declare in UnityEngine.Component
bool w_otob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char[], Int32) declare in System.String
bool w_otoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char[], Int32, System.StringSplitOptions) declare in System.String
bool w_otoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rect[] PackTextures(UnityEngine.Texture2D[], Int32, Int32, Boolean) declare in UnityEngine.Texture2D
bool w_otoi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoi4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass LoadLuaChildPrefab(XLua.LuaTable, UnityEngine.Transform, System.Object, Boolean) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otooDODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otooDODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UIPrefabBaseClass CreateChildPrefabClass(System.Type, UnityEngine.Transform, System.Object, Boolean, UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_otooObS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otooObS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, struct S_r4r4r4_ p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UIPrefab2DClass CreateAsynChildPrefabClass(System.Type, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UIPrefab2DClass], UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otooOboS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otooOboS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, struct S_r4r4r4_ p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Material GetCustomMatWithDic(System.Collections.Generic.Dictionary`2[System.Int32,UnityEngine.Material], UnityEngine.Material, Boolean) declare in UnityEngine.UI.Image
bool w_otoob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otoob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UIWidgets.ListViewItem BindUIPrefab2Component(UnityEngine.GameObject, UIPrefab2D, Int32, System.String) declare in UIWidgets.EasyListView
bool w_otooi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otooi4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, int32_t p3, Il2CppString* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanMove(UnityEngine.GameObject, UnityEngine.Vector3[], Single) declare in LeanTweenExt
bool w_otor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otor4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, System.Action`1[System.Single], Single, Single, Single) declare in LeanTweenExt
bool w_otor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otor4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, float p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object) declare in System.Text.StringBuilder
bool w_otosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otosOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otosOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.IFormatProvider, System.String, System.Object[]) declare in System.Text.StringBuilder
bool w_otosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otosVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.GameLogic.Project8Equipment+EquipRecommendInfo] GetConfigThenRecommendHeroForEquipList(UInt32[], UInt32) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_otou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otou4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// ResData.HighLightShowDataBin GetTriggerHighLightShowCfg(Assets.Scripts.GameLogic.Project8PlayerInstance, UInt32, UInt32) declare in Assets.Scripts.GameLogic.PlayerBattleBroadcast
bool w_otou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otou4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setDelay(Single) declare in LTDescr
bool w_otr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,float p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanDelayedCall(UnityEngine.GameObject, Single, System.Action`1[System.Object]) declare in LeanTweenExt
bool w_otr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,float p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanAlpha(UnityEngine.GameObject, Single, Single) declare in LeanTweenExt
bool w_otr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,float p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, Single, Single, Single) declare in LeanTweenExt
bool w_otr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,float p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Double) declare in System.Text.StringBuilder
bool w_otr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otr8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,double p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Transform FuzzyFind(UnityEngine.Transform, System.String) declare in ExtRectTransform
bool w_ots(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ots");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass GetOrCreateLuaChild(System.String, System.Object, Boolean, UnityEngine.Transform) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_otsDODbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDODbDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
                // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Transform FindChildWithSplit(UnityEngine.Transform, System.String, Boolean) declare in ExtRectTransform
bool w_otsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.WZArtistSceneAsset LoadWZArtistSceneAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.Object, System.String, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DODsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DODsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3); // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppObject* p3, Il2CppString* p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.TextureAsset LoadTextureAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.UIAsset LoadUIAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, Int32, UnityEngine.Transform) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1Di4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1Di4Do");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
                // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.ActorAsset LoadActorAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppString* p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset LoadInstantiateAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, System.Object) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DsDi4DO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DsDi4DO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppString* p3, int32_t p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.ParticleAsset LoadParticleAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, UnityEngine.Transform) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsDi1DsDi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi1DsDi4Do");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, Il2CppString* p3, int32_t p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(System.String, System.StringSplitOptions) declare in System.String
bool w_otsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GatherTag(System.String, System.String) declare in UnityEngine.Shader
bool w_otsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Coroutine StartCoroutine(System.String, System.Object) declare in UnityEngine.MonoBehaviour
bool w_otsO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.String, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otsOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendFormat(System.String, System.Object, System.Object, System.Object) declare in System.Text.StringBuilder
bool w_otsOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(System.String, System.Object[]) declare in System.Text.StringBuilder
bool w_otsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(System.String, System.String[]) declare in System.Text.StringBuilder
bool w_otsVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileInfo CopyTo(System.String, Boolean) declare in System.IO.FileInfo
bool w_otsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset GetPooledGameObj(System.String, Boolean, SceneObjType, UnityEngine.Vector3, UnityEngine.Quaternion) declare in SceneMgr
bool w_otsbi4S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsbi4S_r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.BaseAsset GetPooledGameObjLOD(System.String, Boolean, SceneObjType, UnityEngine.Vector3, UnityEngine.Quaternion, Assets.Scripts.Framework.AssetService.LifeType, System.String, System.String) declare in SceneMgr
bool w_otsbi4S_r4r4r4_S_r4r4r4r4_i1DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsbi4S_r4r4r4_S_r4r4r4r4_i1DsDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;
        if (lua_args_len > 7 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv4);
    S_r4r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    int8_t p5 = converter::Converter<int8_t>::toCpp(apis, env, _sv5);
    // LuaValToCSVal string with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 6);    // LuaValToCSVal string with default
    Il2CppString* p7 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 7);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, struct S_r4r4r4_ p4, struct S_r4r4r4r4_ p5, int8_t p6, Il2CppString* p7, Il2CppString* p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.BaseAsset GetPooledGameObjLOD(System.String, Boolean, SceneObjType, UnityEngine.Vector3, Assets.Scripts.Framework.AssetService.LifeType, System.String) declare in SceneMgr
bool w_otsbi4S_r4r4r4_i1Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsbi4S_r4r4r4_i1Ds");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int8_t p4 = converter::Converter<int8_t>::toCpp(apis, env, _sv4);
    // LuaValToCSVal string with default
    Il2CppString* p5 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 5);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, bool p2, int32_t p3, struct S_r4r4r4_ p4, int8_t p5, Il2CppString* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.UIHPBarAsset LoadUIHPBarAsset(System.String, Assets.Scripts.Framework.AssetService.LifeType, Assets.Scripts.Framework.AssetService.UI3DAssetParam) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_otsi1S_S_r4r4r4_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi1S_S_r4r4r4_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal struct
    S_S_r4r4r4_o_* pp2 = DataTransfer::GetPointer<S_S_r4r4r4_o_>(apis, env, _sv2);
    S_S_r4r4r4_o_ p2 = pp2 ? *pp2 : S_S_r4r4r4_o_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int8_t p2, struct S_S_r4r4r4_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] GetMember(System.String, System.Reflection.BindingFlags) declare in System.Type
bool w_otsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(System.String, Int32, System.StringSplitOptions) declare in System.String
bool w_otsi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] GetMember(System.String, System.Reflection.MemberTypes, System.Reflection.BindingFlags) declare in System.Type
bool w_otsi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Reflection.BindingFlags, System.Reflection.Binder, System.Reflection.CallingConventions, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4i4oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4i4oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4i4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4i4ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Type[]) declare in System.Type
bool w_otsi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Reflection.CallingConventions, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, int32_t p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, Int32, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.PropertyInfo GetProperty(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsi4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsi4oooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Type[]) declare in System.Type
bool w_otso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass LoadLuaChildPrefab(System.String, UnityEngine.Transform, System.Object, Boolean) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otsoDODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass AsyncLoadLuaChildPrefab(System.String, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UILuaPrefabClass]) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otsoDODbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDODbDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// TimelineRuntime.Timeline PlayTimelineWithMultiActor(System.String, System.Collections.Generic.Dictionary`2[System.String,System.Collections.Generic.List`1[UnityEngine.Transform]], UnityEngine.GameObject) declare in TimelineRuntime.TimelineService
bool w_otsoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// TimelineRuntime.Timeline PlayTimeline(System.String, System.Collections.Generic.Dictionary`2[System.String,UnityEngine.GameObject], TimelineRuntime.TimelineHandler, UnityEngine.GameObject, TimelineRuntime.ClipDataSampleDelegate) declare in TimelineRuntime.TimelineService
bool w_otsoDoDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoDoDoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);    // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass LoadLuaChildPrefab(System.String, UnityEngine.Transform, System.Object, Boolean, UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otsoObS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoObS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv4);
    S_r4r4r4_ p4 = pp4 ? *pp4 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, struct S_r4r4r4_ p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass AsyncLoadLuaChildPrefab(System.String, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UILuaPrefabClass], UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIPrefab2DClass
bool w_otsoOboS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoOboS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, struct S_r4r4r4_ p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MethodInfo GetMethod(System.String, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.PropertyInfo GetProperty(System.String, System.Type, System.Type[], System.Reflection.ParameterModifier[]) declare in System.Type
bool w_otsooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AnimationState CrossFadeQueued(System.String, Single) declare in UnityEngine.Animation
bool w_otsr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AnimationState CrossFadeQueued(System.String, Single, UnityEngine.QueueMode) declare in UnityEngine.Animation
bool w_otsr4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsr4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AnimationState CrossFadeQueued(System.String, Single, UnityEngine.QueueMode, UnityEngine.PlayMode) declare in UnityEngine.Animation
bool w_otsr4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otsr4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, float p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileInfo Replace(System.String, System.String) declare in System.IO.FileInfo
bool w_otss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileInfo Replace(System.String, System.String, Boolean) declare in System.IO.FileInfo
bool w_otssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otssb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Replace(System.String, System.String, Int32, Int32) declare in System.Text.StringBuilder
bool w_otssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otssi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Byte) declare in System.Text.StringBuilder
bool w_otu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,uint8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(UInt16) declare in System.Text.StringBuilder
bool w_otu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,uint16_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.GameLogic.Project8EquipPropItemData] GetEquipPropItemDataListById(UInt16, UInt32) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_otu2Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu2Du4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    uint32_t p1 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,uint16_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GameObject GetAuctionItemUIGo(UInt32) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_otu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SkillHurtInfoParam[] GetActorDamagePropertyArray(UInt32, Int32) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_otu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// WaitCheckSeqDone WaitForCanWearEquipItems(UInt32, System.Collections.Generic.List`1[Assets.Scripts.UI.InTheGame.Common.UIEquipCommonItem+EquipWithActor]) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_otu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset CreateUnityObject(UInt32, System.String, System.String, Boolean, Boolean, UInt32) declare in UnityObjMgr
bool w_otu4ssbbu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4ssbbu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, Il2CppString* p2, Il2CppString* p3, bool p4, bool p5, uint32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setId(UInt32, UInt32) declare in LTDescr
bool w_otu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// WaitCheckSeqDone WaitForCanTakeOffEquip(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_otu4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// WaitCheckSeqDone WaitForCanWearEquip(UInt32, UInt32, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_otu4u4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4DbDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.UI.InGameCommon.UIPropData+HeroPropPanelItemData] GetHeroPropList(UInt32, UInt32, Boolean, Int32, Int32, UInt32[]) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_otu4u4bi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4bi4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, int32_t p4, int32_t p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameSystem.FloatRunInfo GetFloatRunInfo(UInt32, UInt32, Assets.Scripts.GameSystem.FLOAT_TYPE, Int32) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_otu4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator UpgradeEquip(UInt32, UInt32, UInt32, UInt32) declare in Assets.Scripts.GameSystem.UIComponentEquip
bool w_otu4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu4u4u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppObject* (*FuncToCall)(void*,uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(UInt64) declare in System.Text.StringBuilder
bool w_otu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otu8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(void*,uint64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Project8PlayerInstance GetPlayerInstance(UInt32) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// ResData.ResChessLevelModelCfg GetChessLevelModelCfg(UInt32, Int32) declare in PBData.PBDataAux
bool w_ou4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// ResData.ResLordSkillDataBin GetSkill(UInt32, UInt32) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_ou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppObject* (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AkChannelConfig GetSpeakerConfiguration(UInt64) declare in AkSoundEngine
bool w_ou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ou8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppObject* (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IntPtr SGameGetExtraCrashLoggerExport() declare in SGamePInvoke
bool w_p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_p");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);
	int r = apis->create_binary(env, ret, 0);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IntPtr op_Explicit(CurlUnity.CurlEasy) declare in CurlUnity.CurlEasy
bool w_po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_po");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef void* (*FuncToCall)(Il2CppObject* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = apis->create_binary(env, ret, 0);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IntPtr GetNativeDepthBufferPtr() declare in UnityEngine.RenderTexture
bool w_pt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_pt");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = apis->create_binary(env, ret, 0);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single get_dpi() declare in UnityEngine.Screen
bool w_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.Object) declare in System.Convert
bool w_r4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef float (*FuncToCall)(Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.Object, System.IFormatProvider) declare in System.Convert
bool w_r4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.Decimal) declare in System.Convert
bool w_r4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef float (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetParticleCurveMax(MinMaxCurve) declare in Assets.Scripts.Framework.UI.TimiEffectLoader
bool w_r4S_i4r4oor4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_i4r4oor4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4r4oor4r4_* pp0 = DataTransfer::GetPointer<S_i4r4oor4r4_>(apis, env, _sv0);
    S_i4r4oor4r4_ p0 = pp0 ? *pp0 : S_i4r4oor4r4_ {};
        
    typedef float (*FuncToCall)(struct S_i4r4oor4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SqrMagnitude(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Dot(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_r4S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Magnitude(UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_r4S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Magnitude(UnityEngine.Vector4) declare in UnityEngine.Vector4
bool w_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Dot(UnityEngine.Quaternion, UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_r4S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_r4r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef float (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetActorHudHeight(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_r4S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef float (*FuncToCall)(struct S_u4o_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.DateTime) declare in System.Convert
bool w_r4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef float (*FuncToCall)(struct S_u8_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single Min(Single[]) declare in UnityEngine.Mathf
bool w_r4Vr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4Vr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<float>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef float (*FuncToCall)(Il2CppArray* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Boolean) declare in System.Convert
bool w_r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(bool p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Char) declare in System.Convert
bool w_r4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(Il2CppChar p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(SByte) declare in System.Convert
bool w_r4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int8_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Int16) declare in System.Convert
bool w_r4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Int32) declare in System.Convert
bool w_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Int64) declare in System.Convert
bool w_r4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(int64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single RecordLayoutHeight(UnityEngine.MonoBehaviour) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef float (*FuncToCall)(Il2CppObject* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single tweenOnCurve(LTDescr, Single) declare in LeanTween
bool w_r4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4or4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ValidtionVal(Single) declare in com.pixui.PxMisc
bool w_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single FocalLengthToFieldOfView(Single, Single) declare in UnityEngine.Camera
bool w_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(float p1, float p2, float* p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);

    typedef float (*FuncToCall)(float p1, float p2, float* p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SmoothDamp(Single, Single, Single ByRef, Single, Single, Single) declare in UnityEngine.Mathf
bool w_r4r4r4Pr4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4Pr4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef float (*FuncToCall)(float p1, float p2, float* p3, float p4, float p5, float p6, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeOutQuadOpt(Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(float p1, float p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeInBack(Single, Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeInElastic(Single, Single, Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4Dr4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single TweenLerp(Single, Single, Single, LeanTweenType) declare in LeanTweenExt
bool w_r4r4r4r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(float p1, float p2, float p3, int32_t p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single easeInOutQuadOpt2(Single, Single, Single, Single) declare in LeanTween
bool w_r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Double) declare in System.Convert
bool w_r4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(double p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(System.String) declare in System.Convert
bool w_r4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef float (*FuncToCall)(Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetTextCalculateHeight(System.String, Boolean, Single, Int32, Single) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_r4sbr4Di4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sbr4Di4Dr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef float (*FuncToCall)(Il2CppString* p1, bool p2, float p3, int32_t p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetTextCalculateWidth(System.String, ShrinkText) declare in ShrinkText
bool w_r4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef float (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetTextCalculateHeight(System.String, ShrinkText, Single) declare in ShrinkText
bool w_r4sor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sor4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetFloat(System.String, Single) declare in UnityEngine.PlayerPrefs
bool w_r4sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4sr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetWidth(UnityEngine.RectTransform) declare in ExtRectTransform
bool w_r4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SqrDistance(UnityEngine.Vector3) declare in UnityEngine.Bounds
bool w_r4tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef float (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single get_Item(Int32) declare in UnityEngine.Vector3
bool w_r4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SetAnimation(Int32, System.String, Boolean) declare in UnityEngine.UnitySkeletonGraphic
bool w_r4ti4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ti4sb");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetLength(UnityEngine.RectTransform, Boolean) declare in UIWidgets.EasyLayout
bool w_r4toDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4toDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef float (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single PlayNewCardBetween(OSProto.InteractiveEffectInfo, RectRtRecord ByRef, RectRtRecord ByRef, UnityEngine.Vector3, System.Action, Boolean, InteractiveLocal) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_r4toPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_PS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_S_r4r4r4_obo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4toPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_PS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_S_r4r4r4_obo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p2 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef float (*FuncToCall)(void*,Il2CppObject* p1, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p2, struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p3, struct S_r4r4r4_ p4, Il2CppObject* p5, bool p6, Il2CppObject* p7, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single SetSkeletonDataAsset(UnityEngine.UnitySkeletonDataAsset, System.String, Boolean) declare in UIWidgets.UISpine
bool w_r4tosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tosb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef float (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetRealOffsetValue(Single, Single) declare in Moba_Camera
bool w_r4tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tr4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef float (*FuncToCall)(void*,float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetAnimationRunTime(System.String) declare in Timi.TimiAnimation
bool w_r4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4ts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef float (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetPreferredWidth(System.String, UnityEngine.TextGenerationSettings ByRef) declare in UnityEngine.TextGenerator
bool w_r4tsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsPS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p1 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetPreferredWidth(System.String, UnityEngine.TextGenerationSettings) declare in UnityEngine.TextGenerator
bool w_r4tsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* pp1 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(apis, env, _sv1);
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p1 = pp1 ? *pp1 : S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ {};
        
    typedef float (*FuncToCall)(void*,Il2CppString* p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ExtCrossFade(UnityEngine.Animation, System.String, Single, Single, Single) declare in ExtAnimation
bool w_r4tsr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tsr4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef float (*FuncToCall)(void*,Il2CppString* p1, float p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single GetActorHudHeight(UInt32) declare in Assets.Scripts.GameLogic.ActorManager
bool w_r4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(void*,uint32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(Byte) declare in System.Convert
bool w_r4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint8_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(UInt16) declare in System.Convert
bool w_r4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint16_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(UInt32) declare in System.Convert
bool w_r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single ToSingle(UInt64) declare in System.Convert
bool w_r4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef float (*FuncToCall)(uint64_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<float>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double get_timeAsDouble() declare in UnityEngine.Time
bool w_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.Object) declare in System.Convert
bool w_r8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef double (*FuncToCall)(Il2CppObject* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.Object, System.IFormatProvider) declare in System.Convert
bool w_r8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef double (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.Decimal) declare in System.Convert
bool w_r8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef double (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.DateTime) declare in System.Convert
bool w_r8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef double (*FuncToCall)(struct S_u8_ p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Boolean) declare in System.Convert
bool w_r8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(bool p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Char) declare in System.Convert
bool w_r8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(Il2CppChar p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(SByte) declare in System.Convert
bool w_r8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int8_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Int16) declare in System.Convert
bool w_r8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int16_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Int32) declare in System.Convert
bool w_r8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Int64) declare in System.Convert
bool w_r8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(int64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Single) declare in System.Convert
bool w_r8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(float p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Double) declare in System.Convert
bool w_r8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(double p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.String) declare in System.Convert
bool w_r8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef double (*FuncToCall)(Il2CppString* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(System.String, System.IFormatProvider) declare in System.Convert
bool w_r8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef double (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToOADate() declare in System.DateTime
bool w_r8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(Byte) declare in System.Convert
bool w_r8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint8_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(UInt16) declare in System.Convert
bool w_r8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint16_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(UInt32) declare in System.Convert
bool w_r8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Double ToDouble(UInt64) declare in System.Convert
bool w_r8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_r8u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef double (*FuncToCall)(uint64_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<double>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetLanguageName() declare in Localize
bool w_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppString* (*FuncToCall)(const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String AddGoldCoinInBattle(ResData.CountableAssetType, Int32) declare in CheatCommandBattleEntry
bool w_sDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sDi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String AddLordSkillExpInBattle(UInt32) declare in CheatCommandBattleEntry
bool w_sDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sDu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    uint32_t p0 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Object) declare in System.Convert
bool w_sO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object, System.Object) declare in System.String
bool w_sOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object, System.Object, System.Object) declare in System.String
bool w_sOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object, System.Object, System.Object, System.Object, ...) declare in System.String
bool w_sOOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Object, System.IFormatProvider) declare in System.Convert
bool w_sOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sOo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String deserialize_string(Byte* ByRef) declare in SGW
bool w_sPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
 
    // LuaValToCSVal P not primitive
    uint8_t** p0 = nullptr;

    typedef Il2CppString* (*FuncToCall)(uint8_t** p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret0 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(System.ReadOnlySpan`1[System.Byte], System.Base64FormattingOptions) declare in System.Convert
bool w_sS_S_p_i4_Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_sS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             
    // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_S_p_i4_S_S_p_i4_S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             
    // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             
    // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Decimal) declare in System.Convert
bool w_sS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.Decimal, System.IFormatProvider) declare in System.Convert
bool w_sS_i4i4i4i4u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_i4i4i4i4u8_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_i4i4i4i4u8_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToHtmlStringRGB(UnityEngine.Color) declare in UnityEngine.ColorUtility
bool w_sS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.DateTime) declare in System.Convert
bool w_sS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.DateTime, System.IFormatProvider) declare in System.Convert
bool w_sS_u8_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sS_u8_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(struct S_u8_ p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.Object[]) declare in System.String
bool w_sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

    }
    // LuaValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.String[]) declare in System.String
bool w_sVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
     // LuaValToCSVal string params
    Il2CppArray* p0 = Params<void*>::PackString(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(Byte[]) declare in System.Convert
bool w_sa(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sa");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(Byte[], System.Base64FormattingOptions) declare in System.Convert
bool w_sai4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sai4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(Byte[], Int32, Int32) declare in System.Convert
bool w_sai4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sai4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToBase64String(Byte[], Int32, Int32, System.Base64FormattingOptions) declare in System.Convert
bool w_sai4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sai4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SaveToFile(Byte[], System.String) declare in FileUtils
bool w_sas(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sas");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String DumpAnimationProfileInfo(Boolean) declare in UnityEngine.Animation
bool w_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(bool p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Boolean, System.IFormatProvider) declare in System.Convert
bool w_sbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sbo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(bool p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetCachePath(Boolean, System.String) declare in MultifunctionRawImage
bool w_sbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sbs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(bool p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Char) declare in System.Convert
bool w_sc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(Char, System.Object[]) declare in System.String
bool w_scVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(Char, System.String[]) declare in System.String
bool w_scVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
     // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Char, System.IFormatProvider) declare in System.Convert
bool w_sco(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sco");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(Char, System.String[], Int32, Int32) declare in System.String
bool w_scoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_scoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppChar p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(SByte) declare in System.Convert
bool w_si1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int8_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(SByte, System.IFormatProvider) declare in System.Convert
bool w_si1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si1o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int8_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int16) declare in System.Convert
bool w_si2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int16, Int32) declare in System.Convert
bool w_si2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int16_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int16, System.IFormatProvider) declare in System.Convert
bool w_si2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si2o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int16_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTimelineSceneCameraTrackName(CameraCategory) declare in ScreenFitConfig
bool w_si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SelectedIndexToKey(Int32, Int32) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_si4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetWindowsDeviceName(Int32, UInt32 ByRef) declare in AkSoundEngine
bool w_si4Tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4Tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef Il2CppString* (*FuncToCall)(int32_t p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetWindowsDeviceName(Int32, UInt32 ByRef, AkAudioDeviceState) declare in AkSoundEngine
bool w_si4Tu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4Tu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, void* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Project8ClearEquip(Int32, Boolean) declare in CheatCommandBattleEntry
bool w_si4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFractionString(Int32, Int32) declare in Localize
bool w_si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SpawnProject8Hero(Int32, Int32, Int32) declare in CheatCommandBattleEntry
bool w_si4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SpawnProject8Enemy(Int32, Int32, Int32, Int32) declare in CheatCommandBattleEntry
bool w_si4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String PickCard(Int32, OSProto.CardPileType, System.String, Int32, Int32) declare in CheatCommandBattleEntry
bool w_si4i4si4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4i4si4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
 // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppString* (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int32, System.IFormatProvider) declare in System.Convert
bool w_si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int64) declare in VersionInfo
bool w_si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(int64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int64, Int32) declare in System.Convert
bool w_si8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int64_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Int64, System.IFormatProvider) declare in System.Convert
bool w_si8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(int64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String DateTimeFormat(Int64, System.String) declare in Utility
bool w_si8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_si8s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(int64_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetPathMethod(System.Type) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_so");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ParseDynamicDescContent(OSProto.DynamicDescContent, Int32) declare in Assets.Scripts.GameLogic.ExtSyncDynamicDesc
bool w_soDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetName(System.Type, System.Object) declare in System.Enum
bool w_soO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.Type, System.Object, System.String) declare in System.Enum
bool w_soOs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soOs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetAnimNameByIndex(UnityEngine.Animation, Int32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetCurPlayingAnimationName(UnityEngine.Animation, UnityEngine.Animator) declare in LuaCallCSharpInteraction
bool w_soo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_soo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetGoFullPathRelatively(UnityEngine.GameObject, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_sos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object) declare in System.String
bool w_sosO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object) declare in System.String
bool w_sosOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object, System.Object, System.Object) declare in System.String
bool w_sosOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.IFormatProvider, System.String, System.Object[]) declare in System.String
bool w_sosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sosVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String StringFromIntPtrString(IntPtr) declare in AkSoundEngine
bool w_sp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sp");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFloat2String(Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(float p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Single, System.IFormatProvider) declare in System.Convert
bool w_sr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(float p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Double) declare in System.Convert
bool w_sr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(double p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Double, System.IFormatProvider) declare in System.Convert
bool w_sr8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sr8o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(double p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetHashPath(System.String) declare in com.pixui.PxMisc
bool w_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetDirectory(System.String, Boolean) declare in CFileManager
bool w_ssDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFullPathInResources(System.String, System.String) declare in CFileManager
bool w_ssDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.String, System.Object) declare in System.String
bool w_ssO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.String, System.Object, System.Object) declare in System.String
bool w_ssOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Format(System.String, System.Object, System.Object, System.Object) declare in System.String
bool w_ssOOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssOOO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetString(System.String, System.Object[]) declare in Localize
bool w_ssVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.String, System.String[]) declare in System.String
bool w_ssVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetFixedPlayerName(System.String, Int32) declare in Assets.Scripts.GameSystem.UIComponentPlayerRank
bool w_ssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.String, System.IFormatProvider) declare in System.Convert
bool w_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Join(System.String, System.String[], Int32, Int32) declare in System.String
bool w_ssoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceCalculateValue(System.String, Int32[], UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssou4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssou4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetCombineStr(System.String, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceDescWithParams(System.String, System.String, System.String, UInt32, UInt32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_sssDsDu4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssDsDu4Du4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, uint32_t p4, uint32_t p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator) declare in System.Text.RegularExpressions.Regex
bool w_ssso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions) declare in System.Text.RegularExpressions.Regex
bool w_sssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_sssoi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssoi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
     
    // LuaValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, struct S_i8_ p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.String, System.String, System.String) declare in System.String
bool w_ssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions) declare in System.Text.RegularExpressions.Regex
bool w_ssssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_ssssi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
     
    // LuaValToCSVal struct
    S_i8_* pp4 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv4);
    S_i8_ p4 = pp4 ? *pp4 : S_i8_ {};
        
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int32_t p4, struct S_i8_ p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Concat(System.String, System.String, System.String, System.String) declare in System.String
bool w_sssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String FormatOpt(System.String, System.String, System.String, System.String, System.String) declare in StringHelper
bool w_ssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String FormatOpt(System.String, System.String, System.String, System.String, System.String, System.String) declare in StringHelper
bool w_sssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sssssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);    // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String FormatOpt(System.String, System.String, System.String, System.String, System.String, System.String, System.String) declare in StringHelper
bool w_ssssssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssssssss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    auto TIp5 = wrapData->TypeInfos[6];
    auto TIp6 = wrapData->TypeInfos[7];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);    // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);    // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppString* p5, Il2CppString* p6, Il2CppString* p7, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceOutSkillDesc(System.String, UInt32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceSkillLevelUpTips(System.String, UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceInSkillDesc(System.String, UInt32, Int32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceRelativeDesc(System.String, UInt32, UInt32) declare in Assets.Scripts.GameLogic.SkillDescHelper
bool w_ssu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ssu4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(Il2CppString* p1, uint32_t p2, uint32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Ptr2Str(IntPtr) declare in com.pixui.PxMisc
bool w_st(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_st");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppString* (*FuncToCall)(void*,const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetBattleArtPrefabName(Int32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_stDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Available(System.String) declare in BoxSDK.BoxSDKService
bool w_stDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetEnumName(System.Object) declare in System.Type
bool w_stO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Trim(Char[]) declare in System.String
bool w_stVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stVc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ReplaceCardObjDesc(OSProto.SyncCardObjDynamicDesc, Boolean, UInt32, System.String) declare in Assets.Scripts.GameLogic.ExtSyncDynamicDesc
bool w_stbu4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stbu4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,bool p1, uint32_t p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Trim(Char) declare in System.String
bool w_stc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(Char, Char) declare in System.String
bool w_stcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stcc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetLifeName(Assets.Scripts.Framework.AssetService.LifeType, System.String) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_sti1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti1s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(void*,int8_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetSpinePath(Int32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_sti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetBattleArtPrefabNameEditor(UnityEngine.RuntimePlatform, Int32, Int32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_sti4Di4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4Di4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String PadLeft(Int32, Char) declare in System.String
bool w_sti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4c");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, Il2CppChar p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetBattlePrefab(Int32, ModelLevelDefine) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_sti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetHeroPropValueStr(Int32, Int32, UInt32, Boolean) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_sti4i4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4i4u4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, int32_t p2, uint32_t p3, bool p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Insert(Int32, System.String) declare in System.String
bool w_sti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetHangPointRelativePath(OSProto.HangUIType, UInt32) declare in Assets.Scripts.GameSystem.UIComponentArtEffect
bool w_sti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sti4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetRelativePath(UnityEngine.Transform, UnityEngine.Transform) declare in ExtTransform
bool w_sto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sto");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetOutputText(System.String) declare in ShrinkText
bool w_sts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_sts");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Get(System.String, System.String) declare in Assets.Scripts.Update.GCloudConfig+KeyValueConfig
bool w_stsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String TranslateLodFileName(System.String, Effect.EffectLoadErrorCode ByRef, DepDisconnectedAssetInfoRuntimeData ByRef) declare in Effect.EffectLODAdaptor
bool w_stsTi4To(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsTi4To");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, void* p2, void* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetVideoKeyHash(System.String, System.String ByRef) declare in BoxSDK.BoxSDKService
bool w_stsTs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsTs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, void* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTag(System.String, Boolean) declare in UnityEngine.Material
bool w_stsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTag(System.String, Boolean, System.String) declare in UnityEngine.Shader
bool w_stsbDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsbDs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetTag(System.String, Boolean, System.String) declare in UnityEngine.Material
bool w_stsbs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsbs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppString* p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetPathWithLodPostfix(System.String, Int32, Boolean) declare in SceneMgr
bool w_stsi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetProject8DynamicMatPath(System.String, ResData.PLAYMOD_TYPE, UInt32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_stsi4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsi4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, uint32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(System.String, System.IFormatProvider) declare in UnityEngine.Vector3
bool w_stso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, Int32, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stsoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stsoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String) declare in System.String
bool w_stss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_stssbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssbo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, System.StringComparison) declare in System.String
bool w_stssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Replace(System.String, System.String, Int32, Int32) declare in System.Text.RegularExpressions.Regex
bool w_stssi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stssi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef Il2CppString* (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetProject8ExtraClipsFilePath(UInt32) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_stu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetSkillDesc(UInt32, Int32) declare in Assets.Scripts.GameLogic.SeasonData
bool w_stu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_stu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Byte) declare in System.Convert
bool w_su1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint8_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Byte, Int32) declare in System.Convert
bool w_su1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint8_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(Byte, System.IFormatProvider) declare in System.Convert
bool w_su1o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su1o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint8_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt16) declare in System.Convert
bool w_su2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint16_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt16, System.IFormatProvider) declare in System.Convert
bool w_su2o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su2o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint16_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetInt2String(UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SetHP(UInt32, Int32) declare in CheatCommandBattleEntry
bool w_su4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint32_t p1, int32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String Project8TestPlayerAIBpTest(UInt32, Int32, Int32) declare in CheatCommandBattleEntry
bool w_su4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef Il2CppString* (*FuncToCall)(uint32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt32, System.IFormatProvider) declare in System.Convert
bool w_su4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetLordBattleArtPrefabName(UInt32, UInt32) declare in Assets.Scripts.GameLogic.OSGBattleLoader
bool w_su4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String SpawnProject8Equip(UInt32, UInt32, Boolean) declare in CheatCommandBattleEntry
bool w_su4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su4u4Db");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppString* (*FuncToCall)(uint32_t p1, uint32_t p2, bool p3, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt64) declare in System.Convert
bool w_su8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef Il2CppString* (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String ToString(UInt64, System.IFormatProvider) declare in System.Convert
bool w_su8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef Il2CppString* (*FuncToCall)(uint64_t p1, Il2CppObject* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String GetUtcToLocalTimeStringFormat(UInt64, System.String) declare in Utility
bool w_su8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_su8s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppString* (*FuncToCall)(uint64_t p1, Il2CppString* p2, const void* method);
    Il2CppString* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppString*>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte get_AK_INTERLEAVED() declare in AkSoundEngine
bool w_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint8_t (*FuncToCall)(const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.Object) declare in System.Convert
bool w_u1O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u1Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.Decimal) declare in System.Convert
bool w_u1S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.DateTime) declare in System.Convert
bool w_u1S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint8_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Boolean) declare in System.Convert
bool w_u1b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(bool p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Char) declare in System.Convert
bool w_u1c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(SByte) declare in System.Convert
bool w_u1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Int16) declare in System.Convert
bool w_u1i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int16_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Int32) declare in System.Convert
bool w_u1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Int64) declare in System.Convert
bool w_u1i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(int64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Single) declare in System.Convert
bool w_u1r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(float p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Double) declare in System.Convert
bool w_u1r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(double p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.String) declare in System.Convert
bool w_u1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint8_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.String, Int32) declare in System.Convert
bool w_u1si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(System.String, System.IFormatProvider) declare in System.Convert
bool w_u1so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint8_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte GetPhaseType() declare in Assets.Scripts.GameLogic.Project8RoundStateFlow
bool w_u1t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint8_t (*FuncToCall)(void*,const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(Byte) declare in System.Convert
bool w_u1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint8_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(UInt16) declare in System.Convert
bool w_u1u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint16_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(UInt32) declare in System.Convert
bool w_u1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint32_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ChannelBitToIndex(UInt32, UInt32) declare in AkSoundEngine
bool w_u1u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint8_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte ToByte(UInt64) declare in System.Convert
bool w_u1u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u1u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint8_t (*FuncToCall)(uint64_t p1, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 get_AK_INT() declare in AkSoundEngine
bool w_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint16_t (*FuncToCall)(const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.Object) declare in System.Convert
bool w_u2O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u2Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.Decimal) declare in System.Convert
bool w_u2S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.DateTime) declare in System.Convert
bool w_u2S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint16_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Boolean) declare in System.Convert
bool w_u2b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(bool p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Char) declare in System.Convert
bool w_u2c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(SByte) declare in System.Convert
bool w_u2i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int8_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Int16) declare in System.Convert
bool w_u2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Int32) declare in System.Convert
bool w_u2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Int64) declare in System.Convert
bool w_u2i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(int64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Single) declare in System.Convert
bool w_u2r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(float p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Double) declare in System.Convert
bool w_u2r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(double p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.String) declare in System.Convert
bool w_u2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint16_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.String, Int32) declare in System.Convert
bool w_u2si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(System.String, System.IFormatProvider) declare in System.Convert
bool w_u2so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint16_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(Byte) declare in System.Convert
bool w_u2u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint8_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(UInt16) declare in System.Convert
bool w_u2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint16_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(UInt32) declare in System.Convert
bool w_u2u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint32_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt16 ToUInt16(UInt64) declare in System.Convert
bool w_u2u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u2u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint16_t (*FuncToCall)(uint64_t p1, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetWatchPlayerId() declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint32_t (*FuncToCall)(const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.Object) declare in System.Convert
bool w_u4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.Decimal) declare in System.Convert
bool w_u4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetPlayerId(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_u4S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_u4o_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.DateTime) declare in System.Convert
bool w_u4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint32_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Boolean) declare in System.Convert
bool w_u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(bool p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Char) declare in System.Convert
bool w_u4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(SByte) declare in System.Convert
bool w_u4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int8_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Int16) declare in System.Convert
bool w_u4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Int32) declare in System.Convert
bool w_u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ConvertToUnixTimestamp(Int32, Int32, Int32, Int32, Int32, Int32) declare in Utility
bool w_u4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef uint32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 StdChannelIndexToDisplayIndex(AkChannelOrdering, UInt32, UInt32) declare in AkSoundEngine
bool w_u4i4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i4u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Int64) declare in System.Convert
bool w_u4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(int64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetPlayerId(Assets.Scripts.GameLogic.Project8PlayerInstance) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 DynamicSequenceOpen(UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4ou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 DynamicSequenceOpen(UnityEngine.GameObject, UInt32, EventCallback, System.Object, AkDynamicSequenceType) declare in AkSoundEngine
bool w_u4ou4oOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ou4oOi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef uint32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 OSG_PopOutputBuffer(IntPtr, Int32) declare in SGamePInvoke
bool w_u4pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Single) declare in System.Convert
bool w_u4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(float p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Double) declare in System.Convert
bool w_u4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(double p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.String) declare in System.Convert
bool w_u4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint32_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ReadFile(System.String, Byte[], UInt32) declare in CFileManager
bool w_u4sau4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sau4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.String, Int32) declare in System.Convert
bool w_u4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(System.String, System.IFormatProvider) declare in System.Convert
bool w_u4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4sou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4sou4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4sou4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4sou4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CompressFile(System.String, System.String, Byte[], UInt32) declare in CFileManager
bool w_u4ssau4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ssau4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, uint32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64) declare in AkSoundEngine
bool w_u4su8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4su8u4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8u4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4su8u4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8u4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(System.String, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4su8u4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4su8u4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);

    typedef uint32_t (*FuncToCall)(Il2CppString* p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 get_SvrFrameDelta() declare in Assets.Scripts.Framework.FrameSynchr
bool w_u4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetRepickCardCost(Boolean) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_u4tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tDb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef uint32_t (*FuncToCall)(void*,bool p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroObjId(Int32) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_u4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetOnFightHeroId(Int32, Int32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_u4ti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4Di4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetBattleHeroByCoord(Int32, Int32, UInt32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_u4ti4i4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4i4Du4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddNotice(Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeStyle, System.String, System.String, Boolean, Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeType, Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeEnergy, Boolean) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4ti4sDsDbDi4DoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ti4sDsDbDi4DoDb");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (lua_args_len > 6 && !converter::Converter<bool>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5); // LuaValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef uint32_t (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, Il2CppString* p3, bool p4, int32_t p5, Il2CppObject* p6, bool p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddNotice(Assets.Scripts.UI.GameBanner.Item.GameBannerNoticeItem) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBannerNoticeGroup
bool w_u4to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4to");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayHeroActSound(System.String) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4ts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayBattleSound2D(System.String, Int32) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsDo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayLogicSound(System.String, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], UnityEngine.GameObject, Boolean, Int32) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsS_u4o_obDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsS_u4o_obDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
 // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, struct S_u4o_ p2, Il2CppObject* p3, bool p4, int32_t p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PlayBattleSound(System.String, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], UnityEngine.GameObject, Boolean, Boolean, Int32) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsS_u4o_obbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsS_u4o_obbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
 // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, struct S_u4o_ p2, Il2CppObject* p3, bool p4, bool p5, int32_t p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, Boolean, UInt32, EventCallback, System.Object) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsobu4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsobu4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, bool p3, uint32_t p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(System.String, UInt32, EventCallback, System.Object) declare in Assets.Scripts.Sound.CSoundManager
bool w_u4tsu4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tsu4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef uint32_t (*FuncToCall)(void*,Il2CppString* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetAuctionItemUniqueId(UInt32) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_u4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroObjId(UInt32, Int32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_u4tu4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4Di4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 Play(UInt32, System.Collections.Generic.Dictionary`2[System.UInt32,System.Int32], Int32) declare in Assets.Scripts.Sound.PlayBroadcastManager
bool w_u4tu4DoDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4DoDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetHeroObjId(UInt32, VInt2) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_u4tu4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, struct S_i4i4_ p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddOSHQuitNotice(UInt32, Assets.Scripts.UI.InTheGame.PlayerRank.OSHQuitType) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4tu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CanWearEquipItems(UInt32, UInt32[]) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_u4tu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddWinnerNotice(UInt32, System.String, Boolean) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4tu4sDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4sDb");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1); // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, Il2CppString* p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 EnsurePerformSceneId(UInt32, UInt32) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_u4tu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CombineEquipment(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameSystem.Project8EquipmentRecipe
bool w_u4tu4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CanTakeOffEquip(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_u4tu4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 CanWearEquip(UInt32, UInt32, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_u4tu4u4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4bb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, bool p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 AddHighlightNotice(UInt32, UInt32, Boolean, UInt32, Boolean) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_u4tu4u4bu4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4bu4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
 // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, uint32_t p4, bool p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 EnsurePerformSkinIndex(UInt32, UInt32, UInt32, ResData.ActorType) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_u4tu4u4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu4u4u4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, uint32_t p3, int32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetPlayerObjId(UInt64) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_u4tu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4tu8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(void*,uint64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(Byte) declare in System.Convert
bool w_u4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint8_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(UInt16) declare in System.Convert
bool w_u4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint16_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetMatchTarget(UInt32) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_u4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ResolveDialogueEvent(UInt32, UInt32[], UInt32) declare in AkSoundEngine
bool w_u4u4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4u4ou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4u4ou4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEvent(UInt32, UnityEngine.GameObject, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4u4ou4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);

    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ResolveDialogueEvent(UInt32, UInt32[], UInt32, UInt32) declare in AkSoundEngine
bool w_u4u4ou4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4ou4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef uint32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, uint32_t p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 GetLevelGradient(UInt32, UInt32) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64) declare in AkSoundEngine
bool w_u4u4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64, UInt32, EventCallback, System.Object) declare in AkSoundEngine
bool w_u4u4u8u4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8u4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray) declare in AkSoundEngine
bool w_u4u4u8u4oOu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8u4oOu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 PostEventOnRoom(UInt32, UInt64, UInt32, EventCallback, System.Object, UInt32, AkExternalSourceInfoArray, UInt32) declare in AkSoundEngine
bool w_u4u4u8u4oOu4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u4u8u4oOu4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    // LuaValToCSVal P any
    uint32_t p7 = converter::Converter<uint32_t>::toCpp(apis, env, _sv7);

    typedef uint32_t (*FuncToCall)(uint32_t p1, uint64_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, uint32_t p6, Il2CppObject* p7, uint32_t p8, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt32 ToUInt32(UInt64) declare in System.Convert
bool w_u4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint32_t (*FuncToCall)(uint64_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 NowMilliseconds() declare in GCloud.GMall.TimeHelper
bool w_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint64_t (*FuncToCall)(const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.Object) declare in System.Convert
bool w_u8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.Object, System.IFormatProvider) declare in System.Convert
bool w_u8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.Decimal) declare in System.Convert
bool w_u8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.DateTime) declare in System.Convert
bool w_u8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef uint64_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Boolean) declare in System.Convert
bool w_u8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(bool p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Char) declare in System.Convert
bool w_u8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppChar p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(SByte) declare in System.Convert
bool w_u8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int8_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Int16) declare in System.Convert
bool w_u8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int16_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Int32) declare in System.Convert
bool w_u8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 CalcActorSkinHashCode(ResData.ActorType, Int32, UInt32) declare in Assets.Scripts.GameLogic.DataCenter.ActorMeta
bool w_u8i4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i4i4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef uint64_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Int64) declare in System.Convert
bool w_u8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(int64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetAkGameObjectID(UnityEngine.GameObject) declare in AkSoundEngine
bool w_u8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef uint64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Single) declare in System.Convert
bool w_u8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(float p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Double) declare in System.Convert
bool w_u8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(double p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.String) declare in System.Convert
bool w_u8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef uint64_t (*FuncToCall)(Il2CppString* p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.String, Int32) declare in System.Convert
bool w_u8si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(System.String, System.IFormatProvider) declare in System.Convert
bool w_u8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetOutputID(System.String, UInt32) declare in AkSoundEngine
bool w_u8su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8su4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 get_sceneCullingMask() declare in UnityEngine.GameObject
bool w_u8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetUInt64(System.String, UInt64) declare in Assets.Scripts.Update.GCloudConfig+KeyValueConfig
bool w_u8tsDu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tsDu8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    uint64_t p1 = OptionalParameter<uint64_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef uint64_t (*FuncToCall)(void*,Il2CppString* p1, uint64_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetPlayerUid(UInt32) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_u8tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(void*,uint32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetHeroWearScore(UInt32, UInt32) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_u8tu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8tu4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(Byte) declare in System.Convert
bool w_u8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint8_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(UInt16) declare in System.Convert
bool w_u8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint16_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(UInt32) declare in System.Convert
bool w_u8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint32_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 GetOutputID(UInt32, UInt32) declare in AkSoundEngine
bool w_u8u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef uint64_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UInt64 ToUInt64(UInt64) declare in System.Convert
bool w_u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_u8u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);

    typedef uint64_t (*FuncToCall)(uint64_t p1, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<uint64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ManualInitStatic() declare in Assets.Plugins.Common.LogTag
bool w_v(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_v");

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);
    return true;
}
// Void UnloadUnusedAssets(Boolean) declare in CResourceManager
bool w_vDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void MarkMainFunctionExecute(Int32) declare in GCloud.GPM.GPMAgent
bool w_vDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void LoginWithConfirmCode(Int32, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vDi4DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDi4DsDs");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
                // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetCurrentSelectIdx(Int32[]) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_vDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDo");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef void (*FuncToCall)(Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void LoginUI(System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDs");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);
    typedef void (*FuncToCall)(Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void TakeSnapshot(System.String, System.String) declare in Assets.Scripts.Framework.PerfUtils
bool w_vDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDsDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Logout(System.String, System.String, Boolean) declare in GCloud.MSDK.MSDKLogin
bool w_vDsDsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDsDsDb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1); // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void TakeSnapshotNativeAllocation(System.String, System.String, System.Action) declare in Assets.Scripts.Framework.PerfUtils
bool w_vDsDsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vDsDsDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Clear(System.Object) declare in EventRouter
bool w_vO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef void (*FuncToCall)(Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void DebugLog(System.Object, System.String, System.Object[]) declare in Assets.Scripts.Framework.AssetService.AssetServiceUtils
bool w_vOsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vOsVO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void OnActorEnterView(ActorRecoverData ByRef) declare in SGC
bool w_vPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p0 = DataTransfer::GetPointer<S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayBattleSound(SoundParams ByRef) declare in SGC
bool w_vPS_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_* p0 = DataTransfer::GetPointer<S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_S_u8_u4u4u4u1u1u1u1u1S_u8_i4u4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAgeChangeModelParam(ModelParamChangeData ByRef, Boolean) declare in SGC
bool w_vPS_i4u4u4i4S_u8_S_S_u8_r4ooo_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1i4_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4_S_S_u8__S_S_u8__S_S_u8___b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_i4u4u4i4S_u8_S_S_u8_r4ooo_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1i4_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4_S_S_u8__S_S_u8__S_S_u8___b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4u4u4i4S_u8_S_S_u8_r4ooo_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1i4_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4_S_S_u8__S_S_u8__S_S_u8___* p0 = DataTransfer::GetPointer<S_i4u4u4i4S_u8_S_S_u8_r4ooo_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1i4_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4_S_S_u8__S_S_u8__S_S_u8___>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4u4i4S_u8_S_S_u8_r4ooo_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1i4_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4_S_S_u8__S_S_u8__S_S_u8___ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_i4u4u4i4S_u8_S_S_u8_r4ooo_S_S_u8_ou1_S_u1S_r4r4r4_u1r4u1i4_S_S_u8_i4_S_u1S_u8_u1i4_S_i4i4i4i4_S_S_u8__S_S_u8__S_S_u8___* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfSetPathVisibilityProcess(SetPathVisibilityParam ByRef) declare in SGC
bool w_vPS_oS_u8_u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oS_u8_u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oS_u8_u1_* p0 = DataTransfer::GetPointer<S_oS_u8_u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oS_u8_u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oS_u8_u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8AuctionUnlockChange(Project8AuctionUnlockChange ByRef) declare in SGC
bool w_vPS_oaoa_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oaoa_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oaoa_* p0 = DataTransfer::GetPointer<S_oaoa_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oaoa_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oaoa_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8RoundStatisticInfo(Project8RoundStatisticInfoList ByRef) declare in SGC
bool w_vPS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oo_* p0 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfCSRecoverBegin(CSRecoverEndInfo ByRef) declare in SGC
bool w_vPS_oou1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_oou1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oou1_* p0 = DataTransfer::GetPointer<S_oou1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oou1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_oou1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Vector3
bool w_vPS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4_* p1, struct S_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef) declare in UnityEngine.Vector3
bool w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_r4r4r4_PS_r4r4r4_PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
        
    typedef void (*FuncToCall)(struct S_r4r4r4_* p1, struct S_r4r4r4_* p2, struct S_r4r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfEventTriggerLogInfo(EventTriggerLogInfo ByRef) declare in SGC
bool w_vPS_si8ou1oss_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_si8ou1oss_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_si8ou1oss_* p0 = DataTransfer::GetPointer<S_si8ou1oss_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_si8ou1oss_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_si8ou1oss_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8ShowBubble(Project8ShowBubbleParams ByRef) declare in SGC
bool w_vPS_so_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_so_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_so_* p0 = DataTransfer::GetPointer<S_so_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_so_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_so_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef) declare in UnityEngine.Shader
bool w_vPS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_su4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean) declare in UnityEngine.Shader
bool w_vPS_su4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_su4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_su4_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfLoadUnityObjSetTransform(LoadUnityObject ByRef) declare in SGC
bool w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__* p0 = DataTransfer::GetPointer<S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1S_r4r4r4_S_r4r4r4_S_r4r4r4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfCreateActorUnityObj(CreateUnityObject ByRef) declare in SGC
bool w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_* p0 = DataTransfer::GetPointer<S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerRecover(PlayerRecoverInfo ByRef) declare in SGC
bool w_vPS_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__* p0 = DataTransfer::GetPointer<S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u4i4i4i4_S_u4i4i4_S_u4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfStopAnimClip(ActorAnimClipStopParam ByRef) declare in SGC
bool w_vPS_u4S_u8__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8__* p0 = DataTransfer::GetPointer<S_u4S_u8__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayTimeline(PlayTimelineInfo ByRef) declare in SGC
bool w_vPS_u4S_u8_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8_i4_* p0 = DataTransfer::GetPointer<S_u4S_u8_i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8_i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8_i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayAnimClip(ActorAnimClipPlayParam ByRef) declare in SGC
bool w_vPS_u4S_u8_r4i4u1u1r4u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8_r4i4u1u1r4u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8_r4i4u1u1r4u1u1u1_* p0 = DataTransfer::GetPointer<S_u4S_u8_r4i4u1u1r4u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8_r4i4u1u1r4u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8_r4i4u1u1r4u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfLoadFloatTip(LordFloatTipData ByRef) declare in SGC
bool w_vPS_u4S_u8_u4u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4S_u8_u4u4u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_u8_u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4S_u8_u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_u8_u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4S_u8_u4u4u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerOverheadUseEnergy(PlayerOverheadUseEnergyInfo ByRef) declare in SGC
bool w_vPS_u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4_* p0 = DataTransfer::GetPointer<S_u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerPopulationChange(PlayerPopulationChangeInfo ByRef) declare in SGC
bool w_vPS_u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4i4_* p0 = DataTransfer::GetPointer<S_u4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerGoldChange(PlayerGoldChangeInfo ByRef) declare in SGC
bool w_vPS_u4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4i4i4_* p0 = DataTransfer::GetPointer<S_u4i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfOSHPlayerEnergyChange(OSHPlayerEnergyChangeInfo ByRef) declare in SGC
bool w_vPS_u4i4u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4u4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4u4i4_* p0 = DataTransfer::GetPointer<S_u4i4u4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4u4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4u4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfCreatePlayerInstance(PlayerInstanceInfo ByRef) declare in SGC
bool w_vPS_u4i4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4i4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4u4u4_* p0 = DataTransfer::GetPointer<S_u4i4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4i4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void DestroyDynamicComponent(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_vPS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8BossHpAwardAllItems(Project8BossAwardResult ByRef) declare in SGC
bool w_vPS_u4oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4oo_* p0 = DataTransfer::GetPointer<S_u4oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4oo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8AuctionUpdateJoinerList(Project8AuctionJoinerList ByRef) declare in SGC
bool w_vPS_u4ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4ooo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4ooo_* p0 = DataTransfer::GetPointer<S_u4ooo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4ooo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4ooo_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAGEPlayLordAudioProcess(PlayLordAudioParam ByRef) declare in SGC
bool w_vPS_u4u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u1u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u1u1u1u1_* p0 = DataTransfer::GetPointer<S_u4u1u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u1u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u1u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAgePlayAnimTick(ActorAnimTickPlayParam ByRef) declare in SGC
bool w_vPS_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_* p0 = DataTransfer::GetPointer<S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4S_u8_r4i4r4u1u1S_i8i8_u1u1u1u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfShieldChange(stShowActorShieldData ByRef) declare in SGC
bool w_vPS_u4u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4_* p0 = DataTransfer::GetPointer<S_u4u4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorDamage(stShowActorDamageData ByRef) declare in SGC
bool w_vPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorLevelGradientChange(ActorLevelGradientData ByRef) declare in SGC
bool w_vPS_u4u4i4i4i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4i4i4i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4i4i4i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayActorHighLightEffect(HighLightActorInfo ByRef) declare in SGC
bool w_vPS_u4u4ou1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4ou1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4ou1_* p0 = DataTransfer::GetPointer<S_u4u4ou1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4ou1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4ou1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfInitCollision(InitDebugCollision ByRef) declare in SGC
bool w_vPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p0 = DataTransfer::GetPointer<S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfPlayerExtraPublicInfo(stPlayerExtraPublicInfo ByRef) declare in SGC
bool w_vPS_u4u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1_* p0 = DataTransfer::GetPointer<S_u4u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEquipGroupInfoChanged(ActorEquipGroupInfo ByRef) declare in SGC
bool w_vPS_u4u4u1u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u1u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1u4_* p0 = DataTransfer::GetPointer<S_u4u4u1u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u1u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void MoveBeamDurationEnter(MoveBeamDurationInfo ByRef) declare in SGC
bool w_vPS_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_* p0 = DataTransfer::GetPointer<S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_i4i4i4_S_u8_S_u8_u1u1S_i4i4i4_S_i4i4i4_u1u1u1u1u1r4r4u1S_i4i4i4_u1r4r4i4i4u1i4i4i4i4i4i4u1u1u1u1i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfAgePlayAnimDurEnter(ActorAnimDuraPlayParam ByRef) declare in SGC
bool w_vPS_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1u1_* p0 = DataTransfer::GetPointer<S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4S_u8_S_u8_i4r4r4r4r4r4u1u1u1u1u1r4u1u1u1u1u1u1u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfSendInteractLikeBoo(ChatLikeBooInfo ByRef) declare in SGC
bool w_vPS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfSendInteractTips(ChatInteractInfo ByRef) declare in SGC
bool w_vPS_u4u4u4i4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4i4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4i4u4o_* p0 = DataTransfer::GetPointer<S_u4u4u4i4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4i4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4i4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfHuanHuaLingPaiRandom(HuanHuaLingPaiRandomData ByRef) declare in SGC
bool w_vPS_u4u4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4o_* p0 = DataTransfer::GetPointer<S_u4u4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfUseLordEmoji(LordEmojiInfo ByRef) declare in SGC
bool w_vPS_u4u4u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorDead(ActorDeadInfo ByRef) declare in SGC
bool w_vPS_u4u4u4u4u1i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4u4u1i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u1i4u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u1i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u1i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4u4u1i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfBattleBroadcast(Project8BattleBroadcast ByRef) declare in SGC
bool w_vPS_u4u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPS_u4u4u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(struct S_u4u4u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EndSampleByIndex_Logic(Int32 ByRef) declare in Assets.Plugins.Perf.StatsLite
bool w_vPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;

    typedef void (*FuncToCall)(int32_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Add(Assets.Scripts.GameLogic.SceneTriggerType ByRef, Assets.Scripts.GameLogic.SceneTriggerType[]) declare in Assets.Scripts.GameLogic.SceneInteractcs
bool w_vPi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPi4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(int32_t* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ResetInactiveRenderChildren(System.Collections.Generic.List`1[UnityEngine.GameObject] ByRef) declare in Utility
bool w_vPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     // LuaValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ret
    Il2CppObject** p0 = &up0;
        
    typedef void (*FuncToCall)(Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = CSRefToLuaValue(apis, env, TIp0, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8EquipChangedAll(Byte*) declare in SGW
bool w_vPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;

    typedef void (*FuncToCall)(uint8_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ReportFrameFPSData(Byte*, Int32) declare in SGC
bool w_vPu1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(uint8_t* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void AK_SPEAKER_SETUP_FIX_LEFT_TO_CENTER(UInt32 ByRef) declare in AkSoundEngine
bool w_vPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vPu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    uint32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;

    typedef void (*FuncToCall)(uint32_t* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
	int ret0 = converter::Converter<uint32_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfLordMoveSuccess(VInt3) declare in SGC
bool w_vS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
        
    typedef void (*FuncToCall)(struct S_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void set_compositionCursorPos(UnityEngine.Vector2) declare in UnityEngine.Input
bool w_vS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void drawBezierPath(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Transform) declare in LeanTween
bool w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_Dr4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_Dr4Do");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5);
    typedef void (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void RGBToHSV(UnityEngine.Color, Single ByRef, Single ByRef, Single ByRef) declare in UnityEngine.Color
bool w_vS_r4r4r4r4_Tr4Tr4Tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_r4r4r4r4_Tr4Tr4Tr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
     
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef void (*FuncToCall)(struct S_r4r4r4r4_ p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ChangeUICameraMask(Assets.Scripts.GameSystem.CullData) declare in LuaCallCSharpInteraction
bool w_vS_u4bbbi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u4bbbi4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u4bbbi4_* pp0 = DataTransfer::GetPointer<S_u4bbbi4_>(apis, env, _sv0);
    S_u4bbbi4_ p0 = pp0 ? *pp0 : S_u4bbbi4_ {};
        
    typedef void (*FuncToCall)(struct S_u4bbbi4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void OnBluePrintBroadCastEventRouterEvent(StringId, BroadCastEventRouterParam ByRef) declare in SGC
bool w_vS_u8_PS_a_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u8_PS_a_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
             
    // LuaValToCSVal Pstruct
    S_a_* p1 = DataTransfer::GetPointer<S_a_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_a_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(struct S_u8_ p1, struct S_a_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayLevelSound(StringId, UInt32) declare in SGC
bool w_vS_u8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vS_u8_u4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(struct S_u8_ p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void CalculateProjectionMatrixFromPhysicalProperties(UnityEngine.Matrix4x4 ByRef, Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, GateFitParameters) declare in UnityEngine.Camera
bool w_vTS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vTS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4S_r4r4_S_r4r4_r4r4DS_i4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 6 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
    // LuaValToCSVal valuetype with default
    S_i4r4_ p6 = OptionalParameter<S_i4r4_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 6);
            
    typedef void (*FuncToCall)(void* p1, float p2, struct S_r4r4_ p3, struct S_r4r4_ p4, float p5, float p6, struct S_i4r4_ p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void set_fullScreen(Boolean) declare in UnityEngine.Screen
bool w_vb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void NtfAgeDebugInfo(Boolean, StringId) declare in SGC
bool w_vbS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbS_u8_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef void (*FuncToCall)(bool p1, struct S_u8_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void StartRecordStats(Boolean, Boolean) declare in Assets.Scripts.Framework.PerfUtils
bool w_vbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void QueryNetwork(Boolean, Boolean, Boolean) declare in com.tencent.mna.MNA
bool w_vbbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbbb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetAnimCullTotalSwitch(Boolean, Int32) declare in UnityEngine.Animation
bool w_vbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void NtfRecordData(Boolean, UInt64, Int32) declare in SGC
bool w_vbu8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vbu8i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(bool p1, uint64_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void BeginSample_Logic(Assets.Plugins.Perf.StatsSampleId, Int32 ByRef) declare in Assets.Plugins.Perf.StatsLite
bool w_vi2Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi2Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(int16_t p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void BeginSample_Logic(Assets.Plugins.Perf.StatsSampleId, System.String, Int32 ByRef) declare in Assets.Plugins.Perf.StatsLite
bool w_vi2sPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi2sPi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(int16_t p1, Il2CppString* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void set_fullScreenMode(UnityEngine.FullScreenMode) declare in UnityEngine.Screen
bool w_vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void removeTween(Int32, Boolean) declare in LeanTween
bool w_vi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Db");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void GetCSharpPreLoadInfo(Int32, Boolean, Boolean) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vi4DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4DbDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(int32_t p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void BeginFlow(Int32, Int32, System.String) declare in Assets.Plugins.Common.CNS.CNSService
bool w_vi4Di4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Di4Ds");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
 // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostNetworkLatency(Int32, System.String, System.String) declare in GCloud.GPM.GPMAgent
bool w_vi4DsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4DsDs");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void dispatchEvent(Int32, System.Object) declare in LeanTween
bool w_vi4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4O");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void NtfProject8UpgradeNumOffsetChange(Int32, Project8UpgradeNumOffset ByRef) declare in SGC
bool w_vi4PS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4PS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal Pstruct
    S_oo_* p1 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oo_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(int32_t p1, struct S_oo_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void endSampleByIndex(Assets.Plugins.Perf.SampleTypeFlags, Int32 ByRef) declare in Assets.Plugins.Perf.StatsLite
bool w_vi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(int32_t p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetGlobalVector(Int32, UnityEngine.Vector4) declare in UnityEngine.Shader
bool w_vi4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetGlobalMatrix(Int32, UnityEngine.Matrix4x4) declare in UnityEngine.Shader
bool w_vi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void cancel(Int32, Boolean) declare in LeanTween
bool w_vi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void init(Int32, Int32) declare in LeanTween
bool w_vi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetResolution(Int32, Int32, Boolean) declare in UnityEngine.Screen
bool w_vi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Collect(Int32, System.GCCollectionMode, Boolean, Boolean) declare in System.GC
bool w_vi4i4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4bb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetResolution(Int32, Int32, Boolean, Int32) declare in UnityEngine.Screen
bool w_vi4i4bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4bi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode) declare in UnityEngine.Screen
bool w_vi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, UnityEngine.RefreshRate) declare in UnityEngine.Screen
bool w_vi4i4i4S_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4S_u4u4_");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal struct
    S_u4u4_* pp3 = DataTransfer::GetPointer<S_u4u4_>(apis, env, _sv3);
    S_u4u4_ p3 = pp3 ? *pp3 : S_u4u4_ {};
        
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, struct S_u4u4_ p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, Int32) declare in UnityEngine.Screen
bool w_vi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void NtfUpdateRoundState(Int32, Int32, Int32, Int32, Int32) declare in SGC
bool w_vi4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void NtfSpecialRelationTipsMechanism(ResData.RES_RELATION_ID, Int32, Int32, Int32, Int32, Boolean) declare in SGC
bool w_vi4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i4i4i4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void StartDumpRoutine(Int32, Int32, Int64, Int64, Int32, Boolean, System.String) declare in CrashSightAgent
bool w_vi4i4i8i8i4bs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4i8i8i4bs");
    auto TIp6 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
    // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, int64_t p3, int64_t p4, int32_t p5, bool p6, Il2CppString* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void GetCardSourceInfoArray(Int32, Int32, CardSourceInfoArrayTypeDelegate, Boolean) declare in SGWRequest
bool w_vi4i4oDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4oDb");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
 // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void CollectTouchData(Int32, Int32, System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32], System.Collections.Generic.List`1[System.Int32]) declare in com.tencent.mna.MNA
bool w_vi4i4oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i4oooo");
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SyncCoreThreadAffinity(Int32, Int64) declare in SGC
bool w_vi4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4i8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void addListener(Int32, System.Action`1[LTEvent]) declare in LeanTween
bool w_vi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4o");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetGlobalTexture(Int32, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.Shader
bool w_vi4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void UpdateTeamRecommendH5Data(Int32, XLua.LuaTable, Int32, Int32) declare in LuaCallCSharpInteraction
bool w_vi4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4oi4i4");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void LuaDoLog(Type, Assets.Plugins.Common.EntryLogTag, System.String) declare in Assets.Plugins.Common.Log
bool w_vi4os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4os");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGlobalFloat(Int32, Single) declare in UnityEngine.Shader
bool w_vi4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PostEvent(Int32, System.String) declare in GCloud.GPM.GPMAgent
bool w_vi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4s");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PrintLog(CSLogSeverity, System.String, System.Object[]) declare in CrashSightAgent
bool w_vi4sVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sVO");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetNoticeRed(Int32, System.String, Boolean) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_vi4sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sb");
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void ReleaseData(Int32, System.String, Int32, com.pixui.NativeBuffer ByRef) declare in com.pixui.PxContext
bool w_vi4si4PS_pi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4si4PS_pi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal Pstruct
    S_pi4_* p3 = DataTransfer::GetPointer<S_pi4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_pi4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, int32_t p3, struct S_pi4_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void LocalOutput(AkMonitorErrorCode, System.String, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_vi4si4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4si4u4o");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, int32_t p3, uint32_t p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void SetUserName(Int32, System.String, System.String, System.String) declare in com.tencent.mna.MNA
bool w_vi4sss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sss");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void ReportException(Int32, System.String, System.String, System.String, System.Collections.Generic.Dictionary`2[System.String,System.String], Int32, System.String) declare in CrashSightAgent
bool w_vi4sssoDi4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4sssoDi4Ds");
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (lua_args_len > 6 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
 // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
                // LuaValToCSVal string with default
    Il2CppString* p6 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 6);
    typedef void (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, int32_t p6, Il2CppString* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void PreLoadLordAge(Int32, LordAgePreLoadType, Int32, Int32) declare in Assets.Scripts.GameLogic.Project8PreLoadConfigService
bool w_vi4u1i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u1i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, uint8_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void RecordRoundTLog(OSProto.PVPRoundHUDOPType, UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vi4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void NtfAgeTriggerParticleLeave(Int32, UInt32, Boolean) declare in SGC
bool w_vi4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4b");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void ExecuteActionOnPlayingID(AkActionOnEventType, UInt32, Int32) declare in AkSoundEngine
bool w_vi4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void NtfChangeActorMesh(Int32, UInt32, Int32, Boolean, Boolean, Int32) declare in SGC
bool w_vi4u4i4bbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4i4bbi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, bool p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void ExecuteActionOnPlayingID(AkActionOnEventType, UInt32, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_vi4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4i4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void NtfAgeTriggerParticleEnter(Int32, UInt32, UInt32, AgeTriggerParticleInfo ByRef) declare in SGC
bool w_vi4u4u4PS_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4u4PS_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4u1u1_* p3 = DataTransfer::GetPointer<S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4u1u1_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4u1u1_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, struct S_u4u4u4u4u4u4S_u8_u1i4i4u1S_S_u8_u4u4u4u4u4u1u1u1u1_S_i4i4i4_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_r4r4r4u1u1u1u1u1u1u1u4u4u1u1u1u1S_r4r4r4_i4u4u4u4u4u1u1u1i4u1u1u4u4r4u4u1u1u1r4u1u1_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EquipBackpackCmd(Assets.Scripts.GameLogic.EquipOpType, UInt32, UInt32, UInt32) declare in Assets.Scripts.GameLogic.EquipCmd
bool w_vi4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4u4u4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void NtfSpecialRelationTipsTeamOfStar(ResData.RES_RELATION_ID, UInt32, UInt32, UInt32, Boolean, UInt32) declare in SGC
bool w_vi4u4u4u4bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u4u4u4bu4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, bool p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetDownloadProgress(Int32, UInt64, UInt64) declare in com.tencent.mna.MNA
bool w_vi4u8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u8u8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(int32_t p1, uint64_t p2, uint64_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void GetSnakeTraceBufferByLua(Int32, UInt64, UInt64, System.String) declare in Assets.Scripts.Framework.SynchrReport
bool w_vi4u8u8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi4u8u8s");
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(int32_t p1, uint64_t p2, uint64_t p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void AddMemoryPressure(Int64) declare in System.GC
bool w_vi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi8");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void QueryPreciseKartin(Int64, Int64, System.String) declare in com.tencent.mna.MNA
bool w_vi8i8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vi8i8s");
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(int64_t p1, int64_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PCall(System.Action) declare in com.pixui.PxMisc
bool w_vo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vo");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef void (*FuncToCall)(Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void GetDebugMatchData(DebugMatchDataTypeDelegate, Boolean) declare in SGWRequest
bool w_voDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetUITookitEventSystemOverride(UnityEngine.EventSystems.EventSystem, Boolean, Boolean) declare in UnityEngine.EventSystems.EventSystem
bool w_voDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voDbDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void KeepInScreen(UnityEngine.RectTransform, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetOptions(System.Type, System.Object) declare in com.pixui.PxMisc
bool w_voO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void serialize_array_FormationChessInfo(FormationChessInfo[], Byte* ByRef) declare in SGW
bool w_voPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 
    // LuaValToCSVal P not primitive
    uint8_t** p1 = nullptr;

    typedef void (*FuncToCall)(Il2CppObject* p1, uint8_t** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void MergeSettings(System.Collections.Generic.List`1[Yarp.RenderSettingsVolume], Yarp.YARenderSettings ByRef) declare in Yarp.YARenderSettings
bool w_voPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ActivateRenderers(UnityEngine.GameObject, System.Collections.Generic.List`1[UnityEngine.GameObject] ByRef, UnityEngine.Renderer[]) declare in Utility
bool w_voPoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voPoo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject** p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void MergeSettings(System.Collections.Generic.List`1[Yarp.RenderSettingsVolume], UnityEngine.LayerMask, Yarp.YARenderSettings ByRef) declare in Yarp.YARenderSettings
bool w_voS_i4_Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_i4_Po");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
             // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_i4_ p2, Il2CppObject** p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ChangeVecParameters(CMTweener, UnityEngine.Vector2, UnityEngine.Vector2) declare in LuaCallCSharpInteraction
bool w_voS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4_S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void ChangeCustomMove(CMTweener, UnityEngine.Vector3, UnityEngine.Transform) declare in CMTweenerHelper
bool w_voS_r4r4r4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4_Do");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void ChangeCustomScale(CMTweener, UnityEngine.Vector3, UnityEngine.Vector3) declare in CMTweenerHelper
bool w_voS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetIndicatorPos(UnityEngine.LineRenderer, UnityEngine.Vector3, UnityEngine.Vector3, Single, Single, IndicatorShape) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voS_r4r4r4_S_r4r4r4_Dr4Dr4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4_S_r4r4r4_Dr4Dr4Di4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, float p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void SetMatColor(UnityEngine.GameObject, UnityEngine.Color, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voS_r4r4r4r4_Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4r4_Ds");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
            // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetModelAlbedoColorAndMaskScale(UnityEngine.Transform, UnityEngine.Color, Single) declare in LuaCallCSharpInteraction
bool w_voS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voS_r4r4r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void DestroyImmediate(UnityEngine.Object, Boolean) declare in UnityEngine.Object
bool w_vob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vob");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void FlipLayoutAxes(UnityEngine.RectTransform, Boolean, Boolean) declare in UnityEngine.RectTransformUtility
bool w_vobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vobb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void cancel(LTRect, Int32) declare in LeanTween
bool w_voi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void cancel(UnityEngine.GameObject, Int32, Boolean) declare in LeanTween
bool w_voi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void FlipLayoutOnAxis(UnityEngine.RectTransform, Int32, Boolean, Boolean) declare in UnityEngine.RectTransformUtility
bool w_voi4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4bb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Reverse(System.Array, Int32, Int32) declare in System.Array
bool w_voi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetLayerRecursively(UnityEngine.GameObject, Int32, Int32, Boolean) declare in ExtGameObject
bool w_voi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Sort(System.Array, Int32, Int32, System.Collections.IComparer) declare in System.Array
bool w_voi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void addListener(UnityEngine.GameObject, Int32, System.Action`1[LTEvent]) declare in LeanTween
bool w_voi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Copy(System.Array, Int32, System.Array, Int32, Int32) declare in System.Array
bool w_voi4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4oi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void SetGameObjLayerRecursively(UnityEngine.GameObject, Int32, System.String) declare in ExtGameObject
bool w_voi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi4s");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Copy(System.Array, Int64, System.Array, Int64, Int64) declare in System.Array
bool w_voi8oi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voi8oi8i8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(Il2CppObject* p1, int64_t p2, Il2CppObject* p3, int64_t p4, int64_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void Sort(System.Array, System.Collections.IComparer) declare in System.Array
bool w_voo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void ReqFormationCode(OSProto.OSOFormationInfo, stringTypeDelegate, Boolean) declare in SGWRequest
bool w_vooDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooDb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Execute(System.Collections.Generic.List`1[UIEventDelegate], LuaUIPointerEventData, Int32) declare in UIEventDelegate
bool w_vooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
 // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void KeepNodeScale(UnityEngine.RectTransform, UnityEngine.RectTransform, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vooDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
 // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void LogCustomException(Assets.Plugins.Common.EntryLogTag, System.Exception, System.String) declare in Assets.Plugins.Common.Log
bool w_vooDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SubCanvasSortOrderImpl(UnityEngine.Canvas, UIPrefabBase, Int32) declare in Assets.Scripts.Framework.UI.UIPrefabLayerService
bool w_vooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Sort(System.Array, System.Array, Int32, Int32) declare in System.Array
bool w_vooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Sort(System.Array, System.Array, Int32, Int32, System.Collections.IComparer) declare in System.Array
bool w_vooi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, Il2CppObject* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void Copy(System.Array, System.Array, Int64) declare in System.Array
bool w_vooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooi8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Sort(System.Array, System.Array, System.Collections.IComparer) declare in System.Array
bool w_vooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void NtfPlayerHeadUrl(UInt64[], System.String[], Int32[], Int32[], UInt64[], UInt64[], UInt64[]) declare in LuaCallCSharpInteraction
bool w_vooooooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooooooo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
    
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[], System.Reflection.AssemblyName, System.Reflection.Emit.CustomAttributeBuilder[], System.String) declare in System.Text.RegularExpressions.Regex
bool w_vooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vooos");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void AutoComputeHeight(UnityEngine.Component, UnityEngine.UI.ScrollRect, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voor4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void GetTotalMtl(UnityEngine.Transform, System.Collections.Generic.List`1[UnityEngine.Renderer], System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_voos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_voos");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Destroy(UnityEngine.Object, Single) declare in UnityEngine.Object
bool w_vor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void GetImageContentSize(Assets.Scripts.GameNotice.ImageContent, Single, UnityEngine.Vector2 ByRef) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_vor4PS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4PS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
        
    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, struct S_r4r4_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GetHorizonSpace(UnityEngine.RectTransform, Single, Single ByRef, Single ByRef) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vor4Tr4Tr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4Tr4Tr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
     
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void ChangeCustomAlpha(CMTweener, Single, Single) declare in CMTweenerHelper
bool w_vor4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetRendererFloatStandState(UnityEngine.GameObject, Single, Single, Single) declare in Utility
bool w_vor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vor4r4r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void CreateGameObjectPath(UnityEngine.Transform, System.String) declare in ExtTransform
bool w_vos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vos");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void DebugLog(System.Type, System.String, System.Object[]) declare in Assets.Scripts.Framework.AssetService.AssetServiceUtils
bool w_vosVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vosVO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetRendererFloatPropertyState(UnityEngine.GameObject, System.String, Single) declare in Utility
bool w_vosr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vosr4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PreGameObjectAPICall(UnityEngine.GameObject, UInt64) declare in AkSoundEngine
bool w_vou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vou8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppObject* p1, uint64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void OSG_SetEditorWindowHander(IntPtr) declare in SGamePInvoke
bool w_vp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vp");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer(apis, env, _sv0);

    typedef void (*FuncToCall)(void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void CopyMemory(IntPtr, IntPtr, Int32) declare in SGamePInvoke
bool w_vppi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vppi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer(apis, env, _sv0);
        
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void set_brightness(Single) declare in UnityEngine.Screen
bool w_vr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);

    typedef void (*FuncToCall)(float p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void ChangeSpeed(Single, Assets.Scripts.GameLogic.BattleTimeScaleType) declare in Assets.Scripts.GameLogic.ReplayUtil
bool w_vr4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vr4i4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PostCoordinates(Single, Single, Single, Single, Single, Single) declare in GCloud.GPM.GPMAgent
bool w_vr4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vr4r4r4r4r4r4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(float p1, float p2, float p3, float p4, float p5, float p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void CreateDirectory(System.String) declare in com.pixui.PxMisc
bool w_vs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vs");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef void (*FuncToCall)(Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);
    return true;
}
// Void SetScene(System.String, Boolean) declare in CrashSightAgent
bool w_vsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void StartRecord(System.String, Boolean, Assets.Plugins.Perf.SampleTypeFlags) declare in Assets.Plugins.Perf.StatsLite
bool w_vsDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDbDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PreloadSceneAutoLoadPrefabs(System.String, SceneLevelDefine) declare in Assets.Scripts.GameLogic.Project8PreLoadConfigService
bool w_vsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SendLuaEvent(System.String, XLua.LuaTable) declare in Utility
bool w_vsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void ShowSystemTips(System.String, System.String, Int32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsDsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDsDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void CheckUniversalLink(System.String, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDsDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Login(System.String, System.String, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vsDsDsDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsDsDsDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void serialize_string(System.String, Byte* ByRef) declare in SGW
bool w_vsPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); 
    // LuaValToCSVal P not primitive
    uint8_t** p1 = nullptr;

    typedef void (*FuncToCall)(Il2CppString* p1, uint8_t** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void StringToUTF8Bytes(System.String, Byte[] ByRef) declare in StringHelper
bool w_vsPa(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsPa");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject** p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void BeginSample_Logic(System.String, Int32 ByRef) declare in Assets.Plugins.Perf.StatsLite
bool w_vsPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsPi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(Il2CppString* p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetGlobalVector(System.String, UnityEngine.Vector4) declare in UnityEngine.Shader
bool w_vsS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetGlobalMatrix(System.String, UnityEngine.Matrix4x4) declare in UnityEngine.Shader
bool w_vsS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetCreationTime(System.String, System.DateTime) declare in System.IO.Directory
bool w_vsS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_u8_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_u8_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SendEventRouter(System.String, Bytes) declare in SGC
bool w_vsS_u8u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsS_u8u8_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal struct
    S_u8u8_* pp1 = DataTransfer::GetPointer<S_u8u8_>(apis, env, _sv1);
    S_u8u8_ p1 = pp1 ? *pp1 : S_u8u8_ {};
        
    typedef void (*FuncToCall)(Il2CppString* p1, struct S_u8u8_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void ExternalCall(System.String, System.Object[]) declare in UnityEngine.Application
bool w_vsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsVO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void WriteAllBytes(System.String, Byte[]) declare in System.IO.File
bool w_vsa(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsa");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Delete(System.String, Boolean) declare in System.IO.Directory
bool w_vsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SetVisible(System.String, Boolean, XLua.LuaTable) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32) declare in com.tencent.mna.MNA
bool w_vsbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32, Boolean) declare in com.tencent.mna.MNA
bool w_vsbi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32, Boolean, Boolean, ReportChannelType) declare in com.tencent.mna.MNA
bool w_vsbi4bbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4bbi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, bool p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void Init(System.String, Boolean, Int32, Boolean, Boolean, ReportChannelType, System.String) declare in com.tencent.mna.MNA
bool w_vsbi4bbi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsbi4bbi4s");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6);
    typedef void (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, bool p4, bool p5, int32_t p6, Il2CppString* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void SetAttributes(System.String, System.IO.FileAttributes) declare in System.IO.File
bool w_vsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void PingGateway(System.String, Int32, Int32, Int32, Boolean) declare in com.tencent.mna.MNA
bool w_vsi4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostStepEvent(System.String, Int32, Int32, Int32, System.String, System.String, Boolean, Boolean) declare in GCloud.GPM.GPMAgent
bool w_vsi4i4i4ssbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4i4ssbb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
    // LuaValToCSVal s
    Il2CppString* p4 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv4);    // LuaValToCSVal s
    Il2CppString* p5 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv5);        
    // LuaValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(apis, env, _sv6);
        
    // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);

    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, Il2CppString* p5, Il2CppString* p6, bool p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void StartSpeed(System.String, Int32, Int32, System.String, Int32, Int32, Int32, System.String, Int32) declare in com.tencent.mna.MNA
bool w_vsi4i4si4i4i4sDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4si4i4i4sDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (true) {
        if (lua_args_len < 8 || lua_args_len > 9) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv7))
            return false;
        if (lua_args_len > 8 && !converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
    // LuaValToCSVal s
    Il2CppString* p7 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv7); // LuaValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 8);
            
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, int32_t p6, int32_t p7, Il2CppString* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void StartSpeed(System.String, Int32, Int32, System.String, Int32, Int32, System.String, Int32) declare in com.tencent.mna.MNA
bool w_vsi4i4si4i4sDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4i4si4i4sDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (true) {
        if (lua_args_len < 7 || lua_args_len > 8) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv6))
            return false;
        if (lua_args_len > 7 && !converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
    // LuaValToCSVal s
    Il2CppString* p6 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv6); // LuaValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 7);
            
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppString* p4, int32_t p5, int32_t p6, Il2CppString* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
    return true;
}
// Void EndSpeed(System.String, Int32, System.String) declare in com.tencent.mna.MNA
bool w_vsi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4s");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGameIpWithLocalIp(System.String, Int32, System.String, Int32) declare in com.tencent.mna.MNA
bool w_vsi4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi4si4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void SetLong(System.String, Int64) declare in PlayerPrefsX
bool w_vsi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsi8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void LoadCDNTextureAsync(System.String, Assets.Scripts.Framework.AssetService.IAssetLoadCallback) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vso");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void GetStringId(System.String, ulongTypeDelegate, Boolean) declare in SGWRequest
bool w_vsoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoDb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
 // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGlobalTexture(System.String, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement) declare in UnityEngine.Shader
bool w_vsoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetGlobalConstantBuffer(System.String, UnityEngine.ComputeBuffer, Int32, Int32) declare in UnityEngine.Shader
bool w_vsoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void WriteAllLines(System.String, System.String[], System.Text.Encoding) declare in System.IO.File
bool w_vsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsoo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void SetFloat(System.String, Single) declare in UnityEngine.PlayerPrefs
bool w_vsr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void Move(System.String, System.String) declare in System.IO.Directory
bool w_vss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vss");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void SendUpdateUI(System.String, System.String, XLua.LuaTable) declare in Utility
bool w_vssDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void CanBind(System.String, System.String, System.String) declare in GCloud.MSDK.MSDKLogin
bool w_vssDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssDs");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void DebugLog(System.String, System.String, System.Object[]) declare in CrashSightAgent
bool w_vssVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssVO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void DecompressFile(System.String, System.String, Byte[], UInt32, UInt32) declare in CFileManager
bool w_vssau4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssau4u4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, uint32_t p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void Copy(System.String, System.String, Boolean) declare in System.IO.File
bool w_vssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostValueI(System.String, System.String, Int32, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssi4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void PostValueI(System.String, System.String, Int32, Int32, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssi4i4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
 // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void GetIpGroupDelays(System.String, System.String, Int32, Int32, Int32) declare in com.tencent.mna.MNA
bool w_vssi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostValueI(System.String, System.String, Int32, Int32, Int32, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssi4i4i4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4i4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
 // LuaValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void Ping(System.String, System.String, Int32, Int32, Int32, Boolean) declare in com.tencent.mna.MNA
bool w_vssi4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssi4i4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void WriteAllText(System.String, System.String, System.Text.Encoding) declare in System.IO.File
bool w_vsso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsso");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostValueF(System.String, System.String, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void PostValueF(System.String, System.String, Single, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4r4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4r4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
 // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
    return true;
}
// Void PostValueF(System.String, System.String, Single, Single, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4r4r4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4r4r4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
 // LuaValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, float p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void PostValueCoordinate(System.String, System.String, Single, Single, Single, Single, Single, Single, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vssr4r4r4r4r4r4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssr4r4r4r4r4r4Du4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (true) {
        if (lua_args_len < 8 || lua_args_len > 9) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7))
            return false;
        if (lua_args_len > 8 && !converter::Converter<uint32_t>::accept(apis, env, _sv8))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
        
    // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
        
    // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
 // LuaValToCSVal primitive with default
    uint32_t p8 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 8);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, float p3, float p4, float p5, float p6, float p7, float p8, uint32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
    return true;
}
// Void Replace(System.String, System.String, System.String) declare in System.IO.File
bool w_vsss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsss");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void PostValueS(System.String, System.String, System.String, UInt32) declare in GCloud.GPM.GPMAgent
bool w_vsssDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsssDu4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2); // LuaValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void Replace(System.String, System.String, System.String, Boolean) declare in System.IO.File
bool w_vsssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsssb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void ConfigDefault(System.String, System.String, System.String, Int64) declare in CrashSightAgent
bool w_vsssi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsssi8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
    return true;
}
// Void EncryptFile(System.String, System.String, System.String, System.String, Byte[], UInt32) declare in CFileManager
bool w_vssssau4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vssssau4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);    
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);

    typedef void (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, Il2CppObject* p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void RecordRoundTLog(System.String, UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsu4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);
    return true;
}
// Void RecordRoundTLog(System.String, UInt32, UInt32) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_vsu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vsu4u4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(Il2CppString* p1, uint32_t p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);
    return true;
}
// Void Init() declare in DataService
bool w_vt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vt");

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef void (*FuncToCall)(void*,const void* method);
    ((FuncToCall)methodPointer)(self,  method);
    return true;
}
// Void RemoveAllGridFlags(System.Object) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Create(System.Object, UIPrefabBase, UnityEngine.Transform, System.Object, Boolean) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtDODoDoDODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDODoDoDODb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 5) 
            return false;

        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3); // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void LoadAllNested(Boolean) declare in UIPrefabBase
bool w_vtDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ForceMeshUpdate(Boolean, Boolean) declare in TMPro.TextMeshPro
bool w_vtDbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDbDb");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ResetAllRenderFeature(GraphicsSettingsPriorityLevel) declare in Assets.Scripts.Framework.GfxSettings
bool w_vtDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDi4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void .ctor(Int32, Int32) declare in Timi.TimiMenuIndex
bool w_vtDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDi4Di4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Reset(UnityEngine.Transform, UnityEngine.Transform) declare in ExtTransform
bool w_vtDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDo");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ShowHeroList(System.Collections.Generic.List`1[Assets.Scripts.UI.InTheGame.TeamRecommend.UITeamRecommendHeroAnnotationItem+ItemShowData], Boolean) declare in Assets.Scripts.UI.InTheGame.TeamRecommend.UITeamRecommendHeroList
bool w_vtDoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDoDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Play(OnCompleted, System.Action`1[CMTweener], Int32, Single, Boolean, OnFollowUpdate) declare in CMTweener
bool w_vtDoDoDi4Dr4DbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDoDoDi4Dr4DbDo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 6) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5);
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, int32_t p3, float p4, bool p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void EnableClickLock(Single) declare in Timi.TimiButton
bool w_vtDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void InitCameraOffsetParam(Single, Single, Single, Single) declare in Moba_Camera
bool w_vtDr4Dr4Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDr4Dr4Dr4Dr4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 4) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
 // LuaValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
             // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
             // LuaValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,float p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void EndSpeed(System.String) declare in GSDKsys
bool w_vtDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDs");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0);
    typedef void (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Play(System.String, Boolean, Single) declare in SceneTagComponent
bool w_vtDsDbDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDsDbDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 3) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,Il2CppString* p1, bool p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void FirePlugin(System.String, Int32) declare in BoxSDK.BoxSDKService
bool w_vtDsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDsDi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayReverse(System.String, Single) declare in SceneTagComponent
bool w_vtDsDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDsDr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal string with default
    Il2CppString* p0 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 0); // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppString* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayEnterAuctionBroadcast(UInt32) declare in Assets.Scripts.GameLogic.Project8BattleAudio
bool w_vtDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtDu4");

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    uint32_t p0 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef void (*FuncToCall)(void*,uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ChangeMsgParent(System.Object) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtO");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetSelectByValue(System.Object, Boolean) declare in Timi.TimiDropDown
bool w_vtODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtODb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
 // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void DeleteTarget(System.Object, System.Object) declare in EventProxy
bool w_vtOO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOO");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, System.Object, System.Object[]) declare in System.Reflection.PropertyInfo
bool w_vtOOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOOo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void AddScaleChange(System.Object, UnityEngine.Vector3) declare in Assets.Scripts.GameLogic.ActorMeshComponent
bool w_vtOS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOS_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int32[]) declare in System.Array
bool w_vtOVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOVi4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;
        if(lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int64[]) declare in System.Array
bool w_vtOVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOVi8");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;
        if(lua_args_len > 1 && !converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
     
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int64_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppArray* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int32) declare in System.Array
bool w_vtOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int32, Int32) declare in System.Array
bool w_vtOi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetValue(System.Object, Int32, Int32, Int32) declare in System.Array
bool w_vtOi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi4i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetValue(System.Object, Int64) declare in System.Array
bool w_vtOi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValue(System.Object, Int64, Int64) declare in System.Array
bool w_vtOi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi8i8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetValue(System.Object, Int64, Int64, Int64) declare in System.Array
bool w_vtOi8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOi8i8i8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, int64_t p2, int64_t p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Yield(System.Object, System.Action) declare in Assets.Scripts.Framework.Lua.CoroutineRunner
bool w_vtOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ListenKeyDown(System.Object, System.Collections.Generic.HashSet`1[UnityEngine.KeyCode], KeyboardAction) declare in Assets.Scripts.Framework.InputModule
bool w_vtOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOoo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void Create(System.Object, UIPrefabBase, UnityEngine.Transform, System.Object, Boolean, UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtOooObS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOooObS_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp5 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv5);
    S_r4r4r4_ p5 = pp5 ? *pp5 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, struct S_r4r4r4_ p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void AsyncCreate(System.Object, UIPrefabBase, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UIPrefabBaseClass]) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtOooObo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOooObo");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);

    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, Il2CppObject* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
    return true;
}
// Void AsyncCreate(System.Object, UIPrefabBase, UnityEngine.Transform, System.Object, Boolean, System.Action`1[Assets.Scripts.Framework.UI.UIPrefabBaseClass], UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_vtOooOboS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtOooOboS_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
    
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp6 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv6);
    S_r4r4r4_ p6 = pp6 ? *pp6 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, bool p5, Il2CppObject* p6, struct S_r4r4r4_ p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
    return true;
}
// Void deserialize(Byte* ByRef) declare in SGW+LastRoundHighestHeroInfo
bool w_vtPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
 
    // LuaValToCSVal P not primitive
    uint8_t** p0 = nullptr;

    typedef void (*FuncToCall)(void*,uint8_t** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GetTransfrom(Project8FreeCameraParam ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef, UnityEngine.Vector3 ByRef) declare in Assets.Scripts.GameLogic.Project8FreeCamera
bool w_vtPS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__TS_r4r4r4_TS_r4r4r4r4_TS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__TS_r4r4r4_TS_r4r4r4r4_TS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p0 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }
                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void EnableKeyword(UnityEngine.Rendering.LocalKeyword ByRef) declare in UnityEngine.Material
bool w_vtPS_S_p_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_p_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_p_su4_* p0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_p_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_p_su4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetKeyword(UnityEngine.Rendering.LocalKeyword ByRef, Boolean) declare in UnityEngine.Material
bool w_vtPS_S_p_su4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_p_su4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_p_su4_* p0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_p_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_su4_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayFadeIn(RectRtRecord ByRef, CMTweener, Single) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_DoDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_DoDr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p1, Il2CppObject* p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void PlayLerpFrom(RectRtRecord ByRef, System.Action`1[CMTweener], Single, CMTweener, Boolean) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_or4DoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_or4DoDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 5) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
    // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3); // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* p1, Il2CppObject* p2, float p3, Il2CppObject* p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorBuffChange(Assets.Scripts.GameLogic.BuffChangeEventParam ByRef) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtPS_S_u4o_i4S_u4o__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4o_i4S_u4o__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4o_i4S_u4o__* p0 = DataTransfer::GetPointer<S_S_u4o_i4S_u4o__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4o_i4S_u4o__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_u4o_i4S_u4o__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnPlayerSkillTimer(Assets.Scripts.GameLogic.SkillTimerEvtParam ByRef) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtPS_S_u4o_u4i4u8i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4o_u4i4u8i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4o_u4i4u8i4i4i4_* p0 = DataTransfer::GetPointer<S_S_u4o_u4i4u8i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4o_u4i4u8i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_u4o_u4i4u8i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEnterView(ActorRecoverData ByRef) declare in Assets.Scripts.GameLogic.ActorManager
bool w_vtPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p0 = DataTransfer::GetPointer<S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void RecoverActor(ActorRecoverData ByRef, ActorRecoverWay) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p0 = DataTransfer::GetPointer<S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Min(VInt2 ByRef) declare in VInt2
bool w_vtPS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4_* p0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnPlayerCampSwitch(Assets.Scripts.GameLogic.GameCommonEventParam ByRef) declare in Assets.Scripts.GameLogic.ActorManager
bool w_vtPS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetCameraCircleLerpParam(VInt3 ByRef, VInt3 ByRef, VInt3 ByRef, Int32, Int32, Int32, Int32, Int32, Int32) declare in Moba_Camera
bool w_vtPS_i4i4i4_PS_i4i4i4_PS_i4i4i4_i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4i4_PS_i4i4i4_PS_i4i4i4_i4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv8))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p2 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_i4i4i4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
        
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
        
    // LuaValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(apis, env, _sv8);

    typedef void (*FuncToCall)(void*,struct S_i4i4i4_* p1, struct S_i4i4i4_* p2, struct S_i4i4i4_* p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnPlayerRandomHp(PlayerRandomHpData ByRef) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtPS_i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4i4i4i4_* p0 = DataTransfer::GetPointer<S_i4i4i4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4i4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void RefreshBaseDataOnReuse(Assets.Scripts.Framework.AssetService.AssetData ByRef) declare in Assets.Scripts.Framework.AssetService.BaseAsset
bool w_vtPS_i4i4ossOossOi4i4i4i1i1i1i1bi4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4i4ossOossOi4i4i4i1i1i1i1bi4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4ossOossOi4i4i4i1i1i1i1bi4o_* p0 = DataTransfer::GetPointer<S_i4i4ossOossOi4i4i4i1i1i1i1bi4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4ossOossOi4i4i4i1i1i1i1bi4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4i4ossOossOi4i4i4i1i1i1i1bi4o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void RefreshCounter(SkillCounterChange ByRef) declare in Assets.Scripts.GameLogic.BuffLinkerComponent
bool w_vtPS_i4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_i4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4u4_* p0 = DataTransfer::GetPointer<S_i4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_i4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetAllPlayersTeamId(AllPlayersTeamIdInfo ByRef) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_vtPS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_o_* p0 = DataTransfer::GetPointer<S_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8AuctionUnlockChange(Project8AuctionUnlockChange ByRef) declare in Assets.Scripts.GameLogic.Project8AuctionLogic
bool w_vtPS_oaoa_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_oaoa_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oaoa_* p0 = DataTransfer::GetPointer<S_oaoa_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oaoa_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_oaoa_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetRoundInfo(Project8RoundStatisticInfo ByRef) declare in Assets.Scripts.GameSystem.RoundStatisticData
bool w_vtPS_oi4i4i4u4u4oi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_oi4i4i4u4u4oi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oi4i4i4u4u4oi4_* p0 = DataTransfer::GetPointer<S_oi4i4i4u4u4oi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oi4i4i4u4u4oi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_oi4i4i4u4u4oi4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEquipGridsChangeAll(stAllEquipInfo ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_vtPS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oo_* p0 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_oo_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void UpdateCameraMovement(UnityEngine.Vector2 ByRef) declare in CameraSystem
bool w_vtPS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4_* p0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetStartLocation(UnityEngine.Vector3 ByRef) declare in Moba_Camera
bool w_vtPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Teleport(UnityEngine.Vector3 ByRef, VInt3 ByRef, UnityEngine.Quaternion ByRef, ActorRecoverWay) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_r4r4r4_PS_i4i4i4_PS_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_r4r4r4_PS_i4i4i4_PS_r4r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4i4_* p1 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_* p1, struct S_i4i4i4_* p2, struct S_r4r4r4r4_* p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetGoldInfo(stGoldDetailInfo ByRef) declare in Assets.Scripts.GameSystem.PlayerStatisticData
bool w_vtPS_u1u1u1u1u1u1ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u1u1u1u1u1u1ooo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u1u1u1u1u1ooo_* p0 = DataTransfer::GetPointer<S_u1u1u1u1u1u1ooo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u1u1u1u1u1ooo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u1u1u1u1u1u1ooo_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorEquipGridChange(stEquipChangeInfo ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_vtPS_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__* p0 = DataTransfer::GetPointer<S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u1u2u1u1S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void AddBuff(BuffChangeParam ByRef) declare in Assets.Scripts.GameLogic.BuffLinkerComponent
bool w_vtPS_u1u4u4i4i4i4u4u4u1u4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u1u4u4i4i4i4u4u4u1u4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u1u4u4i4i4i4u4u4u1u4i4_* p0 = DataTransfer::GetPointer<S_u1u4u4i4i4i4u4u4u1u4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u1u4u4i4i4i4u4u4u1u4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u1u4u4i4i4i4u4u4u1u4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void UpdatePosition(DisplayInfoData ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p0 = DataTransfer::GetPointer<S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void RefreshAllActorPositionByMovementDataCache(DisplayInfoData*, UInt32) declare in Assets.Scripts.GameLogic.ActorManager
bool w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p0 = DataTransfer::GetPointer<S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnNewInstance(PlayerInstanceInfo ByRef) declare in Assets.Scripts.GameLogic.Project8Logic
bool w_vtPS_u4i4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4i4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4i4u4u4_* p0 = DataTransfer::GetPointer<S_u4i4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4i4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4i4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnEquipRecommendRet(EquipRecommendRet ByRef) declare in Assets.Scripts.GameLogic.EquipLogic
bool w_vtPS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef, Assets.Scripts.GameLogic.BuffChangeType, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BuffLinker]) declare in Assets.Scripts.GameLogic.BuffChangeEventParam
bool w_vtPS_u4o_i4S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4o_i4S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal struct
    S_u4o_* pp2 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv2);
    S_u4o_ p2 = pp2 ? *pp2 : S_u4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u4o_* p1, int32_t p2, struct S_u4o_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Project8AuctionUpdateJoinerList(Project8AuctionJoinerList ByRef) declare in Assets.Scripts.GameLogic.Project8AuctionLogic
bool w_vtPS_u4ooo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4ooo_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4ooo_* p0 = DataTransfer::GetPointer<S_u4ooo_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4ooo_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4ooo_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetPlayerTeamId(PlayerTeamIdInfo ByRef) declare in Assets.Scripts.GameLogic.GamePlayerCenter
bool w_vtPS_u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4_* p0 = DataTransfer::GetPointer<S_u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorShieldChange(stShowActorShieldData ByRef) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vtPS_u4u4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4_* p0 = DataTransfer::GetPointer<S_u4u4i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4i4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnActorDamage(stShowActorDamageData ByRef) declare in Assets.Scripts.GameSystem.BattleFloatTextManager
bool w_vtPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p0 = DataTransfer::GetPointer<S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4i4i4i4i4u4u1u1u4i4i4i4i4u1u4S_i4i4i4_i4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void CreateDebugCollision(InitDebugCollision ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p0 = DataTransfer::GetPointer<S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u1S_i4i4i4_S_i4i4i4_S_i4i4i4__* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetEquipGroupInfo(ActorEquipGroupInfo ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_vtPS_u4u4u1u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u1u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u1u4_* p0 = DataTransfer::GetPointer<S_u4u4u1u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u1u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u1u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NotifyHuanHuaLingPaiData(HuanHuaLingPaiRandomData ByRef) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_vtPS_u4u4u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4o_* p0 = DataTransfer::GetPointer<S_u4u4u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4o_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetMetaData(SpawnActorData ByRef) declare in Assets.Scripts.GameLogic.ActorLinker
bool w_vtPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnEquipItemChanged(stEquipItem ByRef) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_vtPS_u4u4u4u4u4u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void DumpCommonMemoryStatCb(CommonMemoryStat ByRef, UInt32) declare in Assets.Scripts.GameSystem.LogicComponentPerformance
bool w_vtPS_u4u4u4u4u4u4u4u4u4u4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPS_u4u4u4u4u4u4u4u4u4u4_u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u4u4u4u4_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4u4u4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u4u4u4u4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u4u4u4u4_* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(Char*) declare in System.String
bool w_vtPc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    Il2CppChar up0 = 0x0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;

    typedef void (*FuncToCall)(void*,Il2CppChar* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = converter::Converter<Il2CppChar>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(Char*, Int32, Int32) declare in System.String
bool w_vtPci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPci4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    Il2CppChar up0 = 0x0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,Il2CppChar* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int ret0 = converter::Converter<Il2CppChar>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(SByte*) declare in System.String
bool w_vtPi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;

    typedef void (*FuncToCall)(void*,int8_t* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(SByte*, Int32, Int32) declare in System.String
bool w_vtPi1i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi1i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,int8_t* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void .ctor(SByte*, Int32, Int32, System.Text.Encoding) declare in System.String
bool w_vtPi1i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi1i4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,int8_t* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void OnTotalCoinInPoolChanged(Int32 ByRef, Project8AuctionPlayerDividendResult ByRef) declare in Assets.Scripts.GameLogic.Project8AuctionLogic
bool w_vtPi4PS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4PS_oo_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
     
    // LuaValToCSVal Pstruct
    S_oo_* p1 = DataTransfer::GetPointer<S_oo_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oo_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(void*,int32_t* p1, struct S_oo_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void FlipCoord(Int32 ByRef, Int32 ByRef) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtPi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef void (*FuncToCall)(void*,int32_t* p1, int32_t* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void NtfProject8AuctionItemAddTime(Int32 ByRef, UInt32 ByRef) declare in Assets.Scripts.GameLogic.Project8AuctionLogic
bool w_vtPi4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPi4Pu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
     
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef void (*FuncToCall)(void*,int32_t* p1, uint32_t* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void InitLevelContext(Assets.Scripts.GameLogic.CLevelContext ByRef) declare in Assets.Scripts.GameLogic.BattleLogic
bool w_vtPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     // LuaValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ret
    Il2CppObject** p0 = &up0;
        
    typedef void (*FuncToCall)(void*,Il2CppObject** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
	int ret0 = CSRefToLuaValue(apis, env, TIp0, *p0);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void Tween(Single ByRef, Single, Project8FreeCameraParam ByRef, Project8FreeCameraParam ByRef, Project8FreeCameraParam ByRef) declare in Assets.Scripts.GameLogic.Project8FreeCamera
bool w_vtPr4r4PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPr4r4PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__PS_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
     
    // LuaValToCSVal P primitive
    float up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv0);
    float* p0 = &up0;
        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p2 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
             
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p3 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
             
    // LuaValToCSVal Pstruct
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p4 = DataTransfer::GetPointer<S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
        
    typedef void (*FuncToCall)(void*,float* p1, float p2, struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p3, struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p4, struct S_S_S_r4r4r4_S_r4r4r4_S_r4r4r4__S_r4r4r4i4__* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int ret0 = converter::Converter<float>::toScript(apis, env, *p0);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }
                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }
                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, ret0);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void GiveAuctionItemToPlayer(UInt32 ByRef, Int32 ByRef, Int32 ByRef) declare in Assets.Scripts.GameLogic.Project8AuctionLogic
bool w_vtPu4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPu4Pi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
     
    // LuaValToCSVal P primitive
    uint32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef void (*FuncToCall)(void*,uint32_t* p1, int32_t* p2, int32_t* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int ret0 = converter::Converter<uint32_t>::toScript(apis, env, *p0);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SyncAllAuctionItems(UInt32 ByRef, Project8AuctionItem[] ByRef) declare in Assets.Scripts.GameLogic.Project8AuctionLogic
bool w_vtPu4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtPu4Po");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal P primitive
    uint32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv0);
    uint32_t* p0 = &up0;
     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef void (*FuncToCall)(void*,uint32_t* p1, Il2CppObject** p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int ret0 = converter::Converter<uint32_t>::toScript(apis, env, *p0);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SetPositions(Unity.Collections.NativeSlice`1[UnityEngine.Vector3]) declare in UnityEngine.LineRenderer
bool w_vtS_Pu1i4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pu1i4i4i4i4S_pi4i4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pu1i4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_Pu1i4i4i4i4S_pi4i4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetPositions(Unity.Collections.NativeArray`1[UnityEngine.Vector3]) declare in UnityEngine.LineRenderer
bool w_vtS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_Pvi4i4i4S_pi4i4_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void TransformDirections(System.Span`1[UnityEngine.Vector3]) declare in UnityEngine.Transform
bool w_vtS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void TransformDirections(System.ReadOnlySpan`1[UnityEngine.Vector3], System.Span`1[UnityEngine.Vector3]) declare in UnityEngine.Transform
bool w_vtS_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_i4_S_S_p_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             
    // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetValueDirect(TypedReference, System.Object) declare in System.Reflection.FieldInfo
bool w_vtS_S_p_pp_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_p_pp_O");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_S_p_pp_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetTRS(UnityEngine.RectTransform, com.pixui.PxTRS) declare in com.pixui.PxMisc
bool w_vtS_S_r4r4_r4S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4_r4S_r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_r4r4_r4S_r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4_r4S_r4r4__>(apis, env, _sv0);
    S_S_r4r4_r4S_r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4_r4S_r4r4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_r4r4_r4S_r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void PlayEnterAnim(RectRtRecord, System.Action) declare in Assets.Scripts.UI.CardComponent.Item.UICardGroup
bool w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_Do");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ {};
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void set_localBounds(UnityEngine.Bounds) declare in UnityEngine.Animation
bool w_vtS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_S_r4r4r4_S_r4r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void LuaCallRefreshUI(Assets.Scripts.UI.InTheGame.OSO.OSOLineupLordShowInfo) declare in Assets.Scripts.UI.InTheGame.OSO.UIOSOLord
bool w_vtS_bu4i4si4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_bu4i4si4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_bu4i4si4_* pp0 = DataTransfer::GetPointer<S_bu4i4si4_>(apis, env, _sv0);
    S_bu4i4si4_ p0 = pp0 ? *pp0 : S_bu4i4si4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_bu4i4si4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_scene(UnityEngine.SceneManagement.Scene) declare in UnityEngine.Camera
bool w_vtS_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void NBResetCardDragCoord(VInt2) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_vtS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void NBResetDragCoord(VInt2, VInt2, Boolean, Boolean) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_vtS_i4i4_S_i4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_S_i4i4_bb");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             
    // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, struct S_i4i4_ p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void NBSetSceneTipGridFeetFlags(VInt2, Boolean) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_vtS_i4i4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void NBSetDragEquipHeroFeetFlags(VInt2, Boolean, Boolean) declare in Assets.Scripts.GameSystem.UIComponentNewbie
bool w_vtS_i4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_bb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void AddGrid(VInt2, UnityEngine.GameObject) declare in Assets.Scripts.GameLogic.Project8BattleField
bool w_vtS_i4i4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4_o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_i4i4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayMoveEffect(VInt3) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_bakingOutput(UnityEngine.LightBakingOutput) declare in UnityEngine.Light
bool w_vtS_i4i4i4i4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4b_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4b_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4b_>(apis, env, _sv0);
    S_i4i4i4i4b_ p0 = pp0 ? *pp0 : S_i4i4i4i4b_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_descriptor(UnityEngine.RenderTextureDescriptor) declare in UnityEngine.RenderTexture
bool w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_startColor(MinMaxGradient) declare in UnityEngine.ParticleSystem+MainModule
bool w_vtS_i4ooS_r4r4r4r4_S_r4r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4ooS_r4r4r4r4_S_r4r4r4r4__");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4ooS_r4r4r4r4_S_r4r4r4r4__* pp0 = DataTransfer::GetPointer<S_i4ooS_r4r4r4r4_S_r4r4r4r4__>(apis, env, _sv0);
    S_i4ooS_r4r4r4r4_S_r4r4r4r4__ p0 = pp0 ? *pp0 : S_i4ooS_r4r4r4r4_S_r4r4r4r4__ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4ooS_r4r4r4r4_S_r4r4r4r4__ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetTargetBuffers(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer) declare in UnityEngine.Camera
bool w_vtS_i4p_S_i4p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4p_S_i4p_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4p_* pp0 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv0);
    S_i4p_ p0 = pp0 ? *pp0 : S_i4p_ {};
             
    // LuaValToCSVal struct
    S_i4p_* pp1 = DataTransfer::GetPointer<S_i4p_>(apis, env, _sv1);
    S_i4p_ p1 = pp1 ? *pp1 : S_i4p_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4p_ p1, struct S_i4p_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void set_startDelay(MinMaxCurve) declare in UnityEngine.ParticleSystem+MainModule
bool w_vtS_i4r4oor4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4r4oor4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4r4oor4r4_* pp0 = DataTransfer::GetPointer<S_i4r4oor4r4_>(apis, env, _sv0);
    S_i4r4oor4r4_ p0 = pp0 ? *pp0 : S_i4r4oor4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4r4oor4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ChangeHudInfo(HPInfoRecord) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtS_i4u8r4b_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i4u8r4b_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i4u8r4b_* pp0 = DataTransfer::GetPointer<S_i4u8r4b_>(apis, env, _sv0);
    S_i4u8r4b_ p0 = pp0 ? *pp0 : S_i4u8r4b_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i4u8r4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_progress(Progress) declare in CurlUnity.CurlEasy
bool w_vtS_i8i8i8i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_i8i8i8i8_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_i8i8i8i8_* pp0 = DataTransfer::GetPointer<S_i8i8i8i8_>(apis, env, _sv0);
    S_i8i8i8i8_ p0 = pp0 ? *pp0 : S_i8i8i8i8_ {};
        
    typedef void (*FuncToCall)(void*,struct S_i8i8i8i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Pay(Assets.Scripts.SDK.PayParam) declare in Assets.Scripts.SDK.PayService
bool w_vtS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_o_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_o_* pp0 = DataTransfer::GetPointer<S_o_>(apis, env, _sv0);
    S_o_ p0 = pp0 ? *pp0 : S_o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_o_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetUpgradeHeroNumOffset(Project8UpgradeNumOffset) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_vtS_oo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oo_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_oo_* pp0 = DataTransfer::GetPointer<S_oo_>(apis, env, _sv0);
    S_oo_ p0 = pp0 ? *pp0 : S_oo_ {};
        
    typedef void (*FuncToCall)(void*,struct S_oo_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void Add(Data) declare in System.Collections.Generic.List`1[CMTweener+Data]
bool w_vtS_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_* pp0 = DataTransfer::GetPointer<S_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_>(apis, env, _sv0);
    S_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_ p0 = pp0 ? *pp0 : S_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_oosr4r4i4soooS_r4r4r4_S_r4r4r4_r4r4r4r4boi4osbor4bS_r4r4r4_i4r4i4oooi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void RecoverBeginNtf(CSRecoverEndInfo) declare in Assets.Scripts.Framework.CSRecoverSys
bool w_vtS_oou1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_oou1_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_oou1_* pp0 = DataTransfer::GetPointer<S_oou1_>(apis, env, _sv0);
    S_oou1_ p0 = pp0 ? *pp0 : S_oou1_ {};
        
    typedef void (*FuncToCall)(void*,struct S_oou1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetSize(UnityEngine.RectTransform, UnityEngine.Vector2) declare in Timi.TimiExtension
bool w_vtS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void UpdateCameraRelativeDisplacement(UnityEngine.Vector2, Boolean) declare in Moba_Camera
bool w_vtS_r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetContentRollManully(UnityEngine.Vector2, Single) declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_vtS_r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_Dr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void GetGenerationSettings(UnityEngine.Vector2, UnityEngine.TextGenerationSettings ByRef) declare in UnityEngine.UI.Text
bool w_vtS_r4r4_PS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_PS_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p1 = DataTransfer::GetPointer<S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Void SmartSetAnchor(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Vector2) declare in ExtRectTransform
bool w_vtS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetVirtualActorScreenPosition(UnityEngine.Vector2, UnityEngine.Vector3) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetTRS(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Vector3, UnityEngine.Vector3) declare in com.pixui.PxMisc
bool w_vtS_r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_r4r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void UpdateDragSaleArea(UnityEngine.Vector2, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_vtS_r4r4_S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_S_u4o_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             
    // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_u4o_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void UpdateCameraOffset(UnityEngine.Vector2, Single) declare in Moba_Camera
bool w_vtS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetTRS(UnityEngine.RectTransform, UnityEngine.Vector2, Single, UnityEngine.Vector2) declare in com.pixui.PxMisc
bool w_vtS_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4_r4S_r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
     
    // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, struct S_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetScale(UnityEngine.RectTransform, UnityEngine.Vector3) declare in com.pixui.PxMisc
bool w_vtS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetAbsoluteLockLocation(UnityEngine.Vector3, Boolean) declare in Moba_Camera
bool w_vtS_r4r4r4_Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void TweenDeltaOffset(UnityEngine.Vector3, Single) declare in Assets.Scripts.GameLogic.Project8FreeCamera
bool w_vtS_r4r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_Dr4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void LookAt(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_S_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ShowAndSetFieldTransform(UnityEngine.Vector3, Boolean, Boolean, Boolean) declare in Assets.Scripts.GameLogic.Project8ArtField
bool w_vtS_r4r4r4_bbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_bbDb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void SetFieldTransform(UnityEngine.Vector3, Boolean, Int32, Boolean) declare in Assets.Scripts.GameLogic.Project8BaseArtField
bool w_vtS_r4r4r4_bi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_bi4Db");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
 // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void Translate(UnityEngine.Vector3, UnityEngine.Space) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void PlayOSHCoinFlyEffectByUIPos(UnityEngine.Vector3, Assets.Scripts.UI.GameBanner.Item.PrizeBarFlyInEffectType, UnityEngine.RectTransform) declare in Assets.Scripts.UI.GameBanner.Item.UIGameBanner
bool w_vtS_r4r4r4_i4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_i4Do");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, Il2CppObject* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void Translate(UnityEngine.Vector3, UnityEngine.Transform) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, Il2CppObject* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Rotate(UnityEngine.Vector3, Single) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space) declare in UnityEngine.Transform
bool w_vtS_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_r4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void AttachMeshObject(UnityEngine.Vector3, UInt32) declare in Assets.Scripts.GameLogic.ActorMeshComponent
bool w_vtS_r4r4r4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4_u4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4_ p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetGraphicGrayPart(UnityEngine.UI.Graphic, UnityEngine.Vector4) declare in Assets.Scripts.Framework.UI.ExtGraphic
bool w_vtS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetColors(UnityEngine.Color, UnityEngine.Color) declare in UnityEngine.LineRenderer
bool w_vtS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_S_r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetSelfClipRect(UnityEngine.Rect, Boolean) declare in Timi.TimiImage
bool w_vtS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void ReadPixels(UnityEngine.Rect, Int32, Int32) declare in UnityEngine.Texture2D
bool w_vtS_r4r4r4r4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_i4i4");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
    return true;
}
// Void ReadPixels(UnityEngine.Rect, Int32, Int32, Boolean) declare in UnityEngine.Texture2D
bool w_vtS_r4r4r4r4_i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_i4i4b");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, int32_t p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void CrossFadeColor(UnityEngine.Color, Single, Boolean, Boolean) declare in UnityEngine.UI.Graphic
bool w_vtS_r4r4r4r4_r4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4bb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void CrossFadeColor(UnityEngine.Color, Single, Boolean, Boolean, Boolean) declare in UnityEngine.UI.Graphic
bool w_vtS_r4r4r4r4_r4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4bbb");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, bool p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
    return true;
}
// Void CalculateFrustumCorners(UnityEngine.Rect, Single, MonoOrStereoscopicEye, UnityEngine.Vector3[]) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4_r4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_r4i4o");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, int32_t p3, Il2CppObject* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
    return true;
}
// Void ChangeEnergyColor(UnityEngine.Color, UInt64) declare in Assets.Scripts.GameLogic.Hud3D
bool w_vtS_r4r4r4r4_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4_u8");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);

    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, uint64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void SetMatrix(UnityEngine.RectTransform, com.pixui.NativeMatrix) declare in com.pixui.PxMisc
bool w_vtS_r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void set_cullingMatrix(UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void SetStereoViewMatrices(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4) declare in UnityEngine.Camera
bool w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
             
    // LuaValToCSVal struct
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);
    return true;
}
// Void InitPay(Assets.Scripts.SDK.PayInitParam) declare in Assets.Scripts.SDK.PayService
bool w_vtS_ssso_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_ssso_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_ssso_* pp0 = DataTransfer::GetPointer<S_ssso_>(apis, env, _sv0);
    S_ssso_ p0 = pp0 ? *pp0 : S_ssso_ {};
        
    typedef void (*FuncToCall)(void*,struct S_ssso_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void RemoveGlobalKeywordStateImpl(UnityEngine.Rendering.GlobalKeyword) declare in UnityEngine.MaterialPropertyBlock
bool w_vtS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_su4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_su4_* pp0 = DataTransfer::GetPointer<S_su4_>(apis, env, _sv0);
    S_su4_ p0 = pp0 ? *pp0 : S_su4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_su4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
// Void ChangeCustomCoin(CustomCoinChangeParam) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_vtS_u1i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_vtS_u1i4i4_");
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     
    // LuaValToCSVal struct
    S_u1i4i4_* pp0 = DataTransfer::GetPointer<S_u1i4i4_>(apis, env, _sv0);
    S_u1i4i4_ p0 = pp0 ? *pp0 : S_u1i4i4_ {};
        
    typedef void (*FuncToCall)(void*,struct S_u1i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);
    return true;
}
}

